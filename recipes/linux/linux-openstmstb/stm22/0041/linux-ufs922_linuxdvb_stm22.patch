diff -rcN linux/drivers/media/dvb/dvb-core/compat.h UFS922_Orig/drivers/media/dvb/dvb-core/compat.h
*** linux/drivers/media/dvb/dvb-core/compat.h	1970-01-01 01:00:00.000000000 +0100
--- UFS922_Orig/drivers/media/dvb/dvb-core/compat.h	2009-02-10 19:24:55.000000000 +0100
***************
*** 0 ****
--- 1,378 ----
+ /*
+  * $Id: compat.h,v 1.44 2006/01/15 09:35:16 mchehab Exp $
+  */
+ 
+ #ifndef _COMPAT_H
+ #define _COMPAT_H
+ 
+ /* sylvester */
+ #include <linux/version.h>
+ 
+ #if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,18)
+ # define minor(x) MINOR(x)
+ #endif
+ 
+ #if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+ # include <linux/delay.h>
+ # define need_resched() (current->need_resched)
+ # define work_struct tq_struct
+ #endif
+ 
+ #if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,19)
+ # define BUG_ON(condition) do { if ((condition)!=0) BUG(); } while(0)
+ #endif
+ 
+ #if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,23)
+ # define irqreturn_t void
+ # define IRQ_RETVAL(foobar)
+ #endif
+ 
+ #if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,71)
+ # define strlcpy(dest,src,len) strncpy(dest,src,(len)-1)
+ #endif
+ 
+ #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+ # define iminor(inode) minor(inode->i_rdev)
+ #endif
+ 
+ #if defined(I2C_ADAP_CLASS_TV_ANALOG) && !defined(I2C_CLASS_TV_ANALOG)
+ # define  I2C_CLASS_TV_ANALOG  I2C_ADAP_CLASS_TV_ANALOG
+ # define  I2C_CLASS_TV_DIGITAL I2C_ADAP_CLASS_TV_DIGITAL
+ #endif
+ 
+ #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,9)
+ # define __user
+ # define __kernel
+ # define __iomem
+ #endif
+ 
+ #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,11)
+ # define pm_message_t                      u32
+ # define pci_choose_state(pci_dev, state)  (state)
+ # define PCI_D0                            (0)
+ # define assert_spin_locked(foobar)
+ #endif
+ 
+ /* Since v4l-dvb now includes it's own copy of linux/i2c-id.h these
+    are no longer necessary */
+ /*
+ #if !defined(I2C_ALGO_SAA7134)
+ #define I2C_ALGO_SAA7134 I2C_HW_B_BT848
+ #endif
+ #if !defined(I2C_HW_B_CX2388x)
+ # define I2C_HW_B_CX2388x I2C_HW_B_BT848
+ #endif
+ #if !defined(I2C_HW_SAA7134)
+ # define I2C_HW_SAA7134 I2C_ALGO_SAA7134
+ #endif
+ #if !defined(I2C_HW_SAA7146)
+ # define I2C_HW_SAA7146 I2C_ALGO_SAA7146
+ #endif
+ #if !defined(I2C_HW_B_EM2820)
+ #define I2C_HW_B_EM2820 0x99
+ #endif
+ */
+ 
+ #ifndef I2C_M_IGNORE_NAK
+ # define I2C_M_IGNORE_NAK 0x1000
+ #endif
+ 
+ /* v4l-dvb uses an out of kernel copy of i2c-id.h, which does not have
+    some stuff that previous versions of i2c-id.h defined. */
+ #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,14) && defined(LINUX_I2C_ID_H)
+ # define I2C_ALGO_BIT 0x010000
+ #endif
+ 
+ #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,9)
+ #define __le32 __u32
+ #endif
+ 
+ #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)) && (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,7))
+ static inline unsigned long msecs_to_jiffies(const unsigned int m)
+ {
+ #if HZ <= 1000 && !(1000 % HZ)
+ 	return (m + (1000 / HZ) - 1) / (1000 / HZ);
+ #else
+ #if HZ > 1000 && !(HZ % 1000)
+ 	return m * (HZ / 1000);
+ #else
+ 	return (m * HZ + 999) / 1000;
+ #endif
+ #endif
+ }
+ static inline unsigned int jiffies_to_msecs(const unsigned long j)
+ {
+ #if HZ <= 1000 && !(1000 % HZ)
+ 	return (1000 / HZ) * j;
+ #else
+ #if HZ > 1000 && !(HZ % 1000)
+ 	return (j + (HZ / 1000) - 1)/(HZ / 1000);
+ #else
+ 	return (j * 1000) / HZ;
+ #endif
+ #endif
+ }
+ static inline void msleep(unsigned int msecs)
+ {
+ 	unsigned long timeout = msecs_to_jiffies(msecs);
+ 	while (timeout) {
+ 		set_current_state(TASK_UNINTERRUPTIBLE);
+ 		timeout = schedule_timeout(timeout);
+ 	}
+ }
+ #endif
+ 
+ #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)) && LINUX_VERSION_CODE < KERNEL_VERSION(2,6,9)
+ static inline unsigned long msleep_interruptible(unsigned int msecs)
+ {
+ 	unsigned long timeout = msecs_to_jiffies(msecs);
+ 
+ 	while (timeout) {
+ 		set_current_state(TASK_INTERRUPTIBLE);
+ 		timeout = schedule_timeout(timeout);
+ 	}
+ 	return jiffies_to_msecs(timeout);
+ }
+ #endif
+ 
+ #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+ /* some keys from 2.6.x which are not (yet?) in 2.4.x */
+ # define KEY_PLAY                207
+ # define KEY_PRINT		 210
+ # define KEY_EMAIL         215
+ # define KEY_SEARCH              217
+ # define KEY_SELECT 		 0x161
+ # define KEY_GOTO                0x162
+ # define KEY_INFO                0x166
+ # define KEY_CHANNEL             0x16b
+ # define KEY_LANGUAGE            0x170
+ # define KEY_SUBTITLE		 0x172
+ # define KEY_ZOOM                0x174
+ # define KEY_MODE		 0x175
+ # define KEY_TV                  0x179
+ # define KEY_CD                  0x17f
+ # define KEY_TUNER               0x182
+ # define KEY_TEXT                0x184
+ # define KEY_DVD		 0x185
+ # define KEY_AUDIO               0x188
+ # define KEY_VIDEO               0x189
+ # define KEY_RED                 0x18e
+ # define KEY_GREEN               0x18f
+ # define KEY_YELLOW              0x190
+ # define KEY_BLUE                0x191
+ # define KEY_CHANNELUP           0x192
+ # define KEY_CHANNELDOWN         0x193
+ # define KEY_RESTART		 0x198
+ # define KEY_SHUFFLE     	 0x19a
+ # define KEY_NEXT                0x197
+ # define KEY_RADIO               0x181
+ # define KEY_PREVIOUS            0x19c
+ # define KEY_MHP                 0x16f
+ # define KEY_EPG                 0x16d
+ # define KEY_FASTFORWARD         208
+ # define KEY_LIST                0x18b
+ # define KEY_LAST                0x195
+ # define KEY_CLEAR               0x163
+ # define KEY_AUX                 0x186
+ # define KEY_SCREEN              0x177
+ # define KEY_PC                  0x178
+ # define KEY_MEDIA               226
+ # define KEY_SLOW                0x199
+ # define KEY_OK                  0x160
+ # define KEY_DIGITS              0x19d
+ #endif
+ #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,14)
+ # define KEY_SEND		231
+ # define KEY_REPLY		232
+ # define KEY_FORWARDMAIL	233
+ # define KEY_SAVE		234
+ # define KEY_DOCUMENTS		235
+ #endif
+ 
+ #if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+ #define container_of(ptr, type, member) ({                      \
+ 	const typeof( ((type *)0)->member ) *__mptr = (ptr);    \
+ 	(type *)( (char *)__mptr - offsetof(type,member) );})
+ #endif
+ 
+ #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,10)
+ #include <linux/mm.h>
+ static inline unsigned long vmalloc_to_pfn(void * vmalloc_addr)
+ {
+     return page_to_pfn(vmalloc_to_page(vmalloc_addr));
+ }
+ 
+ #ifndef wait_event_timeout
+ #define wait_event_timeout(wq, condition, timeout)                   	     \
+ ({                                                                           \
+      long __ret = timeout;                                                   \
+      if (!(condition))                                                       \
+      do {                                                                    \
+ 	     DEFINE_WAIT(__wait);                                            \
+ 	     for (;;) {                                                      \
+ 		     prepare_to_wait(&wq, &__wait, TASK_UNINTERRUPTIBLE);    \
+ 		     if (condition)                                          \
+ 			 break;                                              \
+ 		     __ret = schedule_timeout(__ret);                        \
+ 		     if (!__ret)                                             \
+ 			 break;                                              \
+ 	     }                                                               \
+ 	     finish_wait(&wq, &__wait);                                      \
+      } while (0);							     \
+      __ret;                                                                  \
+ })
+ #endif
+ 
+ #define remap_pfn_range remap_page_range
+ 
+ #endif
+ 
+ /* vm_insert_page() was added in 2.6.15 */
+ #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,15) && defined(_LINUX_MM_H)
+ static inline int vm_insert_page(struct vm_area_struct *vma,
+ 	unsigned long addr, struct page *page)
+ {
+ 	return remap_pfn_range(vma, addr, page_to_pfn(page), PAGE_SIZE,
+ 			       vma->vm_page_prot);
+ }
+ #endif
+ 
+ #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,9)
+ #ifndef kcalloc
+ #define kcalloc(n,size,flags)			\
+ ({						\
+   void * __ret = NULL;				\
+   __ret = kmalloc(n * size, flags);		\
+   if (__ret)					\
+ 	 memset(__ret, 0, n * size);		\
+   __ret;					\
+ })
+ #endif
+ #endif
+ 
+ /* try_to_freeze() lost its argument.  Must appear after linux/sched.h */
+ #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,13) && defined(_LINUX_SCHED_H)
+ # if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+ #  define try_to_freeze() try_to_freeze(PF_FREEZE)
+ # else
+ #  define try_to_freeze() (0)
+ # endif
+ #endif
+ 
+ #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,14)
+ #ifndef kzalloc
+ #define kzalloc(size, flags)				\
+ ({							\
+ 	void *__ret = kmalloc(size, flags);		\
+ 	if (__ret)					\
+ 		memset(__ret, 0, size);			\
+ 	__ret;						\
+ })
+ #endif
+ #endif
+ 
+ /* The class_device system didn't appear until 2.5.69 */
+ #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+ #define class_device_create_file(a, b) (0)
+ #endif
+ 
+ #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,13)
+ # define class_device_create(a, b, c, d, e, f, g, h) class_simple_device_add(a, c, d, e, f, g, h)
+ # define class_device_destroy(a, b) class_simple_device_remove(b)
+ # define class_create(a, b) class_simple_create(a, b)
+ # define class_destroy(a) class_simple_destroy(a)
+ #else
+ #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,15)
+ # define class_device_create(a, b, c, d, e, f, g, h) class_device_create(a, c, d, e, f, g, h)
+ #endif
+ #endif
+ 
+ #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,15)
+ # define input_allocate_device() kzalloc(sizeof(struct input_dev),GFP_KERNEL);
+ # define input_free_device(input_dev) kfree(input_dev)
+ # ifdef _INPUT_H  /* input.h must be included _before_ compat.h for this to work */
+    /* input_register_device() was changed to return an error code in 2.6.15 */
+ #  define input_register_device(x) (input_register_device(x), 0)
+ # endif
+ #endif
+ 
+ #if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,15)
+ #define DEFINE_MUTEX(a) DECLARE_MUTEX(a)
+ #define mutex_lock_interruptible(a) down_interruptible(a)
+ #define mutex_unlock(a) up(a)
+ #define mutex_lock(a) down(a)
+ #define mutex_init(a) init_MUTEX(a)
+ #define mutex_trylock(a) down_trylock(a)
+ #endif
+ 
+ #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,14) && defined(_LINUX_SCHED_H)
+ static inline signed long __sched
+ schedule_timeout_interruptible(signed long timeout)
+ {
+ 	__set_current_state(TASK_INTERRUPTIBLE);
+ 	return schedule_timeout(timeout);
+ }
+ #endif
+ 
+ /* New 4GB DMA zone was added in 2.6.15-rc2 */
+ #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,15)
+ #  define __GFP_DMA32	__GFP_DMA
+ #endif
+ 
+ /* setup_timer() helper added 10/31/05, 2.6.15-rc1 */
+ /* Need linux/timer.h to be included for struct timer_list */
+ #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,15) && defined(_LINUX_TIMER_H)
+ static inline void setup_timer(struct timer_list * timer,
+ 			       void (*function)(unsigned long),
+ 			       unsigned long data)
+ {
+ 	timer->function = function;
+ 	timer->data = data;
+ 	init_timer(timer);
+ }
+ #endif
+ 
+ #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)
+ #define IRQF_SHARED		SA_SHIRQ
+ #define IRQF_DISABLED		SA_INTERRUPT
+ #endif
+ 
+ /* linux/usb.h must be included _before_ compat.h for this code to get
+    turned on.  We can not just include usb.h here, because there is a
+    lot of code which will not compile if it has usb.h included, due to
+    conflicts with symbol names.  */
+ #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,13) && \
+     defined(__LINUX_USB_H) && defined(_INPUT_H)
+ #include <linux/input.h>
+ /* Found in linux/usb_input.h in 2.6.13 */
+ /* Moved to linux/usb/input.h in 2.6.18 */
+ static inline void
+ usb_to_input_id(const struct usb_device *dev, struct input_id *id)
+ {
+ 	id->bustype = BUS_USB;
+ 	id->vendor = le16_to_cpu(dev->descriptor.idVendor);
+ 	id->product = le16_to_cpu(dev->descriptor.idProduct);
+ 	id->version = le16_to_cpu(dev->descriptor.bcdDevice);
+ }
+ #endif
+ 
+ #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+ # define PCIAGP_FAIL 0
+ 
+ #define vmalloc_32_user(a) vmalloc_32(a)
+ 
+ #endif
+ 
+ /* bool type and enum-based definition of true and false was added in 2.6.19 */
+ #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,19)
+ typedef int bool;
+ #define true 1
+ #define false 0
+ #endif
+ 
+ #endif
+ /*
+  * Local variables:
+  * c-basic-offset: 8
+  * End:
+  */
diff -rcN linux/drivers/media/dvb/dvb-core/dmxdev.c UFS922_Orig/drivers/media/dvb/dvb-core/dmxdev.c 
*** linux/drivers/media/dvb/dvb-core/dmxdev.c	2006-06-18 03:49:35.000000000 +0200
--- UFS922_Orig//drivers/media/dvb/dvb-core//dmxdev.c 2009-02-10 19:24:55.000000000 +0100
***************
*** 25,31 ****
  #include <linux/vmalloc.h>
  #include <linux/module.h>
  #include <linux/moduleparam.h>
- #include <linux/sched.h>
  #include <linux/poll.h>
  #include <linux/ioctl.h>
  #include <linux/wait.h>
--- 25,30 ----
***************
*** 181,188 ****
  	struct dvb_device *dvbdev = file->private_data;
  	struct dmxdev *dmxdev = dvbdev->priv;
  
! 	if (mutex_lock_interruptible(&dmxdev->mutex))
! 		return -ERESTARTSYS;
  
  	if ((file->f_flags & O_ACCMODE) == O_WRONLY) {
  		dmxdev->demux->disconnect_frontend(dmxdev->demux);
--- 180,186 ----
  	struct dvb_device *dvbdev = file->private_data;
  	struct dmxdev *dmxdev = dvbdev->priv;
  
! 	mutex_lock(&dmxdev->mutex);
  
  	if ((file->f_flags & O_ACCMODE) == O_WRONLY) {
  		dmxdev->demux->disconnect_frontend(dmxdev->demux);
***************
*** 674,686 ****
  static int dvb_dmxdev_filter_free(struct dmxdev *dmxdev,
  				  struct dmxdev_filter *dmxdevfilter)
  {
! 	if (mutex_lock_interruptible(&dmxdev->mutex))
! 		return -ERESTARTSYS;
! 
! 	if (mutex_lock_interruptible(&dmxdevfilter->mutex)) {
! 		mutex_unlock(&dmxdev->mutex);
! 		return -ERESTARTSYS;
! 	}
  
  	dvb_dmxdev_filter_stop(dmxdevfilter);
  	dvb_dmxdev_filter_reset(dmxdevfilter);
--- 672,679 ----
  static int dvb_dmxdev_filter_free(struct dmxdev *dmxdev,
  				  struct dmxdev_filter *dmxdevfilter)
  {
! 	mutex_lock(&dmxdev->mutex);
! 	mutex_lock(&dmxdevfilter->mutex);
  
  	dvb_dmxdev_filter_stop(dmxdevfilter);
  	dvb_dmxdev_filter_reset(dmxdevfilter);
***************
*** 872,880 ****
  		mutex_unlock(&dmxdevfilter->mutex);
  		break;
  
- 	case DMX_GET_EVENT:
- 		break;
- 
  	case DMX_GET_PES_PIDS:
  		if (!dmxdev->demux->get_pes_pids) {
  			ret = -EINVAL;
--- 865,870 ----
diff -rcN linux/drivers/media/dvb/dvb-core/dmxdev.h UFS922_Orig/drivers/media/dvb/dvb-core/dmxdev.h
*** linux/drivers/media/dvb/dvb-core/dmxdev.h	2006-06-18 03:49:35.000000000 +0200
--- UFS922_Orig/drivers/media/dvb/dvb-core/dmxdev.h	2009-02-10 19:24:55.000000000 +0100
***************
*** 30,36 ****
--- 30,39 ----
  #include <linux/wait.h>
  #include <linux/fs.h>
  #include <linux/string.h>
+ #include "compat.h"
+ #if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,15)
  #include <linux/mutex.h>
+ #endif
  
  #include <linux/dvb/dmx.h>
  
***************
*** 73,79 ****
--- 76,86 ----
  	struct dmxdev *dev;
  	struct dvb_ringbuffer buffer;
  
+ #if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,15)
  	struct mutex mutex;
+ #else
+ 	struct semaphore mutex;
+ #endif
  
  	/* only for sections */
  	struct timer_list timer;
***************
*** 97,103 ****
--- 104,114 ----
  	struct dvb_ringbuffer dvr_buffer;
  #define DVR_BUFFER_SIZE (10*188*1024)
  
+ #if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,15)
  	struct mutex mutex;
+ #else
+ 	struct semaphore mutex;
+ #endif
  	spinlock_t lock;
  };
  
diff -rcN linux/drivers/media/dvb/dvb-core/dvb_ca_en50221.c UFS922_Orig//drivers/media/dvb/dvb-core/dvb_ca_en50221.c
*** linux/drivers/media/dvb/dvb-core/dvb_ca_en50221.c	2006-06-18 03:49:35.000000000 +0200
--- UFS922_Orig/drivers/media/dvb/dvb-core/dvb_ca_en50221.c	2009-05-30 14:11:56.000000000 +0200
***************
*** 41,54 ****
  #include "dvb_ca_en50221.h"
  #include "dvb_ringbuffer.h"
  
! static int dvb_ca_en50221_debug;
  
  module_param_named(cam_debug, dvb_ca_en50221_debug, int, 0644);
  MODULE_PARM_DESC(cam_debug, "enable verbose debug messages");
  
  #define dprintk if (dvb_ca_en50221_debug) printk
  
! #define INIT_TIMEOUT_SECS 10
  
  #define HOST_LINK_BUF_SIZE 0x200
  
--- 41,58 ----
  #include "dvb_ca_en50221.h"
  #include "dvb_ringbuffer.h"
  
! //Dagobert
! #include <linux/proc_fs.h>  	/* proc fs */
! 
! static int dvb_ca_en50221_debug = 1;
  
  module_param_named(cam_debug, dvb_ca_en50221_debug, int, 0644);
  MODULE_PARM_DESC(cam_debug, "enable verbose debug messages");
  
  #define dprintk if (dvb_ca_en50221_debug) printk
  
! static int INIT_TIMEOUT_SECS = 10;
! static int WAIT_FREE_TIMEOUT_SECS = 3;
  
  #define HOST_LINK_BUF_SIZE 0x200
  
***************
*** 114,123 ****
--- 118,159 ----
  	/* buffer for incoming packets */
  	struct dvb_ringbuffer rx_buffer;
  
+ 	/* wait queues for read() and write() operations */
+ 	wait_queue_head_t wait_queue;
+ 
  	/* timer used during various states of the slot */
  	unsigned long timeout;
+ 
+ 	/* Dagobert: Proc Entry */
+ 	struct proc_dir_entry* entry;
+ 
+ 	/* Dagobert Error Counters */
+ 	int	errorWaitReady;
+ 	int	errorStateValidate;
+ 	int	errorConfigOption;
+ 	int	errorWriteCamControl;
+ 	int	errorWaitFree;
+ 	int	errorInit;
+ 	int	errorRxBuffer;
+ 	int	errorLinkBufferSize;
+ 	int	errorLinkBufferSizeToSmall;
+ 	int	errorBufferEcount;
+ 
+ 	/* Dagobert Error Ignoring Status */
+ 	int	ignoreStateValidate;
+ 	int 	ignoreConfigOption;
+ 	int	ignoreWriteCamControl;
+ 	int 	ignoreWaitFree;
+ 	int	ignoreInit;
+ 
+ 	int	pollTime;
+ 
+ 	int	waitWrite;
+ 	int	camPollin;
+ 	int	camPollout;
  };
  
+ 
  /* Private CA-interface information */
  struct dvb_ca_private {
  
***************
*** 127,132 ****
--- 163,172 ----
  	/* the DVB device */
  	struct dvb_device *dvbdev;
  
+ 	/* Dagobert: the DVB CI devices */
+ 	struct dvb_device *dvbdev_ci[2];
+ 	int slot_states[2];
+ 
  	/* Flags describing the interface (DVB_CA_FLAG_*) */
  	u32 flags;
  
***************
*** 145,150 ****
--- 185,195 ----
  	/* Wait queue used when shutting thread down */
  	wait_queue_head_t thread_queue;
  
+ 	/* dagobert: since we have multiple (logical) devices
+ 	 * we should protect them
+ 	 */
+ 	struct mutex io_mutex;
+ 
  	/* Flag indicating when thread should exit */
  	unsigned int exit:1;
  
***************
*** 165,170 ****
--- 210,220 ----
  static int dvb_ca_en50221_read_data(struct dvb_ca_private *ca, int slot, u8 * ebuf, int ecount);
  static int dvb_ca_en50221_write_data(struct dvb_ca_private *ca, int slot, u8 * ebuf, int ecount);
  
+ //Dagobert: Hack
+ struct proc_dir_entry*  ci_dir;
+ 
+ struct dvb_ca_slot *ci0;
+ struct dvb_ca_slot *ci1;
  
  /**
   * Safely find needle in haystack.
***************
*** 368,375 ****
  	/* grab the next tuple length and type */
  	if ((_tupleType = ca->pub->read_attribute_mem(ca->pub, slot, _address)) < 0)
  		return _tupleType;
  	if (_tupleType == 0xff) {
! 		dprintk("END OF CHAIN TUPLE type:0x%x\n", _tupleType);
  		*address += 2;
  		*tupleType = _tupleType;
  		*tupleLength = 0;
--- 418,426 ----
  	/* grab the next tuple length and type */
  	if ((_tupleType = ca->pub->read_attribute_mem(ca->pub, slot, _address)) < 0)
  		return _tupleType;
+ 
  	if (_tupleType == 0xff) {
! 		dprintk("END OF CHAIN TUPLE type (%d) :0x%x\n", slot,_tupleType);
  		*address += 2;
  		*tupleType = _tupleType;
  		*tupleLength = 0;
***************
*** 593,599 ****
  	u8 buf[HOST_LINK_BUF_SIZE];
  	int i;
  
! 	dprintk("%s\n", __FUNCTION__);
  
  	/* check if we have space for a link buf in the rx_buffer */
  	if (ebuf == NULL) {
--- 644,653 ----
  	u8 buf[HOST_LINK_BUF_SIZE];
  	int i;
  
! 	/*dprintk("%s\n", __FUNCTION__);*/
! 
! 	/* dagobert */
!         mutex_lock(&ca->io_mutex);
  
  	/* check if we have space for a link buf in the rx_buffer */
  	if (ebuf == NULL) {
***************
*** 616,621 ****
--- 670,706 ----
  		goto exit;
  	if (!(status & STATUSREG_DA)) {
  		/* no data */
+ 
+ #ifdef mit
+ 
+ //if I try this next time I must remove
+ //I must think about the data to send
+ //byte[0] is not the connection I think
+ //byte[0] must be 0xa0 ?!?!?
+ 
+ 		/* so poll it */
+ 
+ 		/* dagobert: poll
+ 		 * ->see Spec Page 69 A.4.1.12
+ 		 * ->not sure if we meet all the parts in the spec (100ms ...)
+ 		 */
+ 		char fragbuf[HOST_LINK_BUF_SIZE];
+ 
+ 		fragbuf[0] = slot + 1 /* connection_id */;
+ 		fragbuf[1] = 0x00;
+ 		fragbuf[2] = 0xa0;
+ 		fragbuf[3] = 0x01 /* len */ ;
+ 		fragbuf[4] = slot + 1 /* connection_id */;
+ 
+ 		status = dvb_ca_en50221_write_data(ca, slot, fragbuf, 5);
+ 
+ 		if (status == 5)
+ 		{
+ 			printk("POLL Module %d\n", slot);
+ 		} else
+ 			printk("POLL FAILED for Module %d\n", slot);
+ 
+ #endif
  		status = 0;
  		goto exit;
  	}
***************
*** 631,643 ****
  	/* check it will fit */
  	if (ebuf == NULL) {
  		if (bytes_read > ca->slot_info[slot].link_buf_size) {
! 			printk("dvb_ca adapter %d: CAM tried to send a buffer larger than the link buffer size (%i > %i)!\n",
! 			       ca->dvbdev->adapter->num, bytes_read, ca->slot_info[slot].link_buf_size);
  			ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_LINKINIT;
  			status = -EIO;
  			goto exit;
  		}
  		if (bytes_read < 2) {
  			printk("dvb_ca adapter %d: CAM sent a buffer that was less than 2 bytes!\n",
  			       ca->dvbdev->adapter->num);
  			ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_LINKINIT;
--- 716,732 ----
  	/* check it will fit */
  	if (ebuf == NULL) {
  		if (bytes_read > ca->slot_info[slot].link_buf_size) {
! 			printk("dvb_ca adapter %d: CAM tried to send a buffer larger than the link buffer size (%i > %i) slot = %d!\n",
! 			       ca->dvbdev->adapter->num, bytes_read, ca->slot_info[slot].link_buf_size, slot);
  			ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_LINKINIT;
+ 			//Dagobert
+ 			ca->slot_info[slot].errorLinkBufferSize++;
  			status = -EIO;
  			goto exit;
  		}
  		if (bytes_read < 2) {
+ 			//Dagobert
+ 			ca->slot_info[slot].errorLinkBufferSizeToSmall++;
  			printk("dvb_ca adapter %d: CAM sent a buffer that was less than 2 bytes!\n",
  			       ca->dvbdev->adapter->num);
  			ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_LINKINIT;
***************
*** 646,653 ****
  		}
  	} else {
  		if (bytes_read > ecount) {
! 			printk("dvb_ca adapter %d: CAM tried to send a buffer larger than the ecount size!\n",
! 			       ca->dvbdev->adapter->num);
  			status = -EIO;
  			goto exit;
  		}
--- 735,743 ----
  		}
  	} else {
  		if (bytes_read > ecount) {
! 			ca->slot_info[slot].errorBufferEcount++;
! 			printk("dvb_ca adapter %d: CAM tried to send a buffer larger than the ecount size (slot = %d)!\n",
! 			       ca->dvbdev->adapter->num, slot);
  			status = -EIO;
  			goto exit;
  		}
***************
*** 667,672 ****
--- 757,763 ----
  	if ((status = ca->pub->read_cam_control(ca->pub, slot, CTRLIF_STATUS)) < 0)
  		goto exit;
  	if (status & STATUSREG_RE) {
+ 		printk("read on slot %d failed ->state now linkinit\n", slot);
  		ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_LINKINIT;
  		status = -EIO;
  		goto exit;
***************
*** 688,698 ****
--- 779,793 ----
  
  	/* wake up readers when a last_fragment is received */
  	if ((buf[1] & 0x80) == 0x00) {
+ 		wake_up_interruptible(&ca->slot_info[slot].wait_queue);
  		wake_up_interruptible(&ca->wait_queue);
  	}
  	status = bytes_read;
  
  exit:
+ 	/* dagobert */
+         mutex_unlock(&ca->io_mutex);
+ 
  	return status;
  }
  
***************
*** 716,725 ****
  
  	dprintk("%s\n", __FUNCTION__);
  
- 
  	// sanity check
  	if (bytes_write > ca->slot_info[slot].link_buf_size)
  		return -EINVAL;
  
  	/* check if interface is actually waiting for us to read from it, or if a read is in progress */
  	if ((status = ca->pub->read_cam_control(ca->pub, slot, CTRLIF_STATUS)) < 0)
--- 811,825 ----
  
  	dprintk("%s\n", __FUNCTION__);
  
  	// sanity check
  	if (bytes_write > ca->slot_info[slot].link_buf_size)
+ 	{
+ 		printk("3. EINVAL\n");
  		return -EINVAL;
+ 	}
+ 
+ 	/* dagobert */
+         mutex_lock(&ca->io_mutex);
  
  	/* check if interface is actually waiting for us to read from it, or if a read is in progress */
  	if ((status = ca->pub->read_cam_control(ca->pub, slot, CTRLIF_STATUS)) < 0)
***************
*** 760,765 ****
--- 860,866 ----
  	if ((status = ca->pub->read_cam_control(ca->pub, slot, CTRLIF_STATUS)) < 0)
  		goto exit;
  	if (status & STATUSREG_WE) {
+ 		printk("write on slot %d failed ->state now linkinit\n", slot);
  		ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_LINKINIT;
  		status = -EIO;
  		goto exit;
***************
*** 773,778 ****
--- 874,882 ----
  	ca->pub->write_cam_control(ca->pub, slot, CTRLIF_COMMAND, IRQEN);
  
  exitnowrite:
+ 	/* dagobert */
+         mutex_unlock(&ca->io_mutex);
+ 
  	return status;
  }
  EXPORT_SYMBOL(dvb_ca_en50221_camchange_irq);
***************
*** 791,803 ****
   */
  static int dvb_ca_en50221_slot_shutdown(struct dvb_ca_private *ca, int slot)
  {
! 	dprintk("%s\n", __FUNCTION__);
  
  	ca->pub->slot_shutdown(ca->pub, slot);
  	ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_NONE;
  
  	/* need to wake up all processes to check if they're now
  	   trying to write to a defunct CAM */
  	wake_up_interruptible(&ca->wait_queue);
  
  	dprintk("Slot %i shutdown\n", slot);
--- 895,908 ----
   */
  static int dvb_ca_en50221_slot_shutdown(struct dvb_ca_private *ca, int slot)
  {
! 	dprintk("%s (slot %d)\n", __FUNCTION__, slot);
  
  	ca->pub->slot_shutdown(ca->pub, slot);
  	ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_NONE;
  
  	/* need to wake up all processes to check if they're now
  	   trying to write to a defunct CAM */
+ 	wake_up_interruptible(&ca->slot_info[slot].wait_queue);
  	wake_up_interruptible(&ca->wait_queue);
  
  	dprintk("Slot %i shutdown\n", slot);
***************
*** 1043,1057 ****
--- 1148,1167 ----
  				break;
  
  			case DVB_CA_SLOTSTATE_UNINITIALISED:
+ 				printk("DVB_CA_SLOTSTATE_UNINITIALISED %d\n", slot);
  				ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_WAITREADY;
  				ca->pub->slot_reset(ca->pub, slot);
  				ca->slot_info[slot].timeout = jiffies + (INIT_TIMEOUT_SECS * HZ);
  				break;
  
  			case DVB_CA_SLOTSTATE_WAITREADY:
+ 				printk("DVB_CA_SLOTSTATE_WAITREADY %d\n", slot);
  				if (time_after(jiffies, ca->slot_info[slot].timeout)) {
  					printk("dvb_ca adaptor %d: PC card did not respond :(\n",
  					       ca->dvbdev->adapter->num);
+ 
+ 					ca->slot_info[slot].errorWaitReady++;
+ 
  					ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_INVALID;
  					dvb_ca_en50221_thread_update_delay(ca);
  					break;
***************
*** 1060,1102 ****
  				break;
  
  			case DVB_CA_SLOTSTATE_VALIDATE:
! 				if (dvb_ca_en50221_parse_attributes(ca, slot)
! 				    != 0) {
! 					printk("dvb_ca adapter %d: Invalid PC card inserted :(\n",
! 					       ca->dvbdev->adapter->num);
! 					ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_INVALID;
! 					dvb_ca_en50221_thread_update_delay(ca);
! 					break;
  				}
  				if (dvb_ca_en50221_set_configoption(ca, slot) != 0) {
  					printk("dvb_ca adapter %d: Unable to initialise CAM :(\n",
  					       ca->dvbdev->adapter->num);
! 					ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_INVALID;
! 					dvb_ca_en50221_thread_update_delay(ca);
! 					break;
  				}
  				if (ca->pub->write_cam_control(ca->pub, slot,
  							       CTRLIF_COMMAND, CMDREG_RS) != 0) {
  					printk("dvb_ca adapter %d: Unable to reset CAM IF\n",
  					       ca->dvbdev->adapter->num);
! 					ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_INVALID;
! 					dvb_ca_en50221_thread_update_delay(ca);
! 					break;
  				}
! 				dprintk("DVB CAM validated successfully\n");
  
! 				ca->slot_info[slot].timeout = jiffies + (INIT_TIMEOUT_SECS * HZ);
  				ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_WAITFR;
  				ca->wakeup = 1;
  				break;
  
  			case DVB_CA_SLOTSTATE_WAITFR:
  				if (time_after(jiffies, ca->slot_info[slot].timeout)) {
  					printk("dvb_ca adapter %d: DVB CAM did not respond :(\n",
  					       ca->dvbdev->adapter->num);
! 					ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_INVALID;
! 					dvb_ca_en50221_thread_update_delay(ca);
! 					break;
  				}
  
  				flags = ca->pub->read_cam_control(ca->pub, slot, CTRLIF_STATUS);
--- 1170,1270 ----
  				break;
  
  			case DVB_CA_SLOTSTATE_VALIDATE:
! 				printk("DVB_CA_SLOTSTATE_VALIDATE %d\n", slot);
! 
! 				/*GustavGans: it seems that the validation process comes to early
! 				  if MPEG stream is turned on and MPEG bypassing is disabled
! 				  (the first tuple is invalid) */
! 				mdelay(100);
! 
! 				if (dvb_ca_en50221_parse_attributes(ca, slot) != 0) {
! 					/* we need this extra check for annoying interfaces like the budget-av */
! 					if ((!(ca->flags & DVB_CA_EN50221_FLAG_IRQ_CAMCHANGE)) &&
! 					    (ca->pub->poll_slot_status)) {
! 						int status = ca->pub->poll_slot_status(ca->pub, slot, 0);
! 						if (!(status & DVB_CA_EN50221_POLL_CAM_PRESENT)) {
! 							ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_NONE;
! 							dvb_ca_en50221_thread_update_delay(ca);
! 							break;
! 						}
! 					}
! 
! 					printk("dvb_ca adapter %d: Invalid PC card inserted (slot = %d) :(\n",
! 					       ca->dvbdev->adapter->num, slot);
! 
! 					//Dagobert
! 					ca->slot_info[slot].errorStateValidate++;
! 					if (ca->slot_info[slot].ignoreStateValidate == 0)
! 					{
! 				 	   ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_INVALID;
! 					   dvb_ca_en50221_thread_update_delay(ca);
! 				 	   break;
! 				        }
  				}
  				if (dvb_ca_en50221_set_configoption(ca, slot) != 0) {
  					printk("dvb_ca adapter %d: Unable to initialise CAM :(\n",
  					       ca->dvbdev->adapter->num);
! 					//Dagobert
! 					ca->slot_info[slot].errorConfigOption++;
! 					if (ca->slot_info[slot].ignoreConfigOption == 0)
! 					{
! 						ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_INVALID;
! 						dvb_ca_en50221_thread_update_delay(ca);
! 						break;
! 					}
  				}
  				if (ca->pub->write_cam_control(ca->pub, slot,
  							       CTRLIF_COMMAND, CMDREG_RS) != 0) {
+ 
  					printk("dvb_ca adapter %d: Unable to reset CAM IF\n",
  					       ca->dvbdev->adapter->num);
! 
! 					//Dagobert
! 					ca->slot_info[slot].errorWriteCamControl++;
! 					if (ca->slot_info[slot].ignoreWriteCamControl == 0)
! 					{
! 						ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_INVALID;
! 						dvb_ca_en50221_thread_update_delay(ca);
! 					        break;
! 					} else
! 					{
! 						//noop
! 					}
  				}
! 				dprintk("DVB CAM validated successfully (slot = %d)\n", slot);
  
! 				ca->slot_info[slot].timeout = jiffies + (WAIT_FREE_TIMEOUT_SECS * HZ);
  				ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_WAITFR;
  				ca->wakeup = 1;
  				break;
  
  			case DVB_CA_SLOTSTATE_WAITFR:
+ 				printk("DVB_CA_SLOTSTATE_WAITFR %d\n", slot);
+ #define old
+ #ifdef old
+ /* Dagobert: The Norm says that after setting the RS Bit (see state before) the module
+  * clears the buffer and sets the free bit (FR). But it seems so that older modules does not so,
+  * they set this bit after starting the negotiation.
+  * So we wait here and get a timeout. pvrmain does'nt this and starts the negotiation
+  * (bit SR) directly. Ok first it clears all bits but this seems not necessary at all.
+  */
  				if (time_after(jiffies, ca->slot_info[slot].timeout)) {
  					printk("dvb_ca adapter %d: DVB CAM did not respond :(\n",
  					       ca->dvbdev->adapter->num);
! 
! 					//Dagobert
! 					ca->slot_info[slot].errorWaitFree++;
! 					if (ca->slot_info[slot].ignoreWaitFree == 0)
! 					{
! 						ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_INVALID;
! 						dvb_ca_en50221_thread_update_delay(ca);
! 						break;
! 					} else
! 					{
! 					    ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_LINKINIT;
! 					    ca->wakeup = 1;
! 					    break;
! 					}
  				}
  
  				flags = ca->pub->read_cam_control(ca->pub, slot, CTRLIF_STATUS);
***************
*** 1104,1123 ****
  					ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_LINKINIT;
  					ca->wakeup = 1;
  				}
  				break;
  
  			case DVB_CA_SLOTSTATE_LINKINIT:
  				if (dvb_ca_en50221_link_init(ca, slot) != 0) {
  					printk("dvb_ca adapter %d: DVB CAM link initialisation failed :(\n", ca->dvbdev->adapter->num);
! 					ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_INVALID;
! 					dvb_ca_en50221_thread_update_delay(ca);
! 					break;
  				}
  
  				if (ca->slot_info[slot].rx_buffer.data == NULL) {
  					rxbuf = vmalloc(RX_BUFFER_SIZE);
  					if (rxbuf == NULL) {
  						printk("dvb_ca adapter %d: Unable to allocate CAM rx buffer :(\n", ca->dvbdev->adapter->num);
  						ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_INVALID;
  						dvb_ca_en50221_thread_update_delay(ca);
  						break;
--- 1272,1317 ----
  					ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_LINKINIT;
  					ca->wakeup = 1;
  				}
+ #else
+ 					ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_LINKINIT;
+ 					ca->wakeup = 1;
+ #endif
+ 
  				break;
  
  			case DVB_CA_SLOTSTATE_LINKINIT:
+ 				printk("DVB_CA_SLOTSTATE_LINKINIT %d\n", slot);
  				if (dvb_ca_en50221_link_init(ca, slot) != 0) {
+ 					/* we need this extra check for annoying interfaces like the budget-av */
+ 					if ((!(ca->flags & DVB_CA_EN50221_FLAG_IRQ_CAMCHANGE)) &&
+ 					    (ca->pub->poll_slot_status)) {
+ 						int status = ca->pub->poll_slot_status(ca->pub, slot, 0);
+ 						if (!(status & DVB_CA_EN50221_POLL_CAM_PRESENT)) {
+ 							ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_NONE;
+ 							dvb_ca_en50221_thread_update_delay(ca);
+ 							break;
+ 						}
+ 					}
+ 
  					printk("dvb_ca adapter %d: DVB CAM link initialisation failed :(\n", ca->dvbdev->adapter->num);
! 					//Dagobert
! 					ca->slot_info[slot].errorInit++;
! 					if (ca->slot_info[slot].ignoreInit == 0)
! 					{
! 						ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_INVALID;
! 						dvb_ca_en50221_thread_update_delay(ca);
! 						break;
! 					}
  				}
  
  				if (ca->slot_info[slot].rx_buffer.data == NULL) {
  					rxbuf = vmalloc(RX_BUFFER_SIZE);
  					if (rxbuf == NULL) {
  						printk("dvb_ca adapter %d: Unable to allocate CAM rx buffer :(\n", ca->dvbdev->adapter->num);
+ 
+ 						//Dagobert: this one cant be ignored I think
+ 						ca->slot_info[slot].errorRxBuffer++;
+ 
  						ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_INVALID;
  						dvb_ca_en50221_thread_update_delay(ca);
  						break;
***************
*** 1128,1134 ****
  				ca->pub->slot_ts_enable(ca->pub, slot);
  				ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_RUNNING;
  				dvb_ca_en50221_thread_update_delay(ca);
! 				printk("dvb_ca adapter %d: DVB CAM detected and initialised successfully\n", ca->dvbdev->adapter->num);
  				break;
  
  			case DVB_CA_SLOTSTATE_RUNNING:
--- 1322,1328 ----
  				ca->pub->slot_ts_enable(ca->pub, slot);
  				ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_RUNNING;
  				dvb_ca_en50221_thread_update_delay(ca);
! 				printk("dvb_ca adapter %d: DVB CAM detected and initialised successfully (slot = %d)\n", ca->dvbdev->adapter->num, slot);
  				break;
  
  			case DVB_CA_SLOTSTATE_RUNNING:
***************
*** 1138,1143 ****
--- 1332,1342 ----
  				// poll slots for data
  				pktcount = 0;
  				while ((status = dvb_ca_en50221_read_data(ca, slot, NULL, 0)) > 0) {
+ 					mutex_lock(&ca->io_mutex);
+ 					ca->slot_info[slot].camPollin = 1;
+ 					mutex_unlock(&ca->io_mutex);
+ 					//printk("\nPI\n\n");
+ 
  					if (!ca->open)
  						break;
  
***************
*** 1155,1160 ****
--- 1354,1376 ----
  						break;
  					}
  				}
+ 
+ 				/* wg pollwri: wake up poll waiters if there is nothing todo, so he can write some data */
+ 		 		if ((status = ca->pub->read_cam_control(ca->pub, slot, CTRLIF_STATUS)) >= 0)
+ 		 		{
+ 	            			if (!(status & STATUSREG_DA))
+ 						if (!(status & STATUSREG_RE))
+ 		           				if (status & STATUSREG_FR)
+ 			   				{
+ 								mutex_lock(&ca->io_mutex);
+ 								ca->slot_info[slot].camPollout = 1;
+ 								mutex_unlock(&ca->io_mutex);
+ 
+ 								wake_up_interruptible(&ca->slot_info[slot].wait_queue);
+ 								wake_up_interruptible(&ca->wait_queue);
+ 							}
+ 		 		}
+ 
  				break;
  			}
  		}
***************
*** 1195,1200 ****
--- 1411,1419 ----
  
  	switch (cmd) {
  	case CA_RESET:
+ 
+ //Dagobert: resetting only requested slot is good idea maybe :-/
+ #ifdef alt
  		for (slot = 0; slot < ca->slot_count; slot++) {
  			if (ca->slot_info[slot].slot_state != DVB_CA_SLOTSTATE_NONE) {
  				dvb_ca_en50221_slot_shutdown(ca, slot);
***************
*** 1204,1209 ****
--- 1423,1443 ----
  								     DVB_CA_EN50221_CAMCHANGE_INSERTED);
  			}
  		}
+ #else
+ 		for (slot = 0; slot < ca->slot_count; slot++) {
+ 			int mySlot = ((int) parg);
+ 
+ 			dprintk("mySlot = %d, searched %d\n", mySlot, slot);
+ 
+ 			if (mySlot != slot)
+ 			    continue;
+ 
+ 			dprintk("->reset %d\n", mySlot);
+ 
+ 			//dagobert: rest will be done in loop
+ 			ca->slot_info[slot].slot_state = DVB_CA_SLOTSTATE_UNINITIALISED;
+ 		}
+ #endif
  		ca->next_read_slot = 0;
  		dvb_ca_en50221_thread_wakeup(ca);
  		break;
***************
*** 1230,1235 ****
--- 1464,1474 ----
  			&& (ca->slot_info[info->num].slot_state != DVB_CA_SLOTSTATE_INVALID)) {
  			info->flags = CA_CI_MODULE_PRESENT;
  		}
+ 		//Dagobert
+ 		else
+ 		if (ca->slot_info[info->num].slot_state == DVB_CA_SLOTSTATE_INVALID)
+ 			info->flags = CA_CI_MODULE_INVALID;
+ 
  		if (ca->slot_info[info->num].slot_state == DVB_CA_SLOTSTATE_RUNNING) {
  			info->flags |= CA_CI_MODULE_READY;
  		}
***************
*** 1289,1310 ****
  
  	/* Incoming packet has a 2 byte header. hdr[0] = slot_id, hdr[1] = connection_id */
  	if (count < 2)
  		return -EINVAL;
! 
  	/* extract slot & connection id */
  	if (copy_from_user(&slot, buf, 1))
  		return -EFAULT;
  	if (copy_from_user(&connection_id, buf + 1, 1))
  		return -EFAULT;
  	buf += 2;
  	count -= 2;
  
  	/* check if the slot is actually running */
  	if (ca->slot_info[slot].slot_state != DVB_CA_SLOTSTATE_RUNNING)
  		return -EINVAL;
  
  	/* fragment the packets & store in the buffer */
  	while (fragpos < count) {
  		fraglen = ca->slot_info[slot].link_buf_size - 2;
  		if ((count - fragpos) < fraglen)
  			fraglen = count - fragpos;
--- 1528,1560 ----
  
  	/* Incoming packet has a 2 byte header. hdr[0] = slot_id, hdr[1] = connection_id */
  	if (count < 2)
+ 	{
+ 		printk("1. EINVAL\n");
  		return -EINVAL;
! 	}
  	/* extract slot & connection id */
  	if (copy_from_user(&slot, buf, 1))
  		return -EFAULT;
+ 
  	if (copy_from_user(&connection_id, buf + 1, 1))
  		return -EFAULT;
+ 
+ 	//Dagobert write out the message so we can debug problems better
+ 	//dprintk("0x%02x 0x%02x", slot, connection_id);
+ 
  	buf += 2;
  	count -= 2;
  
  	/* check if the slot is actually running */
  	if (ca->slot_info[slot].slot_state != DVB_CA_SLOTSTATE_RUNNING)
+ 	{
+ 		printk("2. EINVAL (slot = %d)\n", slot);
  		return -EINVAL;
+ 	}
  
  	/* fragment the packets & store in the buffer */
  	while (fragpos < count) {
+ 		int vLoop;
  		fraglen = ca->slot_info[slot].link_buf_size - 2;
  		if ((count - fragpos) < fraglen)
  			fraglen = count - fragpos;
***************
*** 1314,1319 ****
--- 1564,1575 ----
  		if ((status = copy_from_user(fragbuf + 2, buf + fragpos, fraglen)) != 0)
  			goto exit;
  
+ 		//Dagobert write out the message so we can debug problems better
+ 		dprintk("<fraglen = %d\n", fraglen);
+ 		for (vLoop = 0; vLoop < fraglen; vLoop++)
+ 			dprintk(" 0x%02x", fragbuf[vLoop + 2]);
+ 		dprintk("\nfraglen>\n");
+ 
  		timeout = jiffies + HZ / 2;
  		written = 0;
  		while (!time_after(jiffies, timeout)) {
***************
*** 1343,1348 ****
--- 1599,1605 ----
  	status = count + 2;
  
  exit:
+ 	ca->slot_info[slot].waitWrite = 0;
  	return status;
  }
  
***************
*** 1394,1399 ****
--- 1651,1688 ----
  }
  
  
+ //Dagobert
+ static int dvb_ca_en50221_io_read_condition_for_slot(struct dvb_ca_private *ca, int slot)
+ {
+ 	int idx;
+ 	size_t fraglen;
+ 	int connection_id = -1;
+ 	int found = 0;
+ 	u8 hdr[2];
+ 
+ 	if (ca->slot_info[slot].slot_state != DVB_CA_SLOTSTATE_RUNNING)
+ 		return 0;
+ 
+ 	if (ca->slot_info[slot].rx_buffer.data == NULL) {
+ 		return 0;
+ 	}
+ 
+ 	idx = dvb_ringbuffer_pkt_next(&ca->slot_info[slot].rx_buffer, -1, &fraglen);
+ 	while (idx != -1) {
+ 		dvb_ringbuffer_pkt_read(&ca->slot_info[slot].rx_buffer, idx, 0, hdr, 2, 0);
+ 		if (connection_id == -1)
+ 			connection_id = hdr[0];
+ 		if ((hdr[0] == connection_id) && ((hdr[1] & 0x80) == 0)) {
+ 			found = 1;
+ 			break;
+ 		}
+ 
+ 		idx = dvb_ringbuffer_pkt_next(&ca->slot_info[slot].rx_buffer, idx, &fraglen);
+ 	}
+ 
+ 	return found;
+ }
+ 
  /**
   * Implementation of read() syscall.
   *
***************
*** 1419,1424 ****
--- 1708,1715 ----
  	size_t fraglen;
  	int pktlen;
  	int dispose = 0;
+ 	/* Dagobert */
+ 	int ci_slot = -1;
  
  	dprintk("%s\n", __FUNCTION__);
  
***************
*** 1426,1443 ****
  	if (count < 2)
  		return -EINVAL;
  
  	/* wait for some data */
  	if ((status = dvb_ca_en50221_io_read_condition(ca, &result, &slot)) == 0) {
  
  		/* if we're in nonblocking mode, exit immediately */
  		if (file->f_flags & O_NONBLOCK)
  			return -EWOULDBLOCK;
! 
  		/* wait for some data */
! 		status = wait_event_interruptible(ca->wait_queue,
  						  dvb_ca_en50221_io_read_condition
  						  (ca, &result, &slot));
  	}
  	if ((status < 0) || (result < 0)) {
  		if (result)
  			return result;
--- 1717,1822 ----
  	if (count < 2)
  		return -EINVAL;
  
+ 	/* Dagobert */
+         if (dvbdev == ca->dvbdev_ci[0])
+ 		ci_slot = 0;
+ 	else
+         if (dvbdev == ca->dvbdev_ci[1])
+ 		ci_slot = 1;
+ 
+ 	if (ci_slot != -1)
+ 	{
+ 		/* is there something to read ? */
+ 		if ((status = dvb_ca_en50221_io_read_condition_for_slot(ca, ci_slot)) == 0) {
+ 
+ 		   /* if we're in nonblocking mode, exit immediately */
+ 		   if (file->f_flags & O_NONBLOCK)
+ 		   {
+ 			   return -EWOULDBLOCK;
+ 		   }
+ 
+ 		   /* wait for some data */
+ 		   status = wait_event_interruptible(ca->slot_info[ci_slot].wait_queue,
+ 						     dvb_ca_en50221_io_read_condition_for_slot
+ 						     (ca, ci_slot));
+ 
+ 		   dprintk("status = %d\n", status);	
+ 
+ 		}
+ 
+ 		if ((status < 0)) {
+ 			return status;
+ 		}
+ 
+ 		slot = ci_slot;
+ 
+ 		idx = dvb_ringbuffer_pkt_next(&ca->slot_info[slot].rx_buffer, -1, &fraglen);
+ 		pktlen = 2;
+ 		do {
+ 			if (idx == -1) {
+ 				printk("dvb_ca adapter %d: BUG: read packet ended before last_fragment encountered\n", ca->dvbdev->adapter->num);
+ 
+ 		                printk("pktlen = %d, fraglen = %d, count = %d, con_id = %d\n", pktlen, fraglen, count, connection_id);	
+ 		
+ 				status = -EIO;
+ 				goto exit;
+ 			}
+ 
+ 			dvb_ringbuffer_pkt_read(&ca->slot_info[slot].rx_buffer, idx, 0, hdr, 2, 0);
+ 			if (connection_id == -1)
+ 				connection_id = hdr[0];
+ 			if (hdr[0] == connection_id) {
+ 				if (pktlen < count) {
+ 					if ((pktlen + fraglen - 2) > count) {
+ 						fraglen = count - pktlen;
+ 					} else {
+ 						fraglen -= 2;
+ 					}
+ 
+ 					if ((status = dvb_ringbuffer_pkt_read(&ca->slot_info[slot].rx_buffer, idx, 2,
+ 									      buf + pktlen, fraglen, 1)) < 0) {
+ 						goto exit;
+ 					}
+ 					pktlen += fraglen;
+ 				}
+ 
+ 				if ((hdr[1] & 0x80) == 0)
+ 					last_fragment = 1;
+ 				dispose = 1;
+ 			}
+ 
+ 			idx2 = dvb_ringbuffer_pkt_next(&ca->slot_info[slot].rx_buffer, idx, &fraglen);
+ 			if (dispose)
+ 				dvb_ringbuffer_pkt_dispose(&ca->slot_info[slot].rx_buffer, idx);
+ 			idx = idx2;
+ 			dispose = 0;
+ 		} while (!last_fragment);
+ 
+ 		hdr[0] = slot;
+ 		hdr[1] = connection_id;
+ 
+ 		if ((status = copy_to_user(buf, hdr, 2)) != 0)
+ 			goto exit;
+ 
+ 		status = pktlen;
+ 
+ 		return status;
+ 	}
+ 
  	/* wait for some data */
  	if ((status = dvb_ca_en50221_io_read_condition(ca, &result, &slot)) == 0) {
  
  		/* if we're in nonblocking mode, exit immediately */
  		if (file->f_flags & O_NONBLOCK)
+ 		{
  			return -EWOULDBLOCK;
! 		}
  		/* wait for some data */
! 		status = wait_event_interruptible(ca->slot_info[slot].wait_queue,
  						  dvb_ca_en50221_io_read_condition
  						  (ca, &result, &slot));
  	}
+ 
  	if ((status < 0) || (result < 0)) {
  		if (result)
  			return result;
***************
*** 1485,1494 ****
--- 1864,1884 ----
  
  	hdr[0] = slot;
  	hdr[1] = connection_id;
+ 
  	if ((status = copy_to_user(buf, hdr, 2)) != 0)
  		goto exit;
  	status = pktlen;
  
+ #if 0
+ 	//Dagobert write out the message so we can debug problems better
+ 	{
+ 	   int vLoop;
+ 	   for (vLoop = 0; vLoop < pktlen; vLoop++)
+ 	      dprintk("0x%02x ", hdr[vLoop]);
+ 	   dprintk("\n");
+         }
+ #endif
+ 
  exit:
  	return status;
  }
***************
*** 1573,1587 ****
   *
   * @return Standard poll mask.
   */
  static unsigned int dvb_ca_en50221_io_poll(struct file *file, poll_table * wait)
  {
  	struct dvb_device *dvbdev = file->private_data;
  	struct dvb_ca_private *ca = dvbdev->priv;
  	unsigned int mask = 0;
- 	int slot;
  	int result = 0;
  
! 	dprintk("%s\n", __FUNCTION__);
  
  	if (dvb_ca_en50221_io_read_condition(ca, &result, &slot) == 1) {
  		mask |= POLLIN;
--- 1963,2098 ----
   *
   * @return Standard poll mask.
   */
+ #define x_debug
  static unsigned int dvb_ca_en50221_io_poll(struct file *file, poll_table * wait)
  {
  	struct dvb_device *dvbdev = file->private_data;
  	struct dvb_ca_private *ca = dvbdev->priv;
  	unsigned int mask = 0;
  	int result = 0;
+ 	int slot;
+ 	/* Dagobert */
+ 	int ci_slot = -1;
  
! #ifdef x_debug
! 	//dprintk("%s\n", __FUNCTION__);
! #endif
! 	/* Dagobert */
!         if (dvbdev == ca->dvbdev_ci[0])
! 		ci_slot = 0;
! 	else
!         if (dvbdev == ca->dvbdev_ci[1])
! 		ci_slot = 1;
! 
! 	if (ci_slot != -1)
! 	{
! #ifdef x_debug
! 		//dprintk("CI Slot = %d\n", ci_slot);
! 		//dprintk("%d ", ci_slot);
! #endif
! 
! 		/* get the desired slot from list and check for changed status
! 		 * ->e2 seems to want this only on removal of module and on errors
! 		 */
! 		if (ca->slot_info[ci_slot].slot_state != ca->slot_states[ci_slot])
! 		{
! #ifdef x_debug
! 			//dprintk("old %d, new %d (type %d)\n", ca->slot_states[ci_slot], ca->slot_info[ci_slot].slot_state, ca->slot_info[ci_slot].camchange_type);
! #endif
! 
! 			ca->slot_states[ci_slot] = ca->slot_info[ci_slot].slot_state;
! 
! 			if (ca->slot_info[ci_slot].camchange_type == DVB_CA_EN50221_CAMCHANGE_REMOVED)
! 			{
! 			   mask |= POLLPRI;
! #ifdef x_debug
! 			   printk("return POLLPRI on slot %d ->removed\n", ci_slot);
! #endif
! 
! 			   return mask;
! 			} else
! 			if (ca->slot_info[ci_slot].camchange_type == DVB_CA_EN50221_CAMCHANGE_INSERTED)
! 			{
! 			   if (ca->slot_info[ci_slot].slot_state == DVB_CA_SLOTSTATE_RUNNING)
! 			   {
! 			   	mask |= POLLPRI;
! #ifdef x_debug
! 			   printk("return POLLPRI on slot %d ->inserted\n", ci_slot);
! #endif
! 
! 			   	return mask;
! 			   }
! 			}
! 		}
! 
! 		mutex_lock(&ca->io_mutex);
! 		if(ca->slot_info[ci_slot].camPollout)
! 			mask |= POLLOUT;
! 
! 		if(ca->slot_info[ci_slot].camPollin)
! 			mask |= POLLIN;
! 
! 		ca->slot_info[ci_slot].camPollin = 0;
! 		ca->slot_info[ci_slot].camPollout = 0;
! 		mutex_unlock(&ca->io_mutex);
! 
! 		if(mask != 0)
! 		{
! 			return mask;
! 		}
! 
! 		/* wait for something to happen */
! 		poll_wait(file, &ca->slot_info[ci_slot].wait_queue, wait);
! 
! 		/* get the desired slot from list and check for changed status
! 		 * ->e2 seems to want this only on removal of module and on errors
! 		 */
! 		if (ca->slot_info[ci_slot].slot_state != ca->slot_states[ci_slot])
! 		{
! #ifdef x_debug
! 			dprintk("old %d, new %d (type %d)\n", ca->slot_states[ci_slot], ca->slot_info[ci_slot].slot_state, ca->slot_info[ci_slot].camchange_type);
! #endif
! 
! 			ca->slot_states[ci_slot] = ca->slot_info[ci_slot].slot_state;
! 
! 			if (ca->slot_info[ci_slot].camchange_type == DVB_CA_EN50221_CAMCHANGE_REMOVED)
! 			{
! 			   mask |= POLLPRI;
! #ifdef x_debug
! 			   printk("return POLLPRI on slot %d ->removed\n", ci_slot);
! #endif
! 
! 			   return mask;
! 			} else
! 			if (ca->slot_info[ci_slot].camchange_type == DVB_CA_EN50221_CAMCHANGE_INSERTED)
! 			{
! 			   if (ca->slot_info[ci_slot].slot_state == DVB_CA_SLOTSTATE_RUNNING)
! 			   {
! 			   	mask |= POLLPRI;
! #ifdef x_debug
! 			   printk("return POLLPRI on slot %d ->inserted\n", ci_slot);
! #endif
! 
! 			   	return mask;
! 			   }
! 			}
! 		}
! 
! 		mutex_lock(&ca->io_mutex);
! 		if(ca->slot_info[ci_slot].camPollout)
! 			mask |= POLLOUT;
! 
! 		if(ca->slot_info[ci_slot].camPollin)
! 			mask |= POLLIN;
! 
! 		ca->slot_info[ci_slot].camPollin = 0;
! 		ca->slot_info[ci_slot].camPollout = 0;
! 		mutex_unlock(&ca->io_mutex);
! 
! 		return mask;
! 	}
! 	
! 	/* normal caN handling */
  
  	if (dvb_ca_en50221_io_read_condition(ca, &result, &slot) == 1) {
  		mask |= POLLIN;
***************
*** 1621,1626 ****
--- 2132,2359 ----
  	.fops = &dvb_ca_fops,
  };
  
+ /* Dagobert */
+ static struct dvb_device dvbdev_ci[2] = {
+ {
+ 	.priv = NULL,
+ 	.users = 1,
+ 	.readers = 1,
+ 	.writers = 1,
+ 	.fops = &dvb_ca_fops,
+ },
+ {
+ 	.priv = NULL,
+ 	.users = 1,
+ 	.readers = 1,
+ 	.writers = 1,
+ 	.fops = &dvb_ca_fops,
+ }};
+ 
+ /* Dagobert proc */
+ #define stateValid 	"ignoreStateValidate"
+ #define configOption 	"ignoreConfigOption"
+ #define writeCamControl "ignoreWriteCamControl"
+ #define waitFree 	"ignoreWaitFree"
+ #define init 		"ignoreInit"
+ #define initTimeout     "initTimeout"
+ #define waitFreeTimeout "waitFreeTimeout"
+ #define cPollTime 	"pollTime"
+ 
+ void setValue(struct dvb_ca_slot * ci, char* str)
+ {
+ 	int value;
+ 
+ 	if (strncmp(str, stateValid, strlen(stateValid)) == 0)
+ 	{
+ 		sscanf(str + strlen(stateValid) + 1, "%d", &value);
+ 		printk("Set ignoreStateValidate to %d\n", value);
+ 		ci->ignoreStateValidate = value;
+ 	}
+ 	else
+ 	if (strncmp(str, configOption, strlen(configOption)) == 0)
+ 	{
+ 		sscanf(str + strlen(configOption) + 1, "%d", &value);
+ 		printk("Set ignoreConfigOption to %d\n", value);
+ 		ci->ignoreConfigOption = value;
+ 	}
+ 	else
+ 	if (strncmp(str, writeCamControl, strlen(writeCamControl)) == 0)
+ 	{
+ 		sscanf(str + strlen(writeCamControl) + 1, "%d", &value);
+ 		printk("Set ignoreWriteCamControl to %d\n", value);
+ 		ci->ignoreWriteCamControl = value;
+ 	}
+ 	else
+ 	if (strncmp(str, waitFree, strlen(waitFree)) == 0)
+ 	{
+ 		sscanf(str + strlen(waitFree) + 1, "%d", &value);
+ 		printk("Set ignoreWaitFree to %d\n", value);
+ 		ci->ignoreWaitFree = value;
+ 	}
+ 	else
+ 	if (strncmp(str, init, strlen(init)) == 0)
+ 	{
+ 		sscanf(str + strlen(init) + 1, "%d", &value);
+ 		printk("Set ignoreInit to %d\n", value);
+ 		ci->ignoreInit = value;
+ 	}
+ 	else
+ 	if (strncmp(str, initTimeout, strlen(initTimeout)) == 0)
+ 	{
+ 		sscanf(str + strlen(initTimeout) + 1, "%d", &value);
+ 		printk("Set initTimeout to %d\n", value);
+ 		INIT_TIMEOUT_SECS = value;
+ 	} else
+ 	if (strncmp(str, waitFreeTimeout, strlen(waitFreeTimeout)) == 0)
+ 	{
+ 		sscanf(str + strlen(waitFreeTimeout) + 1, "%d", &value);
+ 		printk("Set waitFreeTimeout to %d\n", value);
+ 		WAIT_FREE_TIMEOUT_SECS = value;
+ 	} else
+ 	if (strncmp(str, cPollTime, strlen(cPollTime)) == 0)
+ 	{
+ 		sscanf(str + strlen(cPollTime) + 1, "%d", &value);
+ 		printk("Set pollTime to %d\n", value);
+ 		ci->pollTime = value;
+ 	} else
+ 	  printk("not found\n");
+ }
+ 
+ char* strStatus(int state)
+ {
+ 	if (state == DVB_CA_SLOTSTATE_NONE)
+ 		return "NONE";
+ 	if (state == DVB_CA_SLOTSTATE_UNINITIALISED)
+ 		return "UNINITIALISED";
+ 	if (state == DVB_CA_SLOTSTATE_RUNNING)
+ 		return "RUNNING";
+ 	if (state == DVB_CA_SLOTSTATE_INVALID)
+ 		return "INVALID";
+ 	if (state == DVB_CA_SLOTSTATE_WAITREADY)
+ 		return "WAITREADY";
+ 	if (state == DVB_CA_SLOTSTATE_VALIDATE)
+ 		return "VALIDATE";
+ 	if (state == DVB_CA_SLOTSTATE_WAITFR)
+ 		return "WAITFR";
+ 	if (state == DVB_CA_SLOTSTATE_LINKINIT)
+ 		return "LINKINIT";
+ 	return "UNKNOWN";
+ }
+ 
+ int proc_ci0_read(char *page, char **start, off_t off, int count,int *eof, void *data_unused)
+ {
+ 	int len = 0;
+ 	printk("%s %d\n", __FUNCTION__, count);
+ 
+ 	len = sprintf(page, "ci0:\nCurrentStatus = %s\n\terrorWaitReady: %d\n\terrorStateValidate: %d\n\terrorConfigOption: %d\n\t\
+ errorWriteCamControl: %d\n\terrorWaitFree: %d\n\terrorInit: %d\n\terrorRxBuffer: %d\
+ \n\terrorLinkBufferSize: %d\n\terrorLinkBufferSizeToSmall: %d\n\terrorBufferEcount: %d\
+ \n\tignoreStateValidate: %d\n\tignoreConfigOption: %d\n\tignoreWriteCamControl: %d\
+ \n\tignoreWaitFree: %d\n\tignoreInit: %d\n\
+ \n\tinitTimeout (global): %d\n\twaitFreeTimeout (global): %d\n",
+ 			strStatus(ci0->slot_state),
+ 			ci0->errorWaitReady, ci0->errorStateValidate, ci0->errorConfigOption, ci0->errorWriteCamControl,
+ 			ci0->errorWaitFree, ci0->errorInit, ci0->errorRxBuffer,
+ 			ci0->errorLinkBufferSize, ci0->errorLinkBufferSizeToSmall, ci0->errorBufferEcount,
+ 			ci0->ignoreStateValidate, ci0->ignoreConfigOption, ci0->ignoreWriteCamControl,
+ 			ci0->ignoreWaitFree, ci0->ignoreInit,
+ 			INIT_TIMEOUT_SECS, WAIT_FREE_TIMEOUT_SECS);
+ 
+         return len;
+ }
+ 
+ int proc_ci0_write(struct file *file, const char __user *buf, unsigned long count, void *data)
+ {
+ 	char 		*page;
+ 	char		*myString;
+ 	ssize_t 	ret = -ENOMEM;
+ 
+ 	printk("%s %ld - ", __FUNCTION__, count);
+ 
+ 	page = (char *)__get_free_page(GFP_KERNEL);
+ 	if (page)
+ 	{
+ 		ret = -EFAULT;
+ 		if (copy_from_user(page, buf, count))
+ 			goto out;
+ 
+ 		myString = (char *) kmalloc(count + 1, GFP_KERNEL);
+ 
+ 		strncpy(myString, page, count);
+ 		myString[count] = '\0';
+ 
+ 		printk("%s\n", myString);
+ 
+ 		setValue(ci0, myString);
+ 
+ 		kfree(myString);
+ 	}
+ 
+ 	ret = count;
+ out:
+ 
+ 	free_page((unsigned long)page);
+ 	return ret;
+ 
+ }
+ 
+ int proc_ci1_read(char *page, char **start, off_t off, int count,int *eof, void *data_unused)
+ {
+ 	int len = 0;
+ 	printk("%s %d\n", __FUNCTION__, count);
+ 
+ 	len = sprintf(page, "ci1:\nCurrentStatus = %s\n\terrorWaitReady: %d\n\terrorStateValidate: %d\n\terrorConfigOption: %d\n\t\
+ errorWriteCamControl: %d\n\terrorWaitFree: %d\n\terrorInit: %d\n\terrorRxBuffer: %d\
+ \n\terrorLinkBufferSize: %d\n\terrorLinkBufferSizeToSmall: %d\n\terrorBufferEcount: %d\
+ \n\tignoreStateValidate: %d\n\tignoreConfigOption: %d\n\tignoreWriteCamControl: %d\
+ \n\tignoreWaitFree: %d\n\tignoreInit: %d\n\
+ \n\tinitTimeout (global): %d\n\twaitFreeTimeout (global): %d\n",
+ 			strStatus(ci1->slot_state),
+ 			ci1->errorWaitReady, ci1->errorStateValidate, ci1->errorConfigOption, ci1->errorWriteCamControl,
+ 			ci1->errorWaitFree, ci1->errorInit, ci1->errorRxBuffer,
+ 			ci1->errorLinkBufferSize, ci1->errorLinkBufferSizeToSmall, ci1->errorBufferEcount,
+ 			ci1->ignoreStateValidate, ci1->ignoreConfigOption, ci1->ignoreWriteCamControl,
+ 			ci1->ignoreWaitFree, ci1->ignoreInit,
+ 			INIT_TIMEOUT_SECS, WAIT_FREE_TIMEOUT_SECS);
+ 
+ 
+         return len;
+ }
+ 
+ int proc_ci1_write(struct file *file, const char __user *buf, unsigned long count, void *data)
+ {
+ 	char 		*page;
+ 	char		*myString;
+ 	ssize_t 	ret = -ENOMEM;
+ 
+ 	printk("%s %ld - ", __FUNCTION__, count);
+ 
+ 	page = (char *)__get_free_page(GFP_KERNEL);
+ 	if (page)
+ 	{
+ 		ret = -EFAULT;
+ 		if (copy_from_user(page, buf, count))
+ 			goto out;
+ 
+ 		myString = (char *) kmalloc(count + 1, GFP_KERNEL);
+ 
+ 		strncpy(myString, page, count);
+ 		myString[count] = '\0';
+ 
+ 		printk("%s\n", myString);
+ 
+ 		setValue(ci1, myString);
+ 
+ 		kfree(myString);
+ 	}
+ 
+ 	ret = count;
+ out:
+ 
+ 	free_page((unsigned long)page);
+ 	return ret;
+ 
+ }
  
  /* ******************************************************************************** */
  /* Initialisation/shutdown functions */
***************
*** 1660,1665 ****
--- 2393,2402 ----
  		ret = -ENOMEM;
  		goto error;
  	}
+ 
+ 	/* dagobert */
+         mutex_init(&ca->io_mutex);
+ 
  	init_waitqueue_head(&ca->wait_queue);
  	ca->thread_pid = 0;
  	init_waitqueue_head(&ca->thread_queue);
***************
*** 1674,1685 ****
--- 2411,2456 ----
  	if (ret)
  		goto error;
  
+ 	/* add proc entries for debug and for settings on different modules */
+ 	ci_dir = proc_mkdir("ci" ,  NULL);
+ 
  	/* now initialise each slot */
  	for (i = 0; i < slot_count; i++) {
  		memset(&ca->slot_info[i], 0, sizeof(struct dvb_ca_slot));
+ 
+ 		init_waitqueue_head(&ca->slot_info[i].wait_queue);
  		ca->slot_info[i].slot_state = DVB_CA_SLOTSTATE_NONE;
  		atomic_set(&ca->slot_info[i].camchange_count, 0);
  		ca->slot_info[i].camchange_type = DVB_CA_EN50221_CAMCHANGE_REMOVED;
+ 
+ 		/* Dagobert and add a ci device entry */
+ 	        ret = dvb_register_device(dvb_adapter, &ca->dvbdev_ci[i], &dvbdev_ci[i], ca, DVB_DEVICE_CI);
+ 		ca->slot_states[i] = DVB_CA_EN50221_CAMCHANGE_REMOVED;
+ 	        if (ret)
+ 		    printk("error creating ci device for slot %d\n", i);
+ 
+ 		//Dagobert: Hacky: dont know how to get data from proc read write functions so I share this here
+ 		//(maybe over kdev)?
+ 		if (i == 0)
+ 		{
+ 		   ca->slot_info[i].entry = create_proc_entry("ci0", 0, ci_dir);
+ 		   ci0 = &ca->slot_info[i];
+ 		   ci0->ignoreWaitFree = 1;
+ 		   ci0->pollTime = 100;
+ 		   ci0->waitWrite = 0;
+ 		   ca->slot_info[i].entry->read_proc = proc_ci0_read;
+ 		   ca->slot_info[i].entry->write_proc = proc_ci0_write;
+ 		} else
+ 		{
+ 		   ca->slot_info[i].entry = create_proc_entry("ci1", 0, ci_dir);
+ 		   ci1 = &ca->slot_info[i];
+ 		   ci1->ignoreWaitFree = 1;
+ 		   ci1->pollTime = 100;
+ 		   ci1->waitWrite = 0;
+ 		   ca->slot_info[i].entry->read_proc = proc_ci1_read;
+ 		   ca->slot_info[i].entry->write_proc = proc_ci1_write;
+ 
+ 		}
  	}
  
  	if (signal_pending(current)) {
diff -rcN linux/drivers/media/dvb/dvb-core/dvb_demux.c UFS922_Orig/drivers/media/dvb/dvb-core/dvb_demux.c
*** linux/drivers/media/dvb/dvb-core/dvb_demux.c	2006-06-18 03:49:35.000000000 +0200
--- UFS922_Orig/drivers/media/dvb/dvb-core//dvb_demux.c	2009-05-29 22:32:37.000000000 +0200
***************
*** 335,363 ****
  }
  
  static inline void dvb_dmx_swfilter_packet_type(struct dvb_demux_feed *feed,
! 						const u8 *buf)
  {
  	switch (feed->type) {
  	case DMX_TYPE_TS:
  		if (!feed->feed.ts.is_filtering)
  			break;
  		if (feed->ts_type & TS_PACKET) {
  			if (feed->ts_type & TS_PAYLOAD_ONLY)
! 				dvb_dmx_swfilter_payload(feed, buf);
  			else
! 				feed->cb.ts(buf, 188, NULL, 0, &feed->feed.ts,
  					    DMX_OK);
  		}
  		if (feed->ts_type & TS_DECODER)
  			if (feed->demux->write_to_decoder)
! 				feed->demux->write_to_decoder(feed, buf, 188);
  		break;
  
  	case DMX_TYPE_SEC:
  		if (!feed->feed.sec.is_filtering)
  			break;
! 		if (dvb_dmx_swfilter_section_packet(feed, buf) < 0)
  			feed->feed.sec.seclen = feed->feed.sec.secbufp = 0;
  		break;
  
  	default:
--- 335,378 ----
  }
  
  static inline void dvb_dmx_swfilter_packet_type(struct dvb_demux_feed *feed,
! 						const u8 *buf, int count)
  {
+ 	int i = 0;
+ 
  	switch (feed->type) {
  	case DMX_TYPE_TS:
  		if (!feed->feed.ts.is_filtering)
  			break;
  		if (feed->ts_type & TS_PACKET) {
  			if (feed->ts_type & TS_PAYLOAD_ONLY)
! 			{
! 				/* TODO: pass data en bloc */
! 				while(count > 0)
! 				{
! 				  dvb_dmx_swfilter_payload(feed, buf + i);
! 				  i += 188;
! 				  count -= 188;
! 				}
! 			}
  			else
! 				feed->cb.ts(buf, count, NULL, 0, &feed->feed.ts,
  					    DMX_OK);
  		}
  		if (feed->ts_type & TS_DECODER)
  			if (feed->demux->write_to_decoder)
! 				feed->demux->write_to_decoder(feed, buf, count);
  		break;
  
  	case DMX_TYPE_SEC:
  		if (!feed->feed.sec.is_filtering)
  			break;
! 		while(count > 0)
! 		{
! 		  if (dvb_dmx_swfilter_section_packet(feed, buf + i) < 0)
  			feed->feed.sec.seclen = feed->feed.sec.secbufp = 0;
+ 		  i += 188;
+ 		  count -= 188;
+ 		}
  		break;
  
  	default:
***************
*** 370,376 ****
  	((f)->feed.ts.is_filtering) &&					\
  	(((f)->ts_type & (TS_PACKET|TS_PAYLOAD_ONLY)) == TS_PACKET))
  
! static void dvb_dmx_swfilter_packet(struct dvb_demux *demux, const u8 *buf)
  {
  	struct dvb_demux_feed *feed;
  	struct list_head *pos, *head = &demux->feed_list;
--- 385,391 ----
  	((f)->feed.ts.is_filtering) &&					\
  	(((f)->ts_type & (TS_PACKET|TS_PAYLOAD_ONLY)) == TS_PACKET))
  
! static void dvb_dmx_swfilter_packet(struct dvb_demux *demux, const u8 *buf, int count)
  {
  	struct dvb_demux_feed *feed;
  	struct list_head *pos, *head = &demux->feed_list;
***************
*** 389,416 ****
  			continue;
  
  		if (feed->pid == pid) {
! 			dvb_dmx_swfilter_packet_type(feed, buf);
  			if (DVR_FEED(feed))
  				continue;
  		}
  
  		if (feed->pid == 0x2000)
! 			feed->cb.ts(buf, 188, NULL, 0, &feed->feed.ts, DMX_OK);
  	}
  }
  
  void dvb_dmx_swfilter_packets(struct dvb_demux *demux, const u8 *buf,
  			      size_t count)
  {
! 	spin_lock(&demux->lock);
! 
! 	while (count--) {
! 		if (buf[0] == 0x47)
! 			dvb_dmx_swfilter_packet(demux, buf);
! 		buf += 188;
  	}
  
! 	spin_unlock(&demux->lock);
  }
  
  EXPORT_SYMBOL(dvb_dmx_swfilter_packets);
--- 404,450 ----
  			continue;
  
  		if (feed->pid == pid) {
! 			dvb_dmx_swfilter_packet_type(feed, buf, count);
  			if (DVR_FEED(feed))
  				continue;
  		}
  
  		if (feed->pid == 0x2000)
! 			feed->cb.ts(buf, count, NULL, 0, &feed->feed.ts, DMX_OK);
  	}
  }
  
  void dvb_dmx_swfilter_packets(struct dvb_demux *demux, const u8 *buf,
  			      size_t count)
  {
! 	int first = 0;
! 	int next = 0;
! 	u16 pid, first_pid;
! 	int done = 0;
! //	spin_lock(&demux->lock);
! 
! 	while (count > 0) {
! 		first = next;
! 		first_pid = ts_pid(&buf[first]);
! 		while(count > 0)
! 		{
! 			count--;
! 			next += 188;
! 			done++;
! 			pid = ts_pid(&buf[next]);
! 			if((buf[next] != 0x47) || (pid != first_pid) || (done > 8))
! 			  break;
! 		}
! 		done = 0;
! 		if((buf[first] == 0x47) && ((next - first) > 0))
! 		{
! 		      spin_lock(&demux->lock);
! 		      dvb_dmx_swfilter_packet(demux, buf + first, next - first);
! 		      spin_unlock(&demux->lock);
! 		}
  	}
  
! //	spin_unlock(&demux->lock);
  }
  
  EXPORT_SYMBOL(dvb_dmx_swfilter_packets);
***************
*** 431,437 ****
  		}
  		memcpy(&demux->tsbuf[i], buf, j);
  		if (demux->tsbuf[0] == 0x47)
! 			dvb_dmx_swfilter_packet(demux, demux->tsbuf);
  		demux->tsbufp = 0;
  		p += j;
  	}
--- 465,471 ----
  		}
  		memcpy(&demux->tsbuf[i], buf, j);
  		if (demux->tsbuf[0] == 0x47)
! 			dvb_dmx_swfilter_packet(demux, demux->tsbuf, 188);
  		demux->tsbufp = 0;
  		p += j;
  	}
***************
*** 439,445 ****
  	while (p < count) {
  		if (buf[p] == 0x47) {
  			if (count - p >= 188) {
! 				dvb_dmx_swfilter_packet(demux, &buf[p]);
  				p += 188;
  			} else {
  				i = count - p;
--- 473,479 ----
  	while (p < count) {
  		if (buf[p] == 0x47) {
  			if (count - p >= 188) {
! 				dvb_dmx_swfilter_packet(demux, &buf[p], 188);
  				p += 188;
  			} else {
  				i = count - p;
***************
*** 473,495 ****
  			goto bailout;
  		}
  		memcpy(&demux->tsbuf[i], buf, j);
! 		if ((demux->tsbuf[0] == 0x47) | (demux->tsbuf[0] == 0xB8)) {
  			memcpy(tmppack, demux->tsbuf, 188);
  			if (tmppack[0] == 0xB8)
  				tmppack[0] = 0x47;
! 			dvb_dmx_swfilter_packet(demux, tmppack);
  		}
  		demux->tsbufp = 0;
  		p += j;
  	}
  
  	while (p < count) {
! 		if ((buf[p] == 0x47) | (buf[p] == 0xB8)) {
  			if (count - p >= 204) {
  				memcpy(tmppack, &buf[p], 188);
  				if (tmppack[0] == 0xB8)
  					tmppack[0] = 0x47;
! 				dvb_dmx_swfilter_packet(demux, tmppack);
  				p += 204;
  			} else {
  				i = count - p;
--- 507,529 ----
  			goto bailout;
  		}
  		memcpy(&demux->tsbuf[i], buf, j);
! 		if ((demux->tsbuf[0] == 0x47) || (demux->tsbuf[0] == 0xB8)) {
  			memcpy(tmppack, demux->tsbuf, 188);
  			if (tmppack[0] == 0xB8)
  				tmppack[0] = 0x47;
! 			dvb_dmx_swfilter_packet(demux, tmppack, 188);
  		}
  		demux->tsbufp = 0;
  		p += j;
  	}
  
  	while (p < count) {
! 		if ((buf[p] == 0x47) || (buf[p] == 0xB8)) {
  			if (count - p >= 204) {
  				memcpy(tmppack, &buf[p], 188);
  				if (tmppack[0] == 0xB8)
  					tmppack[0] = 0x47;
! 				dvb_dmx_swfilter_packet(demux, tmppack, 188);
  				p += 204;
  			} else {
  				i = count - p;
***************
*** 673,680 ****
  	struct dvb_demux *demux = feed->demux;
  	int ret;
  
! 	if (mutex_lock_interruptible(&demux->mutex))
! 		return -ERESTARTSYS;
  
  	if (feed->state < DMX_STATE_GO) {
  		mutex_unlock(&demux->mutex);
--- 707,713 ----
  	struct dvb_demux *demux = feed->demux;
  	int ret;
  
! 	mutex_lock(&demux->mutex);
  
  	if (feed->state < DMX_STATE_GO) {
  		mutex_unlock(&demux->mutex);
***************
*** 748,755 ****
  	struct dvb_demux *demux = (struct dvb_demux *)dmx;
  	struct dvb_demux_feed *feed = (struct dvb_demux_feed *)ts_feed;
  
! 	if (mutex_lock_interruptible(&demux->mutex))
! 		return -ERESTARTSYS;
  
  	if (feed->state == DMX_STATE_FREE) {
  		mutex_unlock(&demux->mutex);
--- 781,787 ----
  	struct dvb_demux *demux = (struct dvb_demux *)dmx;
  	struct dvb_demux_feed *feed = (struct dvb_demux_feed *)ts_feed;
  
! 	mutex_lock(&demux->mutex);
  
  	if (feed->state == DMX_STATE_FREE) {
  		mutex_unlock(&demux->mutex);
***************
*** 916,923 ****
  	struct dvb_demux *dvbdmx = dvbdmxfeed->demux;
  	int ret;
  
! 	if (mutex_lock_interruptible(&dvbdmx->mutex))
! 		return -ERESTARTSYS;
  
  	if (!dvbdmx->stop_feed) {
  		mutex_unlock(&dvbdmx->mutex);
--- 948,954 ----
  	struct dvb_demux *dvbdmx = dvbdmxfeed->demux;
  	int ret;
  
! 	mutex_lock(&dvbdmx->mutex);
  
  	if (!dvbdmx->stop_feed) {
  		mutex_unlock(&dvbdmx->mutex);
***************
*** 942,949 ****
  	struct dvb_demux_feed *dvbdmxfeed = (struct dvb_demux_feed *)feed;
  	struct dvb_demux *dvbdmx = dvbdmxfeed->demux;
  
! 	if (mutex_lock_interruptible(&dvbdmx->mutex))
! 		return -ERESTARTSYS;
  
  	if (dvbdmxfilter->feed != dvbdmxfeed) {
  		mutex_unlock(&dvbdmx->mutex);
--- 973,979 ----
  	struct dvb_demux_feed *dvbdmxfeed = (struct dvb_demux_feed *)feed;
  	struct dvb_demux *dvbdmx = dvbdmxfeed->demux;
  
! 	mutex_lock(&dvbdmx->mutex);
  
  	if (dvbdmxfilter->feed != dvbdmxfeed) {
  		mutex_unlock(&dvbdmx->mutex);
***************
*** 1016,1023 ****
  	struct dvb_demux_feed *dvbdmxfeed = (struct dvb_demux_feed *)feed;
  	struct dvb_demux *dvbdmx = (struct dvb_demux *)demux;
  
! 	if (mutex_lock_interruptible(&dvbdmx->mutex))
! 		return -ERESTARTSYS;
  
  	if (dvbdmxfeed->state == DMX_STATE_FREE) {
  		mutex_unlock(&dvbdmx->mutex);
--- 1046,1052 ----
  	struct dvb_demux_feed *dvbdmxfeed = (struct dvb_demux_feed *)feed;
  	struct dvb_demux *dvbdmx = (struct dvb_demux *)demux;
  
! 	mutex_lock(&dvbdmx->mutex);
  
  	if (dvbdmxfeed->state == DMX_STATE_FREE) {
  		mutex_unlock(&dvbdmx->mutex);
***************
*** 1126,1133 ****
  	if (demux->frontend)
  		return -EINVAL;
  
! 	if (mutex_lock_interruptible(&dvbdemux->mutex))
! 		return -ERESTARTSYS;
  
  	demux->frontend = frontend;
  	mutex_unlock(&dvbdemux->mutex);
--- 1155,1161 ----
  	if (demux->frontend)
  		return -EINVAL;
  
! 	mutex_lock(&dvbdemux->mutex);
  
  	demux->frontend = frontend;
  	mutex_unlock(&dvbdemux->mutex);
***************
*** 1138,1145 ****
  {
  	struct dvb_demux *dvbdemux = (struct dvb_demux *)demux;
  
! 	if (mutex_lock_interruptible(&dvbdemux->mutex))
! 		return -ERESTARTSYS;
  
  	demux->frontend = NULL;
  	mutex_unlock(&dvbdemux->mutex);
--- 1166,1172 ----
  {
  	struct dvb_demux *dvbdemux = (struct dvb_demux *)demux;
  
! 	mutex_lock(&dvbdemux->mutex);
  
  	demux->frontend = NULL;
  	mutex_unlock(&dvbdemux->mutex);
diff -rcN linux/drivers/media/dvb/dvb-core/dvb_demux.h UFS922_Orig/drivers/media/dvb/dvb-core/dvb_demux.h
*** linux/drivers/media/dvb/dvb-core/dvb_demux.h	2006-06-18 03:49:35.000000000 +0200
--- UFS922_Orig/drivers/media/dvb/dvb-core/dvb_demux.h	2009-02-10 19:24:55.000000000 +0100
***************
*** 26,32 ****
--- 26,35 ----
  #include <linux/time.h>
  #include <linux/timer.h>
  #include <linux/spinlock.h>
+ #include "compat.h"
+ #if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,15)
  #include <linux/mutex.h>
+ #endif
  
  #include "demux.h"
  
***************
*** 125,131 ****
--- 128,138 ----
  	u8 tsbuf[204];
  	int tsbufp;
  
+ #if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,15)
  	struct mutex mutex;
+ #else
+ 	struct semaphore mutex;
+ #endif
  	spinlock_t lock;
  };
  
diff -rcN linux/drivers/media/dvb/dvb-core/dvbdev.c UFS922_Orig/drivers/media/dvb/dvb-core/dvbdev.c
*** linux/drivers/media/dvb/dvb-core/dvbdev.c	2006-06-18 03:49:35.000000000 +0200
--- UFS922_Orig/drivers/media/dvb/dvb-core/dvbdev.c 2009-02-10 19:24:55.000000000 +0100
***************
*** 27,39 ****
  #include <linux/module.h>
  #include <linux/moduleparam.h>
  #include <linux/kernel.h>
- #include <linux/sched.h>
  #include <linux/init.h>
  #include <linux/slab.h>
  #include <linux/device.h>
  #include <linux/fs.h>
  #include <linux/cdev.h>
  #include <linux/mutex.h>
  #include "dvbdev.h"
  
  static int dvbdev_debug;
--- 27,41 ----
  #include <linux/module.h>
  #include <linux/moduleparam.h>
  #include <linux/kernel.h>
  #include <linux/init.h>
  #include <linux/slab.h>
  #include <linux/device.h>
  #include <linux/fs.h>
  #include <linux/cdev.h>
+ #include "compat.h"
+ #if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,15)
  #include <linux/mutex.h>
+ #endif
  #include "dvbdev.h"
  
  static int dvbdev_debug;
***************
*** 46,54 ****
  static LIST_HEAD(dvb_adapter_list);
  static DEFINE_MUTEX(dvbdev_register_lock);
  
  static const char * const dnames[] = {
  	"video", "audio", "sec", "frontend", "demux", "dvr", "ca",
! 	"net", "osd"
  };
  
  #define DVB_MAX_ADAPTERS	8
--- 48,57 ----
  static LIST_HEAD(dvb_adapter_list);
  static DEFINE_MUTEX(dvbdev_register_lock);
  
+ /* Dagobert: Add ci */
  static const char * const dnames[] = {
  	"video", "audio", "sec", "frontend", "demux", "dvr", "ca",
! 	"net", "osd", "ci"
  };
  
  #define DVB_MAX_ADAPTERS	8
***************
*** 56,62 ****
--- 59,69 ----
  #define nums2minor(num,type,id)	((num << 6) | (id << 4) | type)
  #define MAX_DVB_MINORS		(DVB_MAX_ADAPTERS*64)
  
+ #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,13)
  static struct class *dvb_class;
+ #else
+ static struct class_simple *dvb_class;
+ #endif
  
  static struct dvb_device* dvbdev_find_device (int minor)
  {
***************
*** 86,92 ****
--- 93,103 ----
  
  	if (dvbdev && dvbdev->fops) {
  		int err = 0;
+ #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,17)
  		const struct file_operations *old_fops;
+ #else
+ 		struct file_operations *old_fops;
+ #endif
  
  		file->private_data = dvbdev;
  		old_fops = file->f_op;
***************
*** 200,211 ****
  			const struct dvb_device *template, void *priv, int type)
  {
  	struct dvb_device *dvbdev;
  	int id;
  
! 	if (mutex_lock_interruptible(&dvbdev_register_lock))
! 		return -ERESTARTSYS;
  
! 	if ((id = dvbdev_get_free_id (adap, type)) < 0) {
  		mutex_unlock(&dvbdev_register_lock);
  		*pdvbdev = NULL;
  		printk ("%s: could get find free device id...\n", __FUNCTION__);
--- 211,223 ----
  			const struct dvb_device *template, void *priv, int type)
  {
  	struct dvb_device *dvbdev;
+ 	struct file_operations *dvbdevfops;
+ 
  	int id;
  
! 	mutex_lock(&dvbdev_register_lock);
  
! 	if ((id = dvbdev_get_free_id (adap, type)) < 0){
  		mutex_unlock(&dvbdev_register_lock);
  		*pdvbdev = NULL;
  		printk ("%s: could get find free device id...\n", __FUNCTION__);
***************
*** 214,220 ****
  
  	*pdvbdev = dvbdev = kmalloc(sizeof(struct dvb_device), GFP_KERNEL);
  
! 	if (!dvbdev) {
  		mutex_unlock(&dvbdev_register_lock);
  		return -ENOMEM;
  	}
--- 226,240 ----
  
  	*pdvbdev = dvbdev = kmalloc(sizeof(struct dvb_device), GFP_KERNEL);
  
! 	if (!dvbdev){
! 		mutex_unlock(&dvbdev_register_lock);
! 		return -ENOMEM;
! 	}
! 
! 	dvbdevfops = kzalloc(sizeof(struct file_operations), GFP_KERNEL);
! 
! 	if (!dvbdevfops){
! 		kfree (dvbdev);
  		mutex_unlock(&dvbdev_register_lock);
  		return -ENOMEM;
  	}
***************
*** 224,244 ****
  	dvbdev->id = id;
  	dvbdev->adapter = adap;
  	dvbdev->priv = priv;
  
  	dvbdev->fops->owner = adap->module;
  
  	list_add_tail (&dvbdev->list_head, &adap->device_list);
  
  	mutex_unlock(&dvbdev_register_lock);
  
- 	devfs_mk_cdev(MKDEV(DVB_MAJOR, nums2minor(adap->num, type, id)),
- 			S_IFCHR | S_IRUSR | S_IWUSR,
- 			"dvb/adapter%d/%s%d", adap->num, dnames[type], id);
- 
  	class_device_create(dvb_class, NULL, MKDEV(DVB_MAJOR, nums2minor(adap->num, type, id)),
! 			    NULL, "dvb%d.%s%d", adap->num, dnames[type], id);
  
! 	dprintk("DVB: register adapter%d/%s%d @ minor: %i (0x%02x)\n",
  		adap->num, dnames[type], id, nums2minor(adap->num, type, id),
  		nums2minor(adap->num, type, id));
  
--- 244,262 ----
  	dvbdev->id = id;
  	dvbdev->adapter = adap;
  	dvbdev->priv = priv;
+ 	dvbdev->fops = dvbdevfops;
  
+ 	memcpy(dvbdev->fops, template->fops, sizeof(struct file_operations));
  	dvbdev->fops->owner = adap->module;
  
  	list_add_tail (&dvbdev->list_head, &adap->device_list);
  
  	mutex_unlock(&dvbdev_register_lock);
  
  	class_device_create(dvb_class, NULL, MKDEV(DVB_MAJOR, nums2minor(adap->num, type, id)),
! 			    adap->device, "dvb%d.%s%d", adap->num, dnames[type], id);
  
! 	printk("DVB: register adapter%d/%s%d @ minor: %i (0x%02x)\n",
  		adap->num, dnames[type], id, nums2minor(adap->num, type, id),
  		nums2minor(adap->num, type, id));
  
***************
*** 252,264 ****
  	if (!dvbdev)
  		return;
  
- 	devfs_remove("dvb/adapter%d/%s%d", dvbdev->adapter->num,
- 			dnames[dvbdev->type], dvbdev->id);
- 
  	class_device_destroy(dvb_class, MKDEV(DVB_MAJOR, nums2minor(dvbdev->adapter->num,
  					dvbdev->type, dvbdev->id)));
  
  	list_del (&dvbdev->list_head);
  	kfree (dvbdev);
  }
  EXPORT_SYMBOL(dvb_unregister_device);
--- 270,280 ----
  	if (!dvbdev)
  		return;
  
  	class_device_destroy(dvb_class, MKDEV(DVB_MAJOR, nums2minor(dvbdev->adapter->num,
  					dvbdev->type, dvbdev->id)));
  
  	list_del (&dvbdev->list_head);
+ 	kfree (dvbdev->fops);
  	kfree (dvbdev);
  }
  EXPORT_SYMBOL(dvb_unregister_device);
***************
*** 285,296 ****
  }
  
  
! int dvb_register_adapter(struct dvb_adapter *adap, const char *name, struct module *module)
  {
  	int num;
  
! 	if (mutex_lock_interruptible(&dvbdev_register_lock))
! 		return -ERESTARTSYS;
  
  	if ((num = dvbdev_get_free_adapter_num ()) < 0) {
  		mutex_unlock(&dvbdev_register_lock);
--- 301,311 ----
  }
  
  
! int dvb_register_adapter(struct dvb_adapter *adap, const char *name, struct module *module, struct device *device)
  {
  	int num;
  
! 	mutex_lock(&dvbdev_register_lock);
  
  	if ((num = dvbdev_get_free_adapter_num ()) < 0) {
  		mutex_unlock(&dvbdev_register_lock);
***************
*** 302,311 ****
  
  	printk ("DVB: registering new adapter (%s).\n", name);
  
- 	devfs_mk_dir("dvb/adapter%d", num);
  	adap->num = num;
  	adap->name = name;
  	adap->module = module;
  
  	list_add_tail (&adap->list_head, &dvb_adapter_list);
  
--- 317,326 ----
  
  	printk ("DVB: registering new adapter (%s).\n", name);
  
  	adap->num = num;
  	adap->name = name;
  	adap->module = module;
+ 	adap->device = device;
  
  	list_add_tail (&adap->list_head, &dvb_adapter_list);
  
***************
*** 318,327 ****
  
  int dvb_unregister_adapter(struct dvb_adapter *adap)
  {
! 	devfs_remove("dvb/adapter%d", adap->num);
! 
! 	if (mutex_lock_interruptible(&dvbdev_register_lock))
! 		return -ERESTARTSYS;
  	list_del (&adap->list_head);
  	mutex_unlock(&dvbdev_register_lock);
  	return 0;
--- 333,339 ----
  
  int dvb_unregister_adapter(struct dvb_adapter *adap)
  {
! 	mutex_lock(&dvbdev_register_lock);
  	list_del (&adap->list_head);
  	mutex_unlock(&dvbdev_register_lock);
  	return 0;
***************
*** 409,416 ****
  		goto error;
  	}
  
- 	devfs_mk_dir("dvb");
- 
  	dvb_class = class_create(THIS_MODULE, "dvb");
  	if (IS_ERR(dvb_class)) {
  		retval = PTR_ERR(dvb_class);
--- 421,426 ----
***************
*** 427,433 ****
  
  static void __exit exit_dvbdev(void)
  {
- 	devfs_remove("dvb");
  	class_destroy(dvb_class);
  	cdev_del(&dvb_device_cdev);
  	unregister_chrdev_region(MKDEV(DVB_MAJOR, 0), MAX_DVB_MINORS);
--- 437,442 ----
diff -rcN linux/drivers/media/dvb/dvb-core/dvbdev.h UFS922_Orig/drivers/media/dvb/dvb-core/dvbdev.h 
*** linux/drivers/media/dvb/dvb-core/dvbdev.h	2006-06-18 03:49:35.000000000 +0200
--- UFS922_Orig/drivers/media/dvb/dvb-core/dvbdev.h	2009-02-10 19:24:55.000000000 +0100
***************
*** 27,34 ****
  #include <linux/poll.h>
  #include <linux/fs.h>
  #include <linux/list.h>
- #include <linux/devfs_fs_kernel.h>
  #include <linux/smp_lock.h>
  
  #define DVB_MAJOR 212
  
--- 27,34 ----
  #include <linux/poll.h>
  #include <linux/fs.h>
  #include <linux/list.h>
  #include <linux/smp_lock.h>
+ #include "compat.h"
  
  #define DVB_MAJOR 212
  
***************
*** 41,46 ****
--- 41,48 ----
  #define DVB_DEVICE_CA         6
  #define DVB_DEVICE_NET        7
  #define DVB_DEVICE_OSD        8
+ /* Dagobert: Add ci */
+ #define DVB_DEVICE_CI         9
  
  
  struct dvb_adapter {
***************
*** 51,56 ****
--- 53,60 ----
  	u8 proposed_mac [6];
  	void* priv;
  
+ 	struct device *device;
+ 
  	struct module *module;
  };
  
***************
*** 76,82 ****
  };
  
  
! extern int dvb_register_adapter (struct dvb_adapter *adap, const char *name, struct module *module);
  extern int dvb_unregister_adapter (struct dvb_adapter *adap);
  
  extern int dvb_register_device (struct dvb_adapter *adap,
--- 80,86 ----
  };
  
  
! extern int dvb_register_adapter (struct dvb_adapter *adap, const char *name, struct module *module, struct device *device);
  extern int dvb_unregister_adapter (struct dvb_adapter *adap);
  
  extern int dvb_register_device (struct dvb_adapter *adap,
***************
*** 101,104 ****
--- 105,130 ----
  			    int (*func)(struct inode *inode, struct file *file,
  			    unsigned int cmd, void *arg));
  
+ /** generic DVB attach function. */
+ #ifdef CONFIG_DVB_CORE_ATTACH
+ #define dvb_attach(FUNCTION, ARGS...) ({ \
+ 	void *__r = NULL; \
+ 	typeof(&FUNCTION) __a = symbol_request(FUNCTION); \
+ 	if (__a) { \
+ 		__r = (void *) __a(ARGS); \
+ 		if (__r == NULL) \
+ 			symbol_put(FUNCTION); \
+ 	} else { \
+ 		printk(KERN_ERR "DVB: Unable to find symbol "#FUNCTION"()\n"); \
+ 	} \
+ 	__r; \
+ })
+ 
+ #else
+ #define dvb_attach(FUNCTION, ARGS...) ({ \
+ 	FUNCTION(ARGS); \
+ })
+ 
+ #endif
+ 
  #endif /* #ifndef _DVBDEV_H_ */
diff -rcN linux/drivers/media/dvb/dvb-core/dvb_filter.c UFS922_Orig/drivers/media/dvb/dvb-core/dvb_filter.c
*** linux/drivers/media/dvb/dvb-core/dvb_filter.c	2006-06-18 03:49:35.000000000 +0200
--- UFS922_Orig/drivers/media/dvb/dvb-core/dvb_filter.c	2009-02-10 19:24:55.000000000 +0100
***************
*** 3,9 ****
  #include <linux/string.h>
  #include "dvb_filter.h"
  
! #if 0
  static unsigned int bitrates[3][16] =
  {{0,32,64,96,128,160,192,224,256,288,320,352,384,416,448,0},
   {0,32,48,56,64,80,96,112,128,160,192,224,256,320,384,0},
--- 3,9 ----
  #include <linux/string.h>
  #include "dvb_filter.h"
  
! #if 0 /* keep */
  static unsigned int bitrates[3][16] =
  {{0,32,64,96,128,160,192,224,256,288,320,352,384,416,448,0},
   {0,32,48,56,64,80,96,112,128,160,192,224,256,320,384,0},
***************
*** 26,32 ****
  
  
  
! #if 0
  static void setup_ts2pes(ipack *pa, ipack *pv, u16 *pida, u16 *pidv,
  		  void (*pes_write)(u8 *buf, int count, void *data),
  		  void *priv)
--- 26,32 ----
  
  
  
! #if 0 /* keep */
  static void setup_ts2pes(ipack *pa, ipack *pv, u16 *pida, u16 *pidv,
  		  void (*pes_write)(u8 *buf, int count, void *data),
  		  void *priv)
***************
*** 40,46 ****
  }
  #endif
  
! #if 0
  static void ts_to_pes(ipack *p, u8 *buf) // don't need count (=188)
  {
  	u8 off = 0;
--- 40,46 ----
  }
  #endif
  
! #if 0 /* keep */
  static void ts_to_pes(ipack *p, u8 *buf) // don't need count (=188)
  {
  	u8 off = 0;
***************
*** 65,71 ****
  }
  #endif
  
! #if 0
  /* needs 5 byte input, returns picture coding type*/
  static int read_picture_header(u8 *headr, struct mpg_picture *pic, int field, int pr)
  {
--- 65,71 ----
  }
  #endif
  
! #if 0 /* keep */
  /* needs 5 byte input, returns picture coding type*/
  static int read_picture_header(u8 *headr, struct mpg_picture *pic, int field, int pr)
  {
***************
*** 111,117 ****
  }
  #endif
  
! #if 0
  /* needs 4 byte input */
  static int read_gop_header(u8 *headr, struct mpg_picture *pic, int pr)
  {
--- 111,117 ----
  }
  #endif
  
! #if 0 /* keep */
  /* needs 4 byte input */
  static int read_gop_header(u8 *headr, struct mpg_picture *pic, int pr)
  {
***************
*** 142,148 ****
  }
  #endif
  
! #if 0
  /* needs 8 byte input */
  static int read_sequence_header(u8 *headr, struct dvb_video_info *vi, int pr)
  {
--- 142,148 ----
  }
  #endif
  
! #if 0 /* keep */
  /* needs 8 byte input */
  static int read_sequence_header(u8 *headr, struct dvb_video_info *vi, int pr)
  {
***************
*** 257,263 ****
  #endif
  
  
! #if 0
  static int get_vinfo(u8 *mbuf, int count, struct dvb_video_info *vi, int pr)
  {
  	u8 *headr;
--- 257,263 ----
  #endif
  
  
! #if 0 /* keep */
  static int get_vinfo(u8 *mbuf, int count, struct dvb_video_info *vi, int pr)
  {
  	u8 *headr;
***************
*** 286,292 ****
  #endif
  
  
! #if 0
  static int get_ainfo(u8 *mbuf, int count, struct dvb_audio_info *ai, int pr)
  {
  	u8 *headr;
--- 286,292 ----
  #endif
  
  
! #if 0 /* keep */
  static int get_ainfo(u8 *mbuf, int count, struct dvb_audio_info *ai, int pr)
  {
  	u8 *headr;
***************
*** 393,399 ****
  EXPORT_SYMBOL(dvb_filter_get_ac3info);
  
  
! #if 0
  static u8 *skip_pes_header(u8 **bufp)
  {
  	u8 *inbuf = *bufp;
--- 393,399 ----
  EXPORT_SYMBOL(dvb_filter_get_ac3info);
  
  
! #if 0 /* keep */
  static u8 *skip_pes_header(u8 **bufp)
  {
  	u8 *inbuf = *bufp;
***************
*** 431,437 ****
  }
  #endif
  
! #if 0
  static void initialize_quant_matrix( u32 *matrix )
  {
  	int i;
--- 431,437 ----
  }
  #endif
  
! #if 0 /* keep */
  static void initialize_quant_matrix( u32 *matrix )
  {
  	int i;
***************
*** 458,464 ****
  }
  #endif
  
! #if 0
  static void initialize_mpg_picture(struct mpg_picture *pic)
  {
  	int i;
--- 458,464 ----
  }
  #endif
  
! #if 0 /* keep */
  static void initialize_mpg_picture(struct mpg_picture *pic)
  {
  	int i;
***************
*** 485,491 ****
  }
  #endif
  
! #if 0
  static void mpg_set_picture_parameter( int32_t field_type, struct mpg_picture *pic )
  {
  	int16_t last_h_offset;
--- 485,491 ----
  }
  #endif
  
! #if 0 /* keep */
  static void mpg_set_picture_parameter( int32_t field_type, struct mpg_picture *pic )
  {
  	int16_t last_h_offset;
***************
*** 523,529 ****
  }
  #endif
  
! #if 0
  static void init_mpg_picture( struct mpg_picture *pic, int chan, int32_t field_type)
  {
  	pic->picture_header = 0;
--- 523,529 ----
  }
  #endif
  
! #if 0 /* keep */
  static void init_mpg_picture( struct mpg_picture *pic, int chan, int32_t field_type)
  {
  	pic->picture_header = 0;
diff -rcN linux/drivers/media/dvb/dvb-core/dvb_frontend.c UFS922_Orig/drivers/media/dvb/dvb-core/dvb_frontend.c
*** linux/drivers/media/dvb/dvb-core/dvb_frontend.c	2009-05-16 19:37:05.000000000 +0200
--- UFS922_Orig/drivers/media/dvb/dvb-core/dvb_frontend.c	2009-02-10 19:24:55.000000000 +0100
***************
*** 9,14 ****
--- 9,17 ----
   *
   * Copyright (C) 2004 Andrew de Quincey (tuning thread cleanup)
   *
+  * Multi protocol support and backward compatibility
+  * Copyright (C) 2007 Manu Abraham
+  *
   * This program is free software; you can redistribute it and/or
   * modify it under the terms of the GNU General Public License
   * as published by the Free Software Foundation; either version 2
***************
*** 34,41 ****
--- 37,50 ----
  #include <linux/module.h>
  #include <linux/moduleparam.h>
  #include <linux/list.h>
+ #include "compat.h"
+ #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
  #include <linux/suspend.h>
+ #else
+ #include <linux/freezer.h>
+ #endif
  #include <linux/jiffies.h>
+ #include <linux/kthread.h>
  #include <asm/processor.h>
  
  #include "dvb_frontend.h"
***************
*** 56,62 ****
  module_param(dvb_override_tune_delay, int, 0644);
  MODULE_PARM_DESC(dvb_override_tune_delay, "0: normal (default), >0 => delay in milliseconds to wait for lock after a tune attempt");
  module_param(dvb_powerdown_on_sleep, int, 0644);
! MODULE_PARM_DESC(dvb_powerdown_on_sleep, "0: do not power down, 1: turn LNB volatage off on sleep (default)");
  
  #define dprintk if (dvb_frontend_debug) printk
  
--- 65,71 ----
  module_param(dvb_override_tune_delay, int, 0644);
  MODULE_PARM_DESC(dvb_override_tune_delay, "0: normal (default), >0 => delay in milliseconds to wait for lock after a tune attempt");
  module_param(dvb_powerdown_on_sleep, int, 0644);
! MODULE_PARM_DESC(dvb_powerdown_on_sleep, "0: do not power down, 1: turn LNB voltage off on sleep (default)");
  
  #define dprintk if (dvb_frontend_debug) printk
  
***************
*** 72,77 ****
--- 81,88 ----
  #define FESTATE_SEARCHING_FAST (FESTATE_TUNING_FAST | FESTATE_ZIGZAG_FAST)
  #define FESTATE_SEARCHING_SLOW (FESTATE_TUNING_SLOW | FESTATE_ZIGZAG_SLOW)
  #define FESTATE_LOSTLOCK (FESTATE_ZIGZAG_FAST | FESTATE_ZIGZAG_SLOW)
+ 
+ #define FE_ALGO_HW		1
  /*
   * FESTATE_IDLE. No tuning parameters have been supplied and the loop is idling.
   * FESTATE_RETUNE. Parameters have been supplied, but we have not yet performed the first tune.
***************
*** 93,104 ****
  
  	/* thread/frontend values */
  	struct dvb_device *dvbdev;
  	struct dvb_frontend_parameters parameters;
  	struct dvb_fe_events events;
  	struct semaphore sem;
  	struct list_head list_head;
  	wait_queue_head_t wait_queue;
! 	pid_t thread_pid;
  	unsigned long release_jiffies;
  	unsigned int exit;
  	unsigned int wakeup;
--- 104,120 ----
  
  	/* thread/frontend values */
  	struct dvb_device *dvbdev;
+ 	/* Legacy datatype, superseded by dvbfe_params		*/
  	struct dvb_frontend_parameters parameters;
+ 	/* dvbfe_params supersedes dvb_frontend_parameters	*/
+ 	struct dvbfe_params	fe_params;
+ 	struct dvbfe_info	fe_info;
+ 
  	struct dvb_fe_events events;
  	struct semaphore sem;
  	struct list_head list_head;
  	wait_queue_head_t wait_queue;
! 	struct task_struct *thread;
  	unsigned long release_jiffies;
  	unsigned int exit;
  	unsigned int wakeup;
***************
*** 122,131 ****
--- 138,581 ----
  	unsigned int step_size;
  	int quality;
  	unsigned int check_wrapped;
+ 
+ 	enum dvbfe_search	algo_status;
  };
  
  static void dvb_frontend_wakeup(struct dvb_frontend *fe);
  
+ struct modcod_table {
+ 	u32 dvbfe_modcod;
+ 	u32 dvbfe_modulation;
+ 	u32 dvbfe_fec;
+ };
+ 
+ static struct modcod_table dvbs2_modcod_lookup[] = {
+ 	{ DVBFE_MODCOD_DUMMY_PLFRAME,	DVBFE_MOD_NONE,		DVBFE_FEC_NONE    },
+ 	{ DVBFE_MODCOD_QPSK_1_4,	DVBFE_MOD_QPSK,		DVBFE_FEC_1_4	  },
+ 	{ DVBFE_MODCOD_QPSK_1_3,	DVBFE_MOD_QPSK,		DVBFE_FEC_1_3	  },
+ 	{ DVBFE_MODCOD_QPSK_2_5,	DVBFE_MOD_QPSK,		DVBFE_FEC_2_5	  },
+ 	{ DVBFE_MODCOD_QPSK_1_2,	DVBFE_MOD_QPSK,		DVBFE_FEC_1_2	  },
+ 	{ DVBFE_MODCOD_QPSK_3_5,	DVBFE_MOD_QPSK,		DVBFE_FEC_3_5	  },
+ 	{ DVBFE_MODCOD_QPSK_2_3,	DVBFE_MOD_QPSK,		DVBFE_FEC_2_3	  },
+ 	{ DVBFE_MODCOD_QPSK_3_4,	DVBFE_MOD_QPSK,		DVBFE_FEC_3_4	  },
+ 	{ DVBFE_MODCOD_QPSK_4_5,	DVBFE_MOD_QPSK,		DVBFE_FEC_4_5	  },
+ 	{ DVBFE_MODCOD_QPSK_5_6,	DVBFE_MOD_QPSK,		DVBFE_FEC_5_6	  },
+ 	{ DVBFE_MODCOD_QPSK_8_9,	DVBFE_MOD_QPSK,		DVBFE_FEC_8_9	  },
+ 	{ DVBFE_MODCOD_QPSK_9_10,	DVBFE_MOD_QPSK,		DVBFE_FEC_9_10	  },
+ 	{ DVBFE_MODCOD_8PSK_3_5,	DVBFE_MOD_8PSK,		DVBFE_FEC_3_5	  },
+ 	{ DVBFE_MODCOD_8PSK_2_3,	DVBFE_MOD_8PSK,		DVBFE_FEC_2_3	  },
+ 	{ DVBFE_MODCOD_8PSK_3_4,	DVBFE_MOD_8PSK,		DVBFE_FEC_3_4	  },
+ 	{ DVBFE_MODCOD_8PSK_5_6,	DVBFE_MOD_8PSK,		DVBFE_FEC_5_6	  },
+ 	{ DVBFE_MODCOD_8PSK_8_9,	DVBFE_MOD_8PSK,		DVBFE_FEC_8_9	  },
+ 	{ DVBFE_MODCOD_8PSK_9_10,	DVBFE_MOD_8PSK,		DVBFE_FEC_9_10	  },
+ 	{ DVBFE_MODCOD_16APSK_2_3,	DVBFE_MOD_16APSK,	DVBFE_FEC_2_3	  },
+ 	{ DVBFE_MODCOD_16APSK_3_4,	DVBFE_MOD_16APSK,	DVBFE_FEC_3_4	  },
+ 	{ DVBFE_MODCOD_16APSK_4_5,	DVBFE_MOD_16APSK,	DVBFE_FEC_4_5	  },
+ 	{ DVBFE_MODCOD_16APSK_5_6,	DVBFE_MOD_16APSK,	DVBFE_FEC_5_6	  },
+ 	{ DVBFE_MODCOD_16APSK_8_9,	DVBFE_MOD_16APSK,	DVBFE_FEC_8_9	  },
+ 	{ DVBFE_MODCOD_16APSK_9_10,	DVBFE_MOD_16APSK,	DVBFE_FEC_9_10	  },
+ 	{ DVBFE_MODCOD_32APSK_3_4,	DVBFE_MOD_32APSK,	DVBFE_FEC_3_4	  },
+ 	{ DVBFE_MODCOD_32APSK_4_5,	DVBFE_MOD_32APSK,	DVBFE_FEC_4_5	  },
+ 	{ DVBFE_MODCOD_32APSK_5_6,	DVBFE_MOD_32APSK,	DVBFE_FEC_5_6	  },
+ 	{ DVBFE_MODCOD_32APSK_8_9,	DVBFE_MOD_32APSK,	DVBFE_FEC_8_9	  },
+ 	{ DVBFE_MODCOD_32APSK_9_10,	DVBFE_MOD_32APSK,	DVBFE_FEC_9_10	  },
+ 	{ DVBFE_MODCOD_RESERVED_1,	DVBFE_MOD_NONE,		DVBFE_FEC_NONE	  },
+ 	{ DVBFE_MODCOD_BPSK_1_3,	DVBFE_MOD_BPSK,		DVBFE_FEC_1_3	  },
+ 	{ DVBFE_MODCOD_BPSK_1_4,	DVBFE_MOD_BPSK,		DVBFE_FEC_1_4	  },
+ 	{ DVBFE_MODCOD_RESERVED_2,	DVBFE_MOD_NONE,		DVBFE_FEC_NONE    }
+ };
+ 
+ void decode_dvbs2_modcod(u32 dvbfe_modcod,
+ 			 enum dvbfe_modulation *modulation,
+ 			 enum dvbfe_fec *fec)
+ {
+ 	BUG_ON(dvbfe_modcod >= ARRAY_SIZE(dvbs2_modcod_lookup));
+ 	*modulation = dvbs2_modcod_lookup[dvbfe_modcod].dvbfe_modulation;
+ 	*fec = dvbs2_modcod_lookup[dvbfe_modcod].dvbfe_fec;
+ }
+ EXPORT_SYMBOL(decode_dvbs2_modcod);
+ 
+ static int newfec_to_oldfec(enum dvbfe_fec new_fec, enum fe_code_rate *old_fec)
+ {
+ 	switch (new_fec) {
+ 	case DVBFE_FEC_NONE:
+ 		*old_fec = FEC_NONE;
+ 		break;
+ 	case DVBFE_FEC_1_2:
+ 		*old_fec = FEC_1_2;
+ 		break;
+ 	case DVBFE_FEC_2_3:
+ 		*old_fec = FEC_2_3;
+ 		break;
+ 	case DVBFE_FEC_3_4:
+ 		*old_fec = FEC_3_4;
+ 		break;
+ 	case DVBFE_FEC_4_5:
+ 		*old_fec = FEC_4_5;
+ 		break;
+ 	case DVBFE_FEC_5_6:
+ 		*old_fec = FEC_5_6;
+ 		break;
+ 	case DVBFE_FEC_6_7:
+ 		*old_fec = FEC_6_7;
+ 		break;
+ 	case DVBFE_FEC_7_8:
+ 		*old_fec = FEC_7_8;
+ 		break;
+ 	case DVBFE_FEC_8_9:
+ 		*old_fec = FEC_8_9;
+ 		break;
+ 	case DVBFE_FEC_AUTO:
+ 		*old_fec = FEC_AUTO;
+ 		break;
+ 	default:
+ 		printk("%s: Unsupported FEC\n", __func__);
+ 		return -EINVAL;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int oldfec_to_newfec(enum fe_code_rate old_fec, enum dvbfe_fec *new_fec)
+ {
+ 	switch (old_fec) {
+ 	case FEC_NONE:
+ 		*new_fec = DVBFE_FEC_NONE;
+ 		break;
+ 	case FEC_1_2:
+ 		*new_fec = DVBFE_FEC_1_2;
+ 		break;
+ 	case FEC_2_3:
+ 		*new_fec = DVBFE_FEC_2_3;
+ 		break;
+ 	case FEC_3_4:
+ 		*new_fec = DVBFE_FEC_3_4;
+ 		break;
+ 	case FEC_4_5:
+ 		*new_fec = DVBFE_FEC_4_5;
+ 		break;
+ 	case FEC_5_6:
+ 		*new_fec = DVBFE_FEC_5_6;
+ 		break;
+ 	case FEC_6_7:
+ 		*new_fec = DVBFE_FEC_6_7;
+ 		break;
+ 	case FEC_7_8:
+ 		*new_fec = DVBFE_FEC_7_8;
+ 		break;
+ 	case FEC_8_9:
+ 		*new_fec = DVBFE_FEC_8_9;
+ 		break;
+ 	case FEC_AUTO:
+ 		*new_fec = DVBFE_FEC_AUTO;
+ 		break;
+ 	default:
+ 		printk("%s: Unsupported FEC\n", __func__);
+ 		return -EINVAL;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int newmod_to_oldmod(enum dvbfe_modulation new_mod, enum fe_modulation *old_mod)
+ {
+ 	switch (new_mod) {
+ 	case DVBFE_MOD_QPSK:
+ 		*old_mod = QPSK;
+ 		break;
+ 	case DVBFE_MOD_QAM16:
+ 		*old_mod = QAM_16;
+ 		break;
+ 	case DVBFE_MOD_QAM32:
+ 		*old_mod = QAM_32;
+ 		break;
+ 	case DVBFE_MOD_QAM64:
+ 		*old_mod = QAM_64;
+ 		break;
+ 	case DVBFE_MOD_QAM128:
+ 		*old_mod = QAM_128;
+ 		break;
+ 	case DVBFE_MOD_QAM256:
+ 		*old_mod = QAM_256;
+ 		break;
+ 	case DVBFE_MOD_QAMAUTO:
+ 		*old_mod = QAM_AUTO;
+ 		break;
+ 	case DVBFE_MOD_VSB8:
+ 		*old_mod = VSB_8;
+ 		break;
+ 	case DVBFE_MOD_VSB16:
+ 		*old_mod = VSB_16;
+ 		break;
+ 	default:
+ 		printk("%s: Unsupported Modulation\n", __func__);
+ 		return -EINVAL;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static int oldmod_to_newmod(enum fe_modulation old_mod, enum dvbfe_modulation *new_mod)
+ {
+ 	switch (old_mod) {
+ 	case QPSK:
+ 		*new_mod = DVBFE_MOD_QPSK;
+ 		break;
+ 	case QAM_16:
+ 		*new_mod = DVBFE_MOD_QAM16;
+ 		break;
+ 	case QAM_32:
+ 		*new_mod = DVBFE_MOD_QAM32;
+ 		break;
+ 	case QAM_64:
+ 		*new_mod = DVBFE_MOD_QAM64;
+ 		break;
+ 	case QAM_128:
+ 		*new_mod = DVBFE_MOD_QAM128;
+ 		break;
+ 	case QAM_256:
+ 		*new_mod = DVBFE_MOD_QAM256;
+ 		break;
+ 	case QAM_AUTO:
+ 		*new_mod = DVBFE_MOD_AUTO;
+ 		break;
+ 	case VSB_8:
+ 		*new_mod = DVBFE_MOD_VSB8;
+ 		break;
+ 	case VSB_16:
+ 		*new_mod = DVBFE_MOD_VSB16;
+ 		break;
+ 	default:
+ 		printk("%s: Unsupported Modulation\n", __func__);
+ 		return -EINVAL;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ int newapi_to_olddrv(struct dvbfe_params *params,
+ 		     struct dvb_frontend_parameters *p,
+ 		     enum dvbfe_delsys delsys)
+ {
+ 	struct dvb_qpsk_parameters	*qpsk	= &p->u.qpsk;
+ 	struct dvb_qam_parameters	*qam	= &p->u.qam;
+ 	struct dvb_ofdm_parameters	*ofdm	= &p->u.ofdm;
+ 	struct dvb_vsb_parameters	*vsb	= &p->u.vsb;
+ 
+ 	struct dvbs_params		*dvbs	= &params->delsys.dvbs;
+ 	struct dvbc_params		*dvbc	= &params->delsys.dvbc;
+ 	struct dvbt_params		*dvbt	= &params->delsys.dvbt;
+ 	struct atsc_params		*atsc	= &params->delsys.atsc;
+ 
+ 	p->frequency = params->frequency;
+ 	p->inversion = params->inversion;
+ 
+ 	switch (delsys) {
+ 	case DVBFE_DELSYS_DVBS:
+ 		qpsk->symbol_rate		= dvbs->symbol_rate;
+ 		newfec_to_oldfec(dvbs->fec, &qpsk->fec_inner);
+ 		break;
+ 	case DVBFE_DELSYS_DVBC:
+ 		qam->symbol_rate		= dvbc->symbol_rate;
+ 		newmod_to_oldmod(dvbc->modulation, &qam->modulation);
+ 		newfec_to_oldfec(dvbc->fec, &qam->fec_inner);
+ 		break;
+ 	case DVBFE_DELSYS_DVBT:
+ 		switch (dvbt->bandwidth) {
+ 		case DVBFE_BANDWIDTH_8_MHZ:
+ 			ofdm->bandwidth		= BANDWIDTH_8_MHZ;
+ 			break;
+ 		case DVBFE_BANDWIDTH_7_MHZ:
+ 			ofdm->bandwidth		= BANDWIDTH_7_MHZ;
+ 			break;
+ 		case DVBFE_BANDWIDTH_6_MHZ:
+ 			ofdm->bandwidth		= BANDWIDTH_6_MHZ;
+ 			break;
+ 		case DVBFE_BANDWIDTH_AUTO:
+ 			ofdm->bandwidth		= BANDWIDTH_AUTO;
+ 			break;
+ 		default:
+ 			dprintk("%s: Unsupported bandwidth\n", __func__);
+ 			return -EINVAL;
+ 		}
+ 		newfec_to_oldfec(dvbt->code_rate_HP, &ofdm->code_rate_HP);
+ 		newfec_to_oldfec(dvbt->code_rate_LP, &ofdm->code_rate_LP);
+ 		newmod_to_oldmod(dvbt->constellation, &ofdm->constellation);
+ 		switch (dvbt->transmission_mode) {
+ 		case DVBFE_TRANSMISSION_MODE_2K:
+ 			ofdm->transmission_mode = TRANSMISSION_MODE_2K;
+ 			break;
+ 		case DVBFE_TRANSMISSION_MODE_8K:
+ 			ofdm->transmission_mode = TRANSMISSION_MODE_8K;
+ 			break;
+ 		case DVBFE_TRANSMISSION_MODE_AUTO:
+ 			ofdm->transmission_mode = TRANSMISSION_MODE_AUTO;
+ 			break;
+ 		default:
+ 			dprintk("%s: Unsupported transmission mode\n", __func__);
+ 			return -EINVAL;
+ 		}
+ 		switch (dvbt->guard_interval) {
+ 		case DVBFE_GUARD_INTERVAL_1_32:
+ 			ofdm->guard_interval	= GUARD_INTERVAL_1_32;
+ 			break;
+ 		case DVBFE_GUARD_INTERVAL_1_16:
+ 			ofdm->guard_interval	= GUARD_INTERVAL_1_16;
+ 			break;
+ 		case DVBFE_GUARD_INTERVAL_1_8:
+ 			ofdm->guard_interval	= GUARD_INTERVAL_1_8;
+ 			break;
+ 		case DVBFE_GUARD_INTERVAL_1_4:
+ 			ofdm->guard_interval	= GUARD_INTERVAL_1_4;
+ 			break;
+ 		case DVBFE_GUARD_INTERVAL_AUTO:
+ 			ofdm->guard_interval	= GUARD_INTERVAL_AUTO;
+ 			break;
+ 		}
+ 		switch (dvbt->hierarchy) {
+ 		case DVBFE_HIERARCHY_OFF:
+ 			ofdm->hierarchy_information		= HIERARCHY_NONE;
+ 			break;
+ 		case DVBFE_HIERARCHY_AUTO:
+ 			ofdm->hierarchy_information		= HIERARCHY_AUTO;
+ 			break;
+ 		case DVBFE_HIERARCHY_ON:
+ 			switch (dvbt->alpha) {
+ 			case DVBFE_ALPHA_1:
+ 				ofdm->hierarchy_information	= HIERARCHY_1;
+ 				break;
+ 			case DVBFE_ALPHA_2:
+ 				ofdm->hierarchy_information	= HIERARCHY_2;
+ 				break;
+ 			case DVBFE_ALPHA_4:
+ 				ofdm->hierarchy_information	= HIERARCHY_4;
+ 				break;
+ 			}
+ 			break;
+ 		}
+ 	case DVBFE_DELSYS_ATSC:
+ 		newmod_to_oldmod(atsc->modulation, &vsb->modulation);
+ 		break;
+ 	case DVBFE_DELSYS_DVBS2:
+ 	case DVBFE_DELSYS_DSS:
+ 	case DVBFE_DELSYS_DVBH:
+ 		printk("%s: SORRY ! Backward compatibility unavailable for these delivery systems !!\n", __func__);
+ 		break;
+ 	default:
+ 		dprintk("%s: Unsupported delivery system\n", __func__);
+ 		return -EINVAL;
+ 		break;
+ 	}
+ 	return 0;
+ }
+ 
+ int olddrv_to_newapi(struct dvb_frontend *fe,
+ 		     struct dvbfe_params *params,
+ 		     struct dvb_frontend_parameters *p,
+ 		     enum fe_type fe_type)
+ {
+ 	struct dvb_qpsk_parameters	*qpsk	= &p->u.qpsk;
+ 	struct dvb_qam_parameters	*qam	= &p->u.qam;
+ 	struct dvb_ofdm_parameters	*ofdm	= &p->u.ofdm;
+ 	struct dvb_vsb_parameters	*vsb	= &p->u.vsb;
+ 
+ 	struct dvbs_params		*dvbs	= &params->delsys.dvbs;
+ 	struct dvbc_params		*dvbc	= &params->delsys.dvbc;
+ 	struct dvbt_params		*dvbt	= &params->delsys.dvbt;
+ 	struct atsc_params		*atsc	= &params->delsys.atsc;
+ 
+ 	params->frequency = p->frequency;
+ 	params->inversion = p->inversion;
+ 
+ 	switch (fe_type) {
+ 	case FE_QPSK:
+ 		dvbs->symbol_rate		= qpsk->symbol_rate;
+ 		oldfec_to_newfec(qpsk->fec_inner, &dvbs->fec);
+ 		break;
+ 	case FE_QAM:
+ 		dvbc->symbol_rate		= qam->symbol_rate;
+ 		oldmod_to_newmod(qam->modulation, &dvbc->modulation);
+ 		oldfec_to_newfec(qam->fec_inner, &dvbc->fec);
+ 		break;
+ 	case FE_OFDM:
+ 		switch (ofdm->bandwidth) {
+ 		case BANDWIDTH_8_MHZ:
+ 			dvbt->bandwidth		= DVBFE_BANDWIDTH_8_MHZ;
+ 			break;
+ 		case BANDWIDTH_7_MHZ:
+ 			dvbt->bandwidth		= DVBFE_BANDWIDTH_7_MHZ;
+ 			break;
+ 		case BANDWIDTH_6_MHZ:
+ 			dvbt->bandwidth		= DVBFE_BANDWIDTH_6_MHZ;
+ 			break;
+ 		case BANDWIDTH_AUTO:
+ 			dvbt->bandwidth		= DVBFE_BANDWIDTH_AUTO;
+ 			break;
+ 		}
+ 		oldfec_to_newfec(ofdm->code_rate_HP, &dvbt->code_rate_HP);
+ 		oldfec_to_newfec(ofdm->code_rate_LP, &dvbt->code_rate_LP);
+ 		oldmod_to_newmod(ofdm->constellation, &dvbt->constellation);
+ 		switch (ofdm->transmission_mode) {
+ 		case TRANSMISSION_MODE_2K:
+ 			dvbt->transmission_mode	= DVBFE_TRANSMISSION_MODE_2K;
+ 			break;
+ 		case TRANSMISSION_MODE_8K:
+ 			dvbt->transmission_mode = DVBFE_TRANSMISSION_MODE_8K;
+ 			break;
+ 		case TRANSMISSION_MODE_AUTO:
+ 			dvbt->transmission_mode	= DVBFE_TRANSMISSION_MODE_AUTO;
+ 			break;
+ 		}
+ 		switch (ofdm->guard_interval) {
+ 		case GUARD_INTERVAL_1_32:
+ 			dvbt->guard_interval	= DVBFE_GUARD_INTERVAL_1_32;
+ 			break;
+ 		case GUARD_INTERVAL_1_16:
+ 			dvbt->guard_interval	= DVBFE_GUARD_INTERVAL_1_16;
+ 			break;
+ 		case GUARD_INTERVAL_1_8:
+ 			dvbt->guard_interval	= DVBFE_GUARD_INTERVAL_1_8;
+ 			break;
+ 		case GUARD_INTERVAL_1_4:
+ 			dvbt->guard_interval	= DVBFE_GUARD_INTERVAL_1_4;
+ 			break;
+ 		case GUARD_INTERVAL_AUTO:
+ 			dvbt->guard_interval	= DVBFE_GUARD_INTERVAL_AUTO;
+ 			break;
+ 		}
+ 		switch (ofdm->hierarchy_information) {
+ 		case HIERARCHY_NONE:
+ 			dvbt->hierarchy		= DVBFE_HIERARCHY_OFF;
+ 			break;
+ 		case HIERARCHY_AUTO:
+ 			dvbt->hierarchy		= DVBFE_HIERARCHY_AUTO;
+ 			break;
+ 		case HIERARCHY_1:
+ 			dvbt->hierarchy		= DVBFE_HIERARCHY_ON;
+ 			dvbt->alpha		= DVBFE_ALPHA_1;
+ 			break;
+ 		case HIERARCHY_2:
+ 			dvbt->hierarchy		= DVBFE_HIERARCHY_ON;
+ 			dvbt->alpha		= DVBFE_ALPHA_2;
+ 			break;
+ 		case HIERARCHY_4:
+ 			dvbt->hierarchy		= DVBFE_HIERARCHY_ON;
+ 			dvbt->alpha		= DVBFE_ALPHA_4;
+ 			break;
+ 		}
+ 		break;
+ 	case FE_ATSC:
+ 		newmod_to_oldmod(atsc->modulation, &vsb->modulation);
+ 		break;
+ 	default:
+ 		dprintk("%s: Unsupported delivery system\n", __func__);
+ 		return -EINVAL;
+ 		break;
+ 	}
+ 	return 0;
+ }
+ 
  static void dvb_frontend_add_event(struct dvb_frontend *fe, fe_status_t status)
  {
  	struct dvb_frontend_private *fepriv = fe->frontend_priv;
***************
*** 147,168 ****
  
  	e = &events->events[events->eventw];
  
! 	memcpy (&e->parameters, &fepriv->parameters,
! 		sizeof (struct dvb_frontend_parameters));
! 
! 	if (status & FE_HAS_LOCK)
! 		if (fe->ops->get_frontend)
! 			fe->ops->get_frontend(fe, &e->parameters);
  
  	events->eventw = wp;
- 
  	up (&events->sem);
- 
  	e->status = status;
- 
  	wake_up_interruptible (&events->wait_queue);
  }
  
  static int dvb_frontend_get_event(struct dvb_frontend *fe,
  			    struct dvb_frontend_event *event, int flags)
  {
--- 597,690 ----
  
  	e = &events->events[events->eventw];
  
! 	if (fe->legacy)
! 		memcpy(&e->parameters, &fepriv->parameters, sizeof (struct dvb_frontend_parameters));
! 	else
! 		memcpy(&e->fe_params, &fepriv->fe_params, sizeof (struct dvbfe_params));
  
+ 	if (fe->legacy) {
+ 		/* Legacy	*/
+ 		if (status & FE_HAS_LOCK)
+ 			if (fe->ops.get_frontend)
+ 				fe->ops.get_frontend(fe, &e->parameters);
+ 	} else {
+ 		if (status & FE_HAS_LOCK)
+ 			if (fe->ops.get_params)
+ 				fe->ops.get_params(fe, &e->fe_params);
+ 	}
  	events->eventw = wp;
  	up (&events->sem);
  	e->status = status;
  	wake_up_interruptible (&events->wait_queue);
  }
  
+ static int dvbfe_sanity_check(struct dvb_frontend *fe)
+ {
+ 	struct dvb_frontend_private *fepriv = fe->frontend_priv;
+ 
+ 	/* Sanity checks	*/
+ 	if ((fepriv->fe_params.frequency < fepriv->fe_info.frequency_min) ||
+ 	    (fepriv->fe_params.frequency > fepriv->fe_info.frequency_max))
+ 		return -EINVAL;
+ 
+ 	switch (fepriv->fe_params.delivery) {
+ 	case DVBFE_DELSYS_DVBS:
+ 		if (!(fepriv->fe_params.delsys.dvbs.modulation &
+ 		      fepriv->fe_info.delsys.dvbs.modulation))
+ 			return -EINVAL;
+ 		if (!(fepriv->fe_params.delsys.dvbs.fec &
+ 		      fepriv->fe_info.delsys.dvbs.fec))
+ 			return -EINVAL;
+ 		break;
+ 	case DVBFE_DELSYS_DVBS2:
+ 		if (!(fepriv->fe_params.delsys.dvbs2.modulation &
+ 		      fepriv->fe_info.delsys.dvbs2.modulation))
+ 			return -EINVAL;
+ 		if (!(fepriv->fe_params.delsys.dvbs2.fec &
+ 		      fepriv->fe_info.delsys.dvbs2.fec))
+ 			return -EINVAL;
+ 		break;
+ 	case DVBFE_DELSYS_DSS:
+ 		if (!(fepriv->fe_params.delsys.dss.modulation &
+ 		      fepriv->fe_info.delsys.dss.modulation))
+ 			return -EINVAL;
+ 		if (!(fepriv->fe_params.delsys.dss.fec &
+ 		      fepriv->fe_info.delsys.dss.fec))
+ 			return -EINVAL;
+ 		break;
+ 	case DVBFE_DELSYS_DVBC:
+ 		if (!(fepriv->fe_params.delsys.dvbc.modulation &
+ 		      fepriv->fe_info.delsys.dvbc.modulation))
+ 			return -EINVAL;
+ 		break;
+ 	case DVBFE_DELSYS_DVBT:
+ 		if (!(fepriv->fe_params.delsys.dvbt.constellation &
+ 		      fepriv->fe_info.delsys.dvbt.modulation))
+ 		      return -EINVAL;
+ 		if (!(fepriv->fe_params.delsys.dvbt.priority &
+ 		      fepriv->fe_info.delsys.dvbt.stream_priority))
+ 		      return -EINVAL;
+ 		break;
+ 	case DVBFE_DELSYS_DVBH:
+ 		if (!(fepriv->fe_params.delsys.dvbh.constellation &
+ 		      fepriv->fe_info.delsys.dvbh.modulation))
+ 		      return -EINVAL;
+ 		if (!(fepriv->fe_params.delsys.dvbh.priority &
+ 		      fepriv->fe_info.delsys.dvbh.stream_priority))
+ 		      return -EINVAL;
+ 		break;
+ 	case DVBFE_DELSYS_ATSC:
+ 		if (!(fepriv->fe_params.delsys.atsc.modulation &
+ 		      fepriv->fe_info.delsys.atsc.modulation))
+ 			return -EINVAL;
+ 		break;
+ 	default:
+ 		return -EINVAL;
+ 	}
+ 
+ 	return 0;
+ }
+ 
  static int dvb_frontend_get_event(struct dvb_frontend *fe,
  			    struct dvb_frontend_event *event, int flags)
  {
***************
*** 211,220 ****
  {
  	dprintk ("DVB: initialising frontend %i (%s)...\n",
  		 fe->dvb->num,
! 		 fe->ops->info.name);
  
! 	if (fe->ops->init)
! 		fe->ops->init(fe);
  }
  
  void dvb_frontend_reinitialise(struct dvb_frontend *fe)
--- 733,747 ----
  {
  	dprintk ("DVB: initialising frontend %i (%s)...\n",
  		 fe->dvb->num,
! 		 fe->ops.info.name);
  
! 	if (fe->ops.init)
! 		fe->ops.init(fe);
! 	if (fe->ops.tuner_ops.init) {
! 		fe->ops.tuner_ops.init(fe);
! 		if (fe->ops.i2c_gate_ctrl)
! 			fe->ops.i2c_gate_ctrl(fe, 0);
! 	}
  }
  
  void dvb_frontend_reinitialise(struct dvb_frontend *fe)
***************
*** 255,266 ****
  	int autoinversion;
  	int ready = 0;
  	struct dvb_frontend_private *fepriv = fe->frontend_priv;
- 	int original_inversion = fepriv->parameters.inversion;
- 	u32 original_frequency = fepriv->parameters.frequency;
  
! 	/* are we using autoinversion? */
! 	autoinversion = ((!(fe->ops->info.caps & FE_CAN_INVERSION_AUTO)) &&
! 			 (fepriv->parameters.inversion == INVERSION_AUTO));
  
  	/* setup parameters correctly */
  	while(!ready) {
--- 782,809 ----
  	int autoinversion;
  	int ready = 0;
  	struct dvb_frontend_private *fepriv = fe->frontend_priv;
  
! 	int original_inversion;
! 	u32 original_frequency;
! 
! 	if (fe->legacy) {
! 		/* Legacy	*/
! 		original_inversion = fepriv->parameters.inversion;
! 		original_frequency = fepriv->parameters.frequency;
! 		/* are we using autoinversion ?	*/
! 		/* Legacy	*/
! 		autoinversion = ((!(fe->ops.info.caps & FE_CAN_INVERSION_AUTO)) &&
! 				 (fepriv->parameters.inversion == INVERSION_AUTO));
! 	} else {
! 		/* Superseding	*/
! 		original_inversion = fepriv->fe_params.inversion;
! 		original_frequency = fepriv->fe_params.frequency;
! 		if (fe->ops.get_info) {
! 			fe->ops.get_info(fe, &fepriv->fe_info);
! 		}
! 		autoinversion = ((!(fepriv->fe_info.inversion & INVERSION_AUTO)) &&
! 				 (fepriv->fe_params.inversion == INVERSION_AUTO));
! 	}
  
  	/* setup parameters correctly */
  	while(!ready) {
***************
*** 322,374 ****
  
  	dprintk("%s: drift:%i inversion:%i auto_step:%i "
  		"auto_sub_step:%i started_auto_step:%i\n",
! 		__FUNCTION__, fepriv->lnb_drift, fepriv->inversion,
! 		fepriv->auto_step, fepriv->auto_sub_step, fepriv->started_auto_step);
! 
! 	/* set the frontend itself */
! 	fepriv->parameters.frequency += fepriv->lnb_drift;
! 	if (autoinversion)
! 		fepriv->parameters.inversion = fepriv->inversion;
! 	if (fe->ops->set_frontend)
! 		fe->ops->set_frontend(fe, &fepriv->parameters);
  
! 	fepriv->parameters.frequency = original_frequency;
! 	fepriv->parameters.inversion = original_inversion;
  
  	fepriv->auto_sub_step++;
  	return 0;
  }
  
! static void dvb_frontend_swzigzag(struct dvb_frontend *fe)
  {
! 	fe_status_t s;
  	struct dvb_frontend_private *fepriv = fe->frontend_priv;
  
  	/* if we've got no parameters, just keep idling */
  	if (fepriv->state & FESTATE_IDLE) {
  		fepriv->delay = 3*HZ;
  		fepriv->quality = 0;
! 		return;
  	}
  
  	/* in SCAN mode, we just set the frontend when asked and leave it alone */
  	if (fepriv->tune_mode_flags & FE_TUNE_MODE_ONESHOT) {
  		if (fepriv->state & FESTATE_RETUNE) {
! 			if (fe->ops->set_frontend)
! 				fe->ops->set_frontend(fe, &fepriv->parameters);
  			fepriv->state = FESTATE_TUNED;
  		}
  		fepriv->delay = 3*HZ;
  		fepriv->quality = 0;
! 		return;
  	}
  
  	/* get the frontend status */
  	if (fepriv->state & FESTATE_RETUNE) {
  		s = 0;
  	} else {
! 		if (fe->ops->read_status)
! 			fe->ops->read_status(fe, &s);
  		if (s != fepriv->status) {
  			dvb_frontend_add_event(fe, s);
  			fepriv->status = s;
--- 865,956 ----
  
  	dprintk("%s: drift:%i inversion:%i auto_step:%i "
  		"auto_sub_step:%i started_auto_step:%i\n",
! 		__func__, fepriv->lnb_drift, fepriv->inversion,
! 		fepriv->auto_step, fepriv->auto_sub_step,
! 		fepriv->started_auto_step);
! 
! 	/* set the frontend itself	*/
! 	/* Legacy	*/
! 	if (fe->legacy)
! 		fepriv->parameters.frequency += fepriv->lnb_drift;
! 	else
! 		/* Supeseding	*/
! 		fepriv->fe_params.frequency += fepriv->lnb_drift;
  
! 	if (autoinversion) {
! 		/* Legacy	*/
! 		if (fe->legacy)
! 			fepriv->parameters.inversion = fepriv->inversion;
! 		else
! 			/* Superseding	*/
! 			fepriv->fe_params.inversion = fepriv->inversion;
! 	}
! 	/* Legacy	*/
! 	if (fe->legacy) {
! 		if (fe->ops.set_frontend)
! 			fe->ops.set_frontend(fe, &fepriv->parameters);
! 	} else {
! //		if ((dvbfe_sanity_check(fe) == 0)) {
! 			/* Superseding	*/
! 			if (fe->ops.set_params)
! 				fe->ops.set_params(fe, &fepriv->fe_params);
! //		} else
! //			return -EINVAL;
! 	}
! 	/* Legacy	*/
! 	if (fe->legacy) {
! 		fepriv->parameters.frequency = original_frequency;
! 		fepriv->parameters.inversion = original_inversion;
! 	} else {
! 		/* Superseding	*/
! 		fepriv->fe_params.frequency = original_frequency;
! 		fepriv->fe_params.inversion = original_inversion;
! 	}
  
  	fepriv->auto_sub_step++;
  	return 0;
  }
  
! static int dvb_frontend_swzigzag(struct dvb_frontend *fe)
  {
! 	fe_status_t s = 0;
  	struct dvb_frontend_private *fepriv = fe->frontend_priv;
  
  	/* if we've got no parameters, just keep idling */
  	if (fepriv->state & FESTATE_IDLE) {
  		fepriv->delay = 3*HZ;
  		fepriv->quality = 0;
! 		return 0;
  	}
  
  	/* in SCAN mode, we just set the frontend when asked and leave it alone */
  	if (fepriv->tune_mode_flags & FE_TUNE_MODE_ONESHOT) {
  		if (fepriv->state & FESTATE_RETUNE) {
! 			if (fe->legacy) {
! 				/* Legacy	*/
! 				if (fe->ops.set_frontend)
! 					fe->ops.set_frontend(fe, &fepriv->parameters);
! 			} else {
! 				if (dvbfe_sanity_check(fe) == 0) {
! 					/* Superseding	*/
! 					if (fe->ops.set_params)
! 						fe->ops.set_params(fe, &fepriv->fe_params);
! 				} else
! 					return -EINVAL;
! 			}
  			fepriv->state = FESTATE_TUNED;
  		}
  		fepriv->delay = 3*HZ;
  		fepriv->quality = 0;
! 		return 0;
  	}
  
  	/* get the frontend status */
  	if (fepriv->state & FESTATE_RETUNE) {
  		s = 0;
  	} else {
! 		if (fe->ops.read_status)
! 			fe->ops.read_status(fe, &s);
  		if (s != fepriv->status) {
  			dvb_frontend_add_event(fe, s);
  			fepriv->status = s;
***************
*** 381,391 ****
  		fepriv->state = FESTATE_TUNED;
  
  		/* if we're tuned, then we have determined the correct inversion */
! 		if ((!(fe->ops->info.caps & FE_CAN_INVERSION_AUTO)) &&
! 		    (fepriv->parameters.inversion == INVERSION_AUTO)) {
! 			fepriv->parameters.inversion = fepriv->inversion;
  		}
! 		return;
  	}
  
  	/* if we are tuned already, check we're still locked */
--- 963,984 ----
  		fepriv->state = FESTATE_TUNED;
  
  		/* if we're tuned, then we have determined the correct inversion */
! 		/* Legacy	*/
! 		if (fe->legacy) {
! 			if ((!(fe->ops.info.caps & FE_CAN_INVERSION_AUTO)) &&
! 			    (fepriv->parameters.inversion == INVERSION_AUTO)) {
! 				fepriv->parameters.inversion = fepriv->inversion;
! 			}
! 		} else {
! 			/* Superseding	*/
! 			if (fe->ops.get_info) {
! 				fe->ops.get_info(fe, &fepriv->fe_info);
! 				if ((!(fepriv->fe_info.inversion & INVERSION_AUTO)) &&
! 				    (fepriv->fe_params.inversion == INVERSION_AUTO))
! 					fepriv->fe_params.inversion = fepriv->inversion;
! 			}
  		}
! 		return 0;
  	}
  
  	/* if we are tuned already, check we're still locked */
***************
*** 394,400 ****
  
  		/* we're tuned, and the lock is still good... */
  		if (s & FE_HAS_LOCK) {
! 			return;
  		} else { /* if we _WERE_ tuned, but now don't have a lock */
  			fepriv->state = FESTATE_ZIGZAG_FAST;
  			fepriv->started_auto_step = fepriv->auto_step;
--- 987,993 ----
  
  		/* we're tuned, and the lock is still good... */
  		if (s & FE_HAS_LOCK) {
! 			return 0;
  		} else { /* if we _WERE_ tuned, but now don't have a lock */
  			fepriv->state = FESTATE_ZIGZAG_FAST;
  			fepriv->started_auto_step = fepriv->auto_step;
***************
*** 403,426 ****
  	}
  
  	/* don't actually do anything if we're in the LOSTLOCK state,
! 	 * the frontend is set to FE_CAN_RECOVER, and the max_drift is 0 */
! 	if ((fepriv->state & FESTATE_LOSTLOCK) &&
! 	    (fe->ops->info.caps & FE_CAN_RECOVER) && (fepriv->max_drift == 0)) {
! 		dvb_frontend_swzigzag_update_delay(fepriv, s & FE_HAS_LOCK);
! 		return;
  	}
  
  	/* don't do anything if we're in the DISEQC state, since this
  	 * might be someone with a motorized dish controlled by DISEQC.
! 	 * If its actually a re-tune, there will be a SET_FRONTEND soon enough.	*/
  	if (fepriv->state & FESTATE_DISEQC) {
  		dvb_frontend_swzigzag_update_delay(fepriv, s & FE_HAS_LOCK);
! 		return;
  	}
  
  	/* if we're in the RETUNE state, set everything up for a brand
  	 * new scan, keeping the current inversion setting, as the next
! 	 * tune is _very_ likely to require the same */
  	if (fepriv->state & FESTATE_RETUNE) {
  		fepriv->lnb_drift = 0;
  		fepriv->auto_step = 0;
--- 996,1038 ----
  	}
  
  	/* don't actually do anything if we're in the LOSTLOCK state,
! 	 * the frontend is set to FE_CAN_RECOVER, and the max_drift is 0
! 	 */
! 	/* Legacy	*/
! 	if (fe->legacy) {
! 		if ((fepriv->state & FESTATE_LOSTLOCK) && (fepriv->max_drift == 0)) {
! 			if (fe->ops.get_frontend_algo)
! 				if (fe->ops.get_frontend_algo(fe) == DVBFE_ALGO_RECOVERY)
! 					dvb_frontend_swzigzag_update_delay(fepriv, s & FE_HAS_LOCK);
! 
! 			return 0;
! 		}
! 	} else {
! 		if (fepriv->state & FESTATE_LOSTLOCK) {
! 			if (fe->ops.get_frontend_algo) {
! 				if ((fe->ops.get_frontend_algo(fe) == DVBFE_ALGO_RECOVERY) &&
! 				    (fepriv->max_drift == 0)) {
! 
! 					dvb_frontend_swzigzag_update_delay(fepriv, s & DVBFE_HAS_LOCK);
! 					return 0;
! 				}
! 			}
! 		}
  	}
  
  	/* don't do anything if we're in the DISEQC state, since this
  	 * might be someone with a motorized dish controlled by DISEQC.
! 	 * If its actually a re-tune, there will be a SET_FRONTEND soon enough.
! 	 */
  	if (fepriv->state & FESTATE_DISEQC) {
  		dvb_frontend_swzigzag_update_delay(fepriv, s & FE_HAS_LOCK);
! 		return 0;
  	}
  
  	/* if we're in the RETUNE state, set everything up for a brand
  	 * new scan, keeping the current inversion setting, as the next
! 	 * tune is _very_ likely to require the same
! 	 */
  	if (fepriv->state & FESTATE_RETUNE) {
  		fepriv->lnb_drift = 0;
  		fepriv->auto_step = 0;
***************
*** 436,452 ****
  		/* peform a tune */
  		if (dvb_frontend_swzigzag_autotune(fe, fepriv->check_wrapped)) {
  			/* OK, if we've run out of trials at the fast speed.
! 			 * Drop back to slow for the _next_ attempt */
  			fepriv->state = FESTATE_SEARCHING_SLOW;
  			fepriv->started_auto_step = fepriv->auto_step;
! 			return;
  		}
  		fepriv->check_wrapped = 1;
  
  		/* if we've just retuned, enter the ZIGZAG_FAST state.
  		 * This ensures we cannot return from an
  		 * FE_SET_FRONTEND ioctl before the first frontend tune
! 		 * occurs */
  		if (fepriv->state & FESTATE_RETUNE) {
  			fepriv->state = FESTATE_TUNING_FAST;
  		}
--- 1048,1066 ----
  		/* peform a tune */
  		if (dvb_frontend_swzigzag_autotune(fe, fepriv->check_wrapped)) {
  			/* OK, if we've run out of trials at the fast speed.
! 			 * Drop back to slow for the _next_ attempt
! 			 */
  			fepriv->state = FESTATE_SEARCHING_SLOW;
  			fepriv->started_auto_step = fepriv->auto_step;
! 			return 0;
  		}
  		fepriv->check_wrapped = 1;
  
  		/* if we've just retuned, enter the ZIGZAG_FAST state.
  		 * This ensures we cannot return from an
  		 * FE_SET_FRONTEND ioctl before the first frontend tune
! 		 * occurs
! 		 */
  		if (fepriv->state & FESTATE_RETUNE) {
  			fepriv->state = FESTATE_TUNING_FAST;
  		}
***************
*** 457,465 ****
  		dvb_frontend_swzigzag_update_delay(fepriv, s & FE_HAS_LOCK);
  
  		/* Note: don't bother checking for wrapping; we stay in this
! 		 * state until we get a lock */
  		dvb_frontend_swzigzag_autotune(fe, 0);
  	}
  }
  
  static int dvb_frontend_is_exiting(struct dvb_frontend *fe)
--- 1071,1082 ----
  		dvb_frontend_swzigzag_update_delay(fepriv, s & FE_HAS_LOCK);
  
  		/* Note: don't bother checking for wrapping; we stay in this
! 		 * state until we get a lock
! 		 */
  		dvb_frontend_swzigzag_autotune(fe, 0);
  	}
+ 
+ 	return 0;
  }
  
  static int dvb_frontend_is_exiting(struct dvb_frontend *fe)
***************
*** 501,519 ****
  	struct dvb_frontend *fe = data;
  	struct dvb_frontend_private *fepriv = fe->frontend_priv;
  	unsigned long timeout;
- 	char name [15];
  	fe_status_t s;
  	struct dvb_frontend_parameters *params;
  
  	dprintk("%s\n", __FUNCTION__);
  
- 	snprintf (name, sizeof(name), "kdvb-fe-%i", fe->dvb->num);
- 
- 	lock_kernel();
- 	daemonize(name);
- 	sigfillset(&current->blocked);
- 	unlock_kernel();
- 
  	fepriv->check_wrapped = 0;
  	fepriv->quality = 0;
  	fepriv->delay = 3*HZ;
--- 1118,1133 ----
  	struct dvb_frontend *fe = data;
  	struct dvb_frontend_private *fepriv = fe->frontend_priv;
  	unsigned long timeout;
  	fe_status_t s;
+ 	enum dvbfe_algo algo;
+ 
+ 	/* Legacy datatype	*/
  	struct dvb_frontend_parameters *params;
+ 	/* Superseding datatype	*/
+ 	struct dvbfe_params *fe_params = &fepriv->fe_params;
  
  	dprintk("%s\n", __FUNCTION__);
  
  	fepriv->check_wrapped = 0;
  	fepriv->quality = 0;
  	fepriv->delay = 3*HZ;
***************
*** 525,540 ****
  
  	while (1) {
  		up(&fepriv->sem);	    /* is locked when we enter the thread... */
! 
  		timeout = wait_event_interruptible_timeout(fepriv->wait_queue,
! 							   dvb_frontend_should_wakeup(fe),
! 							   fepriv->delay);
! 		if (0 != dvb_frontend_is_exiting(fe)) {
  			/* got signal or quitting */
  			break;
  		}
  
! 		try_to_freeze();
  
  		if (down_interruptible(&fepriv->sem))
  			break;
--- 1139,1156 ----
  
  	while (1) {
  		up(&fepriv->sem);	    /* is locked when we enter the thread... */
! restart:
  		timeout = wait_event_interruptible_timeout(fepriv->wait_queue,
! 			dvb_frontend_should_wakeup(fe) || kthread_should_stop(),
! 			fepriv->delay);
! 
! 		if (kthread_should_stop() || dvb_frontend_is_exiting(fe)) {
  			/* got signal or quitting */
  			break;
  		}
  
! 		if (try_to_freeze())
! 			goto restart;
  
  		if (down_interruptible(&fepriv->sem))
  			break;
***************
*** 542,592 ****
  		if (fepriv->reinitialise) {
  			dvb_frontend_init(fe);
  			if (fepriv->tone != -1) {
! 				fe->ops->set_tone(fe, fepriv->tone);
  			}
  			if (fepriv->voltage != -1) {
! 				fe->ops->set_voltage(fe, fepriv->voltage);
  			}
  			fepriv->reinitialise = 0;
  		}
  
  		/* do an iteration of the tuning loop */
! 		if (fe->ops->tune) {
! 			/* have we been asked to retune? */
! 			params = NULL;
! 			if (fepriv->state & FESTATE_RETUNE) {
! 				params = &fepriv->parameters;
! 				fepriv->state = FESTATE_TUNED;
! 			}
  
! 			fe->ops->tune(fe, params, fepriv->tune_mode_flags, &fepriv->delay, &s);
! 			if (s != fepriv->status) {
! 				dvb_frontend_add_event(fe, s);
! 				fepriv->status = s;
  			}
  		} else {
  			dvb_frontend_swzigzag(fe);
  		}
  	}
  
  	if (dvb_shutdown_timeout) {
  		if (dvb_powerdown_on_sleep)
! 			if (fe->ops->set_voltage)
! 				fe->ops->set_voltage(fe, SEC_VOLTAGE_OFF);
! 		if (fe->ops->sleep)
! 			fe->ops->sleep(fe);
  	}
  
! 	fepriv->thread_pid = 0;
  	mb();
  
  	dvb_frontend_wakeup(fe);
  	return 0;
  }
  
  static void dvb_frontend_stop(struct dvb_frontend *fe)
  {
- 	unsigned long ret;
  	struct dvb_frontend_private *fepriv = fe->frontend_priv;
  
  	dprintk ("%s\n", __FUNCTION__);
--- 1158,1270 ----
  		if (fepriv->reinitialise) {
  			dvb_frontend_init(fe);
  			if (fepriv->tone != -1) {
! 				fe->ops.set_tone(fe, fepriv->tone);
  			}
  			if (fepriv->voltage != -1) {
! 				fe->ops.set_voltage(fe, fepriv->voltage);
  			}
  			fepriv->reinitialise = 0;
  		}
  
  		/* do an iteration of the tuning loop */
! 		if (fe->ops.get_frontend_algo) {
! 			algo = fe->ops.get_frontend_algo(fe);
! 			switch (algo) {
! 			case DVBFE_ALGO_HW:
! 				dprintk("%s: Frontend ALGO = DVBFE_ALGO_HW\n", __func__);
! 				params = NULL; /* have we been asked to RETUNE ?	*/
! 
! 				if (fepriv->state & FESTATE_RETUNE) {
! 					dprintk("%s: Retune requested, FESTAT_RETUNE\n", __func__);
! 					params = &fepriv->parameters;
! 					fepriv->state = FESTATE_TUNED;
! 				}
! 				if (fe->ops.tune) {
! 					fe->ops.tune(fe, params, fepriv->tune_mode_flags, &fepriv->delay, &s);
! 					dprintk("%s: TUNE callback exists at 0x%p\n", __func__, fe->ops.tune);
! 				}
  
! 				if (s != fepriv->status) {
! 					dprintk("%s: state changed, adding current state\n", __func__);
! 					dvb_frontend_add_event(fe, s);
! 					fepriv->status = s;
! 				}
! 				break;
! 			case DVBFE_ALGO_SW:
! 				dprintk("%s: Frontend ALGO = DVBFE_ALGO_SW\n", __func__);
! 				dvb_frontend_swzigzag(fe);
! 				break;
! 			case DVBFE_ALGO_CUSTOM:
! 				params = NULL; /* have we been asked to RETUNE ?	*/
! 				dprintk("%s: Frontend ALGO = DVBFE_ALGO_CUSTOM, state=%d\n", __func__, fepriv->state);
! 				if (fepriv->state & FESTATE_RETUNE) {
! 					dprintk("%s: Retune requested, FESTAT_RETUNE\n", __func__);
! 					fe_params = &fepriv->fe_params;
! 					fepriv->state = FESTATE_TUNED;
! 				}
! 				/* Two cases where we are going to search for a carrier
! 				 *
! 				 * 1. Previous search failed. We need to probably search again
! 				 *
! 				 * 2. User asked us to retune again for some reason, possibly
! 				 *    requesting a search with a new set of parameters
! 				 */
! 				if ((!(fepriv->algo_status & DVBFE_ALGO_SEARCH_SUCCESS)) ||
! 				      (fepriv->algo_status & DVBFE_ALGO_SEARCH_AGAIN)) {
! 
! 					if (fe->ops.search) {
! 						fepriv->algo_status = fe->ops.search(fe, fe_params);
! 						dprintk("%s: SEARCH callback exists at 0x%p\n", __func__, fe->ops.search);
! 						/* We did do a search as was requested, the flags are
! 						 * now unset as well and has the flags wrt to search.
! 						 */
! 					}
! 				}
! 				/* Track the carrier if the search was successful	*/
! 				if (fepriv->algo_status == DVBFE_ALGO_SEARCH_SUCCESS) {
! 					dprintk("%s: status = DVBFE_ALGO_SEARCH_SUCCESS\n", __func__);
! 					if (fe->ops.track) {
! 						dprintk("%s: TRACK callback exists at 0x%p\n", __func__, fe->ops.track);
! 						fe->ops.track(fe, fe_params);
! 						dvb_frontend_add_event(fe, s); /* update event list	*/
! 						fepriv->status = s;
! 					}
! 				}
! 				break;
! 			default:
! 				dprintk("%s: UNDEFINED ALGO !\n", __func__);
! 				break;
  			}
+ 
  		} else {
+ 
  			dvb_frontend_swzigzag(fe);
  		}
  	}
  
  	if (dvb_shutdown_timeout) {
  		if (dvb_powerdown_on_sleep)
! 			if (fe->ops.set_voltage)
! 				fe->ops.set_voltage(fe, SEC_VOLTAGE_OFF);
! 		if (fe->ops.tuner_ops.sleep) {
! 			fe->ops.tuner_ops.sleep(fe);
! 			if (fe->ops.i2c_gate_ctrl)
! 				fe->ops.i2c_gate_ctrl(fe, 0);
! 		}
! 		if (fe->ops.sleep)
! 			fe->ops.sleep(fe);
  	}
  
! 	fepriv->thread = NULL;
  	mb();
  
+ 	dprintk("%s: frontend_wakeup\n", __func__);
  	dvb_frontend_wakeup(fe);
  	return 0;
  }
  
  static void dvb_frontend_stop(struct dvb_frontend *fe)
  {
  	struct dvb_frontend_private *fepriv = fe->frontend_priv;
  
  	dprintk ("%s\n", __FUNCTION__);
***************
*** 594,626 ****
  	fepriv->exit = 1;
  	mb();
  
! 	if (!fepriv->thread_pid)
  		return;
  
! 	/* check if the thread is really alive */
! 	if (kill_proc(fepriv->thread_pid, 0, 1) == -ESRCH) {
! 		printk("dvb_frontend_stop: thread PID %d already died\n",
! 				fepriv->thread_pid);
! 		/* make sure the mutex was not held by the thread */
! 		init_MUTEX (&fepriv->sem);
! 		return;
! 	}
! 
! 	/* wake up the frontend thread, so it notices that fe->exit == 1 */
! 	dvb_frontend_wakeup(fe);
! 
! 	/* wait until the frontend thread has exited */
! 	ret = wait_event_interruptible(fepriv->wait_queue,0 == fepriv->thread_pid);
! 	if (-ERESTARTSYS != ret) {
! 		fepriv->state = FESTATE_IDLE;
! 		return;
! 	}
  	fepriv->state = FESTATE_IDLE;
  
  	/* paranoia check in case a signal arrived */
! 	if (fepriv->thread_pid)
! 		printk("dvb_frontend_stop: warning: thread PID %d won't exit\n",
! 				fepriv->thread_pid);
  }
  
  s32 timeval_usec_diff(struct timeval lasttime, struct timeval curtime)
--- 1272,1288 ----
  	fepriv->exit = 1;
  	mb();
  
! 	if (!fepriv->thread)
  		return;
  
! 	kthread_stop(fepriv->thread);
! 	init_MUTEX (&fepriv->sem);
  	fepriv->state = FESTATE_IDLE;
  
  	/* paranoia check in case a signal arrived */
! 	if (fepriv->thread)
! 		printk("dvb_frontend_stop: warning: thread %p won't exit\n",
! 				fepriv->thread);
  }
  
  s32 timeval_usec_diff(struct timeval lasttime, struct timeval curtime)
***************
*** 670,679 ****
  {
  	int ret;
  	struct dvb_frontend_private *fepriv = fe->frontend_priv;
  
  	dprintk ("%s\n", __FUNCTION__);
  
! 	if (fepriv->thread_pid) {
  		if (!fepriv->exit)
  			return 0;
  		else
--- 1332,1342 ----
  {
  	int ret;
  	struct dvb_frontend_private *fepriv = fe->frontend_priv;
+ 	struct task_struct *fe_thread;
  
  	dprintk ("%s\n", __FUNCTION__);
  
! 	if (fepriv->thread) {
  		if (!fepriv->exit)
  			return 0;
  		else
***************
*** 687,704 ****
  
  	fepriv->state = FESTATE_IDLE;
  	fepriv->exit = 0;
! 	fepriv->thread_pid = 0;
  	mb();
  
! 	ret = kernel_thread (dvb_frontend_thread, fe, 0);
! 
! 	if (ret < 0) {
! 		printk("dvb_frontend_start: failed to start kernel_thread (%d)\n", ret);
  		up(&fepriv->sem);
  		return ret;
  	}
! 	fepriv->thread_pid = ret;
! 
  	return 0;
  }
  
--- 1350,1367 ----
  
  	fepriv->state = FESTATE_IDLE;
  	fepriv->exit = 0;
! 	fepriv->thread = NULL;
  	mb();
  
! 	fe_thread = kthread_run(dvb_frontend_thread, fe,
! 		"kdvb-fe-%i", fe->dvb->num);
! 	if (IS_ERR(fe_thread)) {
! 		ret = PTR_ERR(fe_thread);
! 		printk("dvb_frontend_start: failed to start kthread (%d)\n", ret);
  		up(&fepriv->sem);
  		return ret;
  	}
! 	fepriv->thread = fe_thread;
  	return 0;
  }
  
***************
*** 709,714 ****
--- 1372,1378 ----
  	struct dvb_frontend *fe = dvbdev->priv;
  	struct dvb_frontend_private *fepriv = fe->frontend_priv;
  	int err = -EOPNOTSUPP;
+ 	enum dvbfe_delsys delsys = 0;
  
  	dprintk ("%s\n", __FUNCTION__);
  
***************
*** 726,732 ****
  	switch (cmd) {
  	case FE_GET_INFO: {
  		struct dvb_frontend_info* info = parg;
! 		memcpy(info, &fe->ops->info, sizeof(struct dvb_frontend_info));
  
  		/* Force the CAN_INVERSION_AUTO bit on. If the frontend doesn't
  		 * do it, it is done for it. */
--- 1390,1396 ----
  	switch (cmd) {
  	case FE_GET_INFO: {
  		struct dvb_frontend_info* info = parg;
! 		memcpy(info, &fe->ops.info, sizeof(struct dvb_frontend_info));
  
  		/* Force the CAN_INVERSION_AUTO bit on. If the frontend doesn't
  		 * do it, it is done for it. */
***************
*** 746,803 ****
  			break;
  		}
  
! 		if (fe->ops->read_status)
! 			err = fe->ops->read_status(fe, status);
  		break;
  	}
  	case FE_READ_BER:
! 		if (fe->ops->read_ber)
! 			err = fe->ops->read_ber(fe, (__u32*) parg);
  		break;
  
  	case FE_READ_SIGNAL_STRENGTH:
! 		if (fe->ops->read_signal_strength)
! 			err = fe->ops->read_signal_strength(fe, (__u16*) parg);
  		break;
  
  	case FE_READ_SNR:
! 		if (fe->ops->read_snr)
! 			err = fe->ops->read_snr(fe, (__u16*) parg);
  		break;
  
  	case FE_READ_UNCORRECTED_BLOCKS:
! 		if (fe->ops->read_ucblocks)
! 			err = fe->ops->read_ucblocks(fe, (__u32*) parg);
  		break;
  
  
  	case FE_DISEQC_RESET_OVERLOAD:
! 		if (fe->ops->diseqc_reset_overload) {
! 			err = fe->ops->diseqc_reset_overload(fe);
  			fepriv->state = FESTATE_DISEQC;
  			fepriv->status = 0;
  		}
  		break;
  
  	case FE_DISEQC_SEND_MASTER_CMD:
! 		if (fe->ops->diseqc_send_master_cmd) {
! 			err = fe->ops->diseqc_send_master_cmd(fe, (struct dvb_diseqc_master_cmd*) parg);
  			fepriv->state = FESTATE_DISEQC;
  			fepriv->status = 0;
  		}
  		break;
  
  	case FE_DISEQC_SEND_BURST:
! 		if (fe->ops->diseqc_send_burst) {
! 			err = fe->ops->diseqc_send_burst(fe, (fe_sec_mini_cmd_t) parg);
  			fepriv->state = FESTATE_DISEQC;
  			fepriv->status = 0;
  		}
  		break;
  
  	case FE_SET_TONE:
! 		if (fe->ops->set_tone) {
! 			err = fe->ops->set_tone(fe, (fe_sec_tone_mode_t) parg);
  			fepriv->tone = (fe_sec_tone_mode_t) parg;
  			fepriv->state = FESTATE_DISEQC;
  			fepriv->status = 0;
--- 1410,1467 ----
  			break;
  		}
  
! 		if (fe->ops.read_status)
! 			err = fe->ops.read_status(fe, status);
  		break;
  	}
  	case FE_READ_BER:
! 		if (fe->ops.read_ber)
! 			err = fe->ops.read_ber(fe, (__u32*) parg);
  		break;
  
  	case FE_READ_SIGNAL_STRENGTH:
! 		if (fe->ops.read_signal_strength)
! 			err = fe->ops.read_signal_strength(fe, (__u16*) parg);
  		break;
  
  	case FE_READ_SNR:
! 		if (fe->ops.read_snr)
! 			err = fe->ops.read_snr(fe, (__u16*) parg);
  		break;
  
  	case FE_READ_UNCORRECTED_BLOCKS:
! 		if (fe->ops.read_ucblocks)
! 			err = fe->ops.read_ucblocks(fe, (__u32*) parg);
  		break;
  
  
  	case FE_DISEQC_RESET_OVERLOAD:
! 		if (fe->ops.diseqc_reset_overload) {
! 			err = fe->ops.diseqc_reset_overload(fe);
  			fepriv->state = FESTATE_DISEQC;
  			fepriv->status = 0;
  		}
  		break;
  
  	case FE_DISEQC_SEND_MASTER_CMD:
! 		if (fe->ops.diseqc_send_master_cmd) {
! 			err = fe->ops.diseqc_send_master_cmd(fe, (struct dvb_diseqc_master_cmd*) parg);
  			fepriv->state = FESTATE_DISEQC;
  			fepriv->status = 0;
  		}
  		break;
  
  	case FE_DISEQC_SEND_BURST:
! 		if (fe->ops.diseqc_send_burst) {
! 			err = fe->ops.diseqc_send_burst(fe, (fe_sec_mini_cmd_t) parg);
  			fepriv->state = FESTATE_DISEQC;
  			fepriv->status = 0;
  		}
  		break;
  
  	case FE_SET_TONE:
! 		if (fe->ops.set_tone) {
! 			err = fe->ops.set_tone(fe, (fe_sec_tone_mode_t) parg);
  			fepriv->tone = (fe_sec_tone_mode_t) parg;
  			fepriv->state = FESTATE_DISEQC;
  			fepriv->status = 0;
***************
*** 805,812 ****
  		break;
  
  	case FE_SET_VOLTAGE:
! 		if (fe->ops->set_voltage) {
! 			err = fe->ops->set_voltage(fe, (fe_sec_voltage_t) parg);
  			fepriv->voltage = (fe_sec_voltage_t) parg;
  			fepriv->state = FESTATE_DISEQC;
  			fepriv->status = 0;
--- 1469,1476 ----
  		break;
  
  	case FE_SET_VOLTAGE:
! 		if (fe->ops.set_voltage) {
! 			err = fe->ops.set_voltage(fe, (fe_sec_voltage_t) parg);
  			fepriv->voltage = (fe_sec_voltage_t) parg;
  			fepriv->state = FESTATE_DISEQC;
  			fepriv->status = 0;
***************
*** 814,824 ****
  		break;
  
  	case FE_DISHNETWORK_SEND_LEGACY_CMD:
! 		if (fe->ops->dishnetwork_send_legacy_command) {
! 			err = fe->ops->dishnetwork_send_legacy_command(fe, (unsigned long) parg);
  			fepriv->state = FESTATE_DISEQC;
  			fepriv->status = 0;
! 		} else if (fe->ops->set_voltage) {
  			/*
  			 * NOTE: This is a fallback condition.  Some frontends
  			 * (stv0299 for instance) take longer than 8msec to
--- 1478,1488 ----
  		break;
  
  	case FE_DISHNETWORK_SEND_LEGACY_CMD:
! 		if (fe->ops.dishnetwork_send_legacy_command) {
! 			err = fe->ops.dishnetwork_send_legacy_command(fe, (unsigned long) parg);
  			fepriv->state = FESTATE_DISEQC;
  			fepriv->status = 0;
! 		} else if (fe->ops.set_voltage) {
  			/*
  			 * NOTE: This is a fallback condition.  Some frontends
  			 * (stv0299 for instance) take longer than 8msec to
***************
*** 848,854 ****
  			/* before sending a command, initialize by sending
  			 * a 32ms 18V to the switch
  			 */
! 			fe->ops->set_voltage(fe, SEC_VOLTAGE_18);
  			dvb_frontend_sleep_until(&nexttime, 32000);
  
  			for (i = 0; i < 9; i++) {
--- 1512,1518 ----
  			/* before sending a command, initialize by sending
  			 * a 32ms 18V to the switch
  			 */
! 			fe->ops.set_voltage(fe, SEC_VOLTAGE_18);
  			dvb_frontend_sleep_until(&nexttime, 32000);
  
  			for (i = 0; i < 9; i++) {
***************
*** 856,862 ****
  					do_gettimeofday(&tv[i + 1]);
  				if ((cmd & 0x01) != last) {
  					/* set voltage to (last ? 13V : 18V) */
! 					fe->ops->set_voltage(fe, (last) ? SEC_VOLTAGE_13 : SEC_VOLTAGE_18);
  					last = (last) ? 0 : 1;
  				}
  				cmd = cmd >> 1;
--- 1520,1526 ----
  					do_gettimeofday(&tv[i + 1]);
  				if ((cmd & 0x01) != last) {
  					/* set voltage to (last ? 13V : 18V) */
! 					fe->ops.set_voltage(fe, (last) ? SEC_VOLTAGE_13 : SEC_VOLTAGE_18);
  					last = (last) ? 0 : 1;
  				}
  				cmd = cmd >> 1;
***************
*** 876,907 ****
  		break;
  
  	case FE_DISEQC_RECV_SLAVE_REPLY:
! 		if (fe->ops->diseqc_recv_slave_reply)
! 			err = fe->ops->diseqc_recv_slave_reply(fe, (struct dvb_diseqc_slave_reply*) parg);
  		break;
  
  	case FE_ENABLE_HIGH_LNB_VOLTAGE:
! 		if (fe->ops->enable_high_lnb_voltage)
! 			err = fe->ops->enable_high_lnb_voltage(fe, (long) parg);
  		break;
  
  	case FE_SET_FRONTEND: {
  		struct dvb_frontend_tune_settings fetunesettings;
  
! 		memcpy (&fepriv->parameters, parg,
! 			sizeof (struct dvb_frontend_parameters));
! 
  		memset(&fetunesettings, 0, sizeof(struct dvb_frontend_tune_settings));
! 		memcpy(&fetunesettings.parameters, parg,
! 		       sizeof (struct dvb_frontend_parameters));
  
  		/* force auto frequency inversion if requested */
  		if (dvb_force_auto_inversion) {
  			fepriv->parameters.inversion = INVERSION_AUTO;
  			fetunesettings.parameters.inversion = INVERSION_AUTO;
  		}
! 		if (fe->ops->info.type == FE_OFDM) {
! 			/* without hierachical coding code_rate_LP is irrelevant,
  			 * so we tolerate the otherwise invalid FEC_NONE setting */
  			if (fepriv->parameters.u.ofdm.hierarchy_information == HIERARCHY_NONE &&
  			    fepriv->parameters.u.ofdm.code_rate_LP == FEC_NONE)
--- 1540,1569 ----
  		break;
  
  	case FE_DISEQC_RECV_SLAVE_REPLY:
! 		if (fe->ops.diseqc_recv_slave_reply)
! 			err = fe->ops.diseqc_recv_slave_reply(fe, (struct dvb_diseqc_slave_reply*) parg);
  		break;
  
  	case FE_ENABLE_HIGH_LNB_VOLTAGE:
! 		if (fe->ops.enable_high_lnb_voltage)
! 			err = fe->ops.enable_high_lnb_voltage(fe, (long) parg);
  		break;
  
  	case FE_SET_FRONTEND: {
  		struct dvb_frontend_tune_settings fetunesettings;
+ 		fe->legacy = 1;
  
! 		memcpy(&fepriv->parameters, parg, sizeof (struct dvb_frontend_parameters));
  		memset(&fetunesettings, 0, sizeof(struct dvb_frontend_tune_settings));
! 		memcpy(&fetunesettings.parameters, parg, sizeof (struct dvb_frontend_parameters));
  
  		/* force auto frequency inversion if requested */
  		if (dvb_force_auto_inversion) {
  			fepriv->parameters.inversion = INVERSION_AUTO;
  			fetunesettings.parameters.inversion = INVERSION_AUTO;
  		}
! 		if (fe->ops.info.type == FE_OFDM) {
! 			/* without hierarchical coding code_rate_LP is irrelevant,
  			 * so we tolerate the otherwise invalid FEC_NONE setting */
  			if (fepriv->parameters.u.ofdm.hierarchy_information == HIERARCHY_NONE &&
  			    fepriv->parameters.u.ofdm.code_rate_LP == FEC_NONE)
***************
*** 909,921 ****
  		}
  
  		/* get frontend-specific tuning settings */
! 		if (fe->ops->get_tune_settings && (fe->ops->get_tune_settings(fe, &fetunesettings) == 0)) {
  			fepriv->min_delay = (fetunesettings.min_delay_ms * HZ) / 1000;
  			fepriv->max_drift = fetunesettings.max_drift;
  			fepriv->step_size = fetunesettings.step_size;
  		} else {
  			/* default values */
! 			switch(fe->ops->info.type) {
  			case FE_QPSK:
  				fepriv->min_delay = HZ/20;
  				fepriv->step_size = fepriv->parameters.u.qpsk.symbol_rate / 16000;
--- 1571,1583 ----
  		}
  
  		/* get frontend-specific tuning settings */
! 		if (fe->ops.get_tune_settings && (fe->ops.get_tune_settings(fe, &fetunesettings) == 0)) {
  			fepriv->min_delay = (fetunesettings.min_delay_ms * HZ) / 1000;
  			fepriv->max_drift = fetunesettings.max_drift;
  			fepriv->step_size = fetunesettings.step_size;
  		} else {
  			/* default values */
! 			switch(fe->ops.info.type) {
  			case FE_QPSK:
  				fepriv->min_delay = HZ/20;
  				fepriv->step_size = fepriv->parameters.u.qpsk.symbol_rate / 16000;
***************
*** 930,940 ****
  
  			case FE_OFDM:
  				fepriv->min_delay = HZ/20;
! 				fepriv->step_size = fe->ops->info.frequency_stepsize * 2;
! 				fepriv->max_drift = (fe->ops->info.frequency_stepsize * 2) + 1;
  				break;
  			case FE_ATSC:
! 				printk("dvb-core: FE_ATSC not handled yet.\n");
  				break;
  			}
  		}
--- 1592,1604 ----
  
  			case FE_OFDM:
  				fepriv->min_delay = HZ/20;
! 				fepriv->step_size = fe->ops.info.frequency_stepsize * 2;
! 				fepriv->max_drift = (fe->ops.info.frequency_stepsize * 2) + 1;
  				break;
  			case FE_ATSC:
! 				fepriv->min_delay = HZ/20;
! 				fepriv->step_size = 0;
! 				fepriv->max_drift = 0;
  				break;
  			}
  		}
***************
*** 954,974 ****
  		break;
  
  	case FE_GET_FRONTEND:
! 		if (fe->ops->get_frontend) {
  			memcpy (parg, &fepriv->parameters, sizeof (struct dvb_frontend_parameters));
! 			err = fe->ops->get_frontend(fe, (struct dvb_frontend_parameters*) parg);
  		}
  		break;
  
  	case FE_SET_FRONTEND_TUNE_MODE:
  		fepriv->tune_mode_flags = (unsigned long) parg;
  		break;
- 	};
  
  	up (&fepriv->sem);
  	return err;
  }
  
  static unsigned int dvb_frontend_poll(struct file *file, struct poll_table_struct *wait)
  {
  	struct dvb_device *dvbdev = file->private_data;
--- 1618,1752 ----
  		break;
  
  	case FE_GET_FRONTEND:
! 		fe->legacy = 1;
! 		if (fe->ops.get_frontend) {
  			memcpy (parg, &fepriv->parameters, sizeof (struct dvb_frontend_parameters));
! 			err = fe->ops.get_frontend(fe, (struct dvb_frontend_parameters*) parg);
  		}
  		break;
  
  	case FE_SET_FRONTEND_TUNE_MODE:
  		fepriv->tune_mode_flags = (unsigned long) parg;
+ 		err = 0;
  		break;
  
+ 	case DVBFE_SET_PARAMS: {
+ 		struct dvb_frontend_tune_settings fetunesettings;
+ 
+ 		fe->legacy = 0;
+ 		memcpy(&fepriv->fe_params, parg, sizeof (struct dvbfe_params));
+ 		memset(&fetunesettings, 0, sizeof (struct dvb_frontend_tune_settings));
+ 		memcpy(&fetunesettings.fe_params, parg, sizeof (struct dvbfe_params));
+ 
+ 		if (newapi_to_olddrv(&fepriv->fe_params, &fepriv->parameters, fepriv->fe_info.delivery)  == -EINVAL)
+ 			printk("%s: ERROR !!! Converting New parameters --> Old parameters\n", __func__);
+ 
+ 		/* Request the search algorithm to search	*/
+ 		fepriv->algo_status |= DVBFE_ALGO_SEARCH_AGAIN;
+ 
+ 		/* force auto frequency inversion if requested */
+ 		if (dvb_force_auto_inversion) {
+ 			fepriv->fe_params.inversion = DVBFE_INVERSION_AUTO;
+ 			fetunesettings.fe_params.inversion = DVBFE_INVERSION_AUTO;
+ 		}
+ 		if (fe->ops.get_delsys) {
+ 			fe->ops.get_delsys(fe, &delsys);
+ 			if ((delsys == DVBFE_DELSYS_DVBT) ||
+ 			    (delsys == DVBFE_DELSYS_DVBH)) {
+ 
+ 				/* without hierachical coding code_rate_LP is irrelevant,
+ 				 * so we tolerate the otherwise invalid FEC_NONE setting */
+ 				if (fepriv->fe_params.delsys.dvbt.hierarchy == DVBFE_HIERARCHY_OFF &&
+ 				    fepriv->fe_params.delsys.dvbt.code_rate_LP == DVBFE_FEC_NONE)
+ 
+ 					fepriv->fe_params.delsys.dvbt.code_rate_LP = DVBFE_FEC_AUTO;
+ 			}
+ 		}
+ 
+ 		/* get frontend-specific tuning settings */
+ 		if (fe->ops.get_tune_settings &&
+ 		   (fe->ops.get_tune_settings(fe, &fetunesettings) == 0)) {
+ 
+ 			fepriv->min_delay = (fetunesettings.min_delay_ms * HZ) / 1000;
+ 			fepriv->max_drift = fetunesettings.max_drift;
+ 			fepriv->step_size = fetunesettings.step_size;
+ 		} else {
+ 			/* default values */
+ 			switch (fepriv->fe_info.delivery) {
+ 			case DVBFE_DELSYS_DVBS:
+ 			case DVBFE_DELSYS_DSS:
+ 			case DVBFE_DELSYS_DVBS2:
+ 				fepriv->min_delay = HZ / 20;
+ 				fepriv->step_size = fepriv->fe_params.delsys.dvbs.symbol_rate / 16000;
+ 				fepriv->max_drift = fepriv->fe_params.delsys.dvbs.symbol_rate / 2000;
+ 				break;
+ 			case DVBFE_DELSYS_DVBC:
+ 				fepriv->min_delay = HZ / 20;
+ 				fepriv->step_size = 0; /* no zigzag */
+ 				fepriv->max_drift = 0;
+ 				break;
+ 			case DVBFE_DELSYS_DVBT:
+ 			case DVBFE_DELSYS_DVBH:
+ 				fepriv->min_delay = HZ / 20;
+ 				fepriv->step_size = fepriv->fe_info.frequency_step * 2;
+ 				fepriv->max_drift = (fepriv->fe_info.frequency_step * 2) + 1;
+ 				break;
+ 				break;
+ 			case DVBFE_DELSYS_ATSC:
+ 				fepriv->min_delay = HZ / 20;
+ 				fepriv->step_size = 0;
+ 				fepriv->max_drift = 0;
+ 				break;
+ 			default:
+ 				return -EINVAL;
+ 			}
+ 		}
+ 		if (dvb_override_tune_delay > 0)
+ 			fepriv->min_delay = (dvb_override_tune_delay * HZ) / 1000;
+ 
+ 		fepriv->state = FESTATE_RETUNE;
+ 		printk("%s: FESTATE_RETUNE: fepriv->state=%d\n", __func__, fepriv->state);
+ 		dvb_frontend_wakeup(fe);
+ 		dvb_frontend_add_event(fe, 0);
+ 		fepriv->status = 0;
+ 		err = 0;
+ 		break;
+ 	}
+ 
+ 	case DVBFE_GET_PARAMS:
+ 		fe->legacy = 0;
+ 		if (fe->ops.get_params) {
+ 			memcpy(parg, &fepriv->fe_params, sizeof (struct dvbfe_params));
+ 			err = fe->ops.get_params(fe, (struct dvbfe_params *) parg);
+ 
+ 		} else if (fe->ops.get_frontend) {
+ 			memcpy (parg, &fepriv->parameters, sizeof (struct dvb_frontend_parameters));
+ 			err = fe->ops.get_frontend(fe, (struct dvb_frontend_parameters*) parg);
+ 			if (olddrv_to_newapi(fe, &fepriv->fe_params, &fepriv->parameters, fe->ops.info.type) == -EINVAL)
+ 				printk("%s: ERROR !!! Converting Old parameters --> New parameters\n", __func__);
+ 		}
+ 		break;
+ 	case DVBFE_GET_DELSYS:
+ 		fe->legacy = 0;
+ 		if (fe->ops.get_delsys) {
+ 			err = fe->ops.get_delsys(fe, (enum dvbfe_delsys *) parg);
+ 		}
+ 		break;
+ 	case DVBFE_GET_INFO:
+ 		printk("%s: DVBFE_GET_INFO\n", __func__);
+ 		fe->legacy = 0;
+ 		if (fe->ops.get_info) {
+ 			memcpy(&fepriv->fe_info, (struct dvbfe_info *) parg, sizeof (struct dvbfe_info));
+ 			err = fe->ops.get_info(fe, &fepriv->fe_info);
+ 			memcpy((struct dvbfe_info *) parg, &fepriv->fe_info, sizeof (struct dvbfe_info));
+ 		}
+ 		break;
+ 	};
  	up (&fepriv->sem);
  	return err;
  }
  
+ 
  static unsigned int dvb_frontend_poll(struct file *file, struct poll_table_struct *wait)
  {
  	struct dvb_device *dvbdev = file->private_data;
***************
*** 997,1003 ****
--- 1775,1789 ----
  	if ((ret = dvb_generic_open (inode, file)) < 0)
  		return ret;
  
+ 	if (fe->ops.ts_bus_ctrl) {
+ 		if ((ret = fe->ops.ts_bus_ctrl (fe, 1)) < 0) {
+ 			dvb_generic_release (inode, file);
+ 			return ret;
+ 		}
+ 	}
+ 
  	if ((file->f_flags & O_ACCMODE) != O_RDONLY) {
+ 
  		/* normal tune mode when opened R/W */
  		fepriv->tune_mode_flags &= ~FE_TUNE_MODE_ONESHOT;
  		fepriv->tone = -1;
***************
*** 1025,1030 ****
--- 1811,1819 ----
  	if ((file->f_flags & O_ACCMODE) != O_RDONLY)
  		fepriv->release_jiffies = jiffies;
  
+ 	if (fe->ops.ts_bus_ctrl)
+ 		fe->ops.ts_bus_ctrl (fe, 0);
+ 
  	return dvb_generic_release (inode, file);
  }
  
***************
*** 1069,1075 ****
  
  	printk ("DVB: registering frontend %i (%s)...\n",
  		fe->dvb->num,
! 		fe->ops->info.name);
  
  	dvb_register_device (fe->dvb, &fepriv->dvbdev, &dvbdev_template,
  			     fe, DVB_DEVICE_FRONTEND);
--- 1858,1864 ----
  
  	printk ("DVB: registering frontend %i (%s)...\n",
  		fe->dvb->num,
! 		fe->ops.info.name);
  
  	dvb_register_device (fe->dvb, &fepriv->dvbdev, &dvbdev_template,
  			     fe, DVB_DEVICE_FRONTEND);
***************
*** 1087,1099 ****
  	mutex_lock(&frontend_mutex);
  	dvb_unregister_device (fepriv->dvbdev);
  	dvb_frontend_stop (fe);
! 	if (fe->ops->release)
! 		fe->ops->release(fe);
! 	else
! 		printk("dvb_frontend: Demodulator (%s) does not have a release callback!\n", fe->ops->info.name);
  	/* fe is invalid now */
  	kfree(fepriv);
  	mutex_unlock(&frontend_mutex);
  	return 0;
  }
  EXPORT_SYMBOL(dvb_unregister_frontend);
--- 1876,1917 ----
  	mutex_lock(&frontend_mutex);
  	dvb_unregister_device (fepriv->dvbdev);
  	dvb_frontend_stop (fe);
! 
  	/* fe is invalid now */
  	kfree(fepriv);
  	mutex_unlock(&frontend_mutex);
  	return 0;
  }
  EXPORT_SYMBOL(dvb_unregister_frontend);
+ 
+ #ifdef CONFIG_DVB_CORE_ATTACH
+ void dvb_frontend_detach(struct dvb_frontend* fe)
+ {
+ 	void *ptr;
+ 
+ 	if (fe->ops.release_sec) {
+ 		fe->ops.release_sec(fe);
+ 		symbol_put_addr(fe->ops.release_sec);
+ 	}
+ 	if (fe->ops.tuner_ops.release) {
+ 		fe->ops.tuner_ops.release(fe);
+ 		symbol_put_addr(fe->ops.tuner_ops.release);
+ 	}
+ 	ptr = (void*)fe->ops.release;
+ 	if (ptr) {
+ 		fe->ops.release(fe);
+ 		symbol_put_addr(ptr);
+ 	}
+ }
+ #else
+ void dvb_frontend_detach(struct dvb_frontend* fe)
+ {
+ 	if (fe->ops.release_sec)
+ 		fe->ops.release_sec(fe);
+ 	if (fe->ops.tuner_ops.release)
+ 		fe->ops.tuner_ops.release(fe);
+ 	if (fe->ops.release)
+ 		fe->ops.release(fe);
+ }
+ #endif
+ EXPORT_SYMBOL(dvb_frontend_detach);
diff -rcN linux/drivers/media/dvb/dvb-core/dvb_frontend.h UFS922_Orig/drivers/media/dvb/dvb-core/dvb_frontend.h
*** linux/drivers/media/dvb/dvb-core/dvb_frontend.h	2006-06-18 03:49:35.000000000 +0200
--- UFS922_Orig/drivers/media/dvb/dvb-core/dvb_frontend.h	2009-02-10 19:24:55.000000000 +0100
***************
*** 8,13 ****
--- 8,16 ----
   * Overhauled by Holger Waechtler
   * Kernel I2C stuff by Michael Hunold <hunold@convergence.de>
   *
+  * Overhauled for Silicon Tuners, Search Algorithms and multiprotocol
+  * support by Manu Abraham <abraham.manu@gmail.com>
+  *
   * This program is free software; you can redistribute it and/or
   * modify it under the terms of the GNU Lesser General Public License
   * as published by the Free Software Foundation; either version 2.1
***************
*** 45,69 ****
--- 48,236 ----
  	int step_size;
  	int max_drift;
  	struct dvb_frontend_parameters parameters;
+ 	struct dvbfe_params fe_params;
  };
  
  struct dvb_frontend;
  
+ struct dvb_tuner_info {
+ 	char name[128];
+ 
+ 	u32 frequency_min;
+ 	u32 frequency_max;
+ 	u32 frequency_step;
+ 
+ 	u32 bandwidth_min;
+ 	u32 bandwidth_max;
+ 	u32 bandwidth_step;
+ };
+ 
+ enum dvbfe_modcod {
+ 	DVBFE_MODCOD_DUMMY_PLFRAME	= 0,
+ 	DVBFE_MODCOD_QPSK_1_4,
+ 	DVBFE_MODCOD_QPSK_1_3,
+ 	DVBFE_MODCOD_QPSK_2_5,
+ 	DVBFE_MODCOD_QPSK_1_2,
+ 	DVBFE_MODCOD_QPSK_3_5,
+ 	DVBFE_MODCOD_QPSK_2_3,
+ 	DVBFE_MODCOD_QPSK_3_4,
+ 	DVBFE_MODCOD_QPSK_4_5,
+ 	DVBFE_MODCOD_QPSK_5_6,
+ 	DVBFE_MODCOD_QPSK_8_9,
+ 	DVBFE_MODCOD_QPSK_9_10,
+ 	DVBFE_MODCOD_8PSK_3_5,
+ 	DVBFE_MODCOD_8PSK_2_3,
+ 	DVBFE_MODCOD_8PSK_3_4,
+ 	DVBFE_MODCOD_8PSK_5_6,
+ 	DVBFE_MODCOD_8PSK_8_9,
+ 	DVBFE_MODCOD_8PSK_9_10,
+ 	DVBFE_MODCOD_16APSK_2_3,
+ 	DVBFE_MODCOD_16APSK_3_4,
+ 	DVBFE_MODCOD_16APSK_4_5,
+ 	DVBFE_MODCOD_16APSK_5_6,
+ 	DVBFE_MODCOD_16APSK_8_9,
+ 	DVBFE_MODCOD_16APSK_9_10,
+ 	DVBFE_MODCOD_32APSK_3_4,
+ 	DVBFE_MODCOD_32APSK_4_5,
+ 	DVBFE_MODCOD_32APSK_5_6,
+ 	DVBFE_MODCOD_32APSK_8_9,
+ 	DVBFE_MODCOD_32APSK_9_10,
+ 	DVBFE_MODCOD_RESERVED_1,
+ 	DVBFE_MODCOD_BPSK_1_3,
+ 	DVBFE_MODCOD_BPSK_1_4,
+ 	DVBFE_MODCOD_RESERVED_2
+ };
+ 
+ enum tuner_param {
+ 	DVBFE_TUNER_FREQUENCY		= (1 <<  0),
+ 	DVBFE_TUNER_TUNERSTEP		= (1 <<  1),
+ 	DVBFE_TUNER_IFFREQ		= (1 <<  2),
+ 	DVBFE_TUNER_BANDWIDTH		= (1 <<  3),
+ 	DVBFE_TUNER_REFCLOCK		= (1 <<  4),
+ 	DVBFE_TUNER_IQSENSE		= (1 <<  5),
+ 	DVBFE_TUNER_DUMMY		= (1 << 31)
+ };
+ 
+ /*
+  * ALGO_HW: (Hardware Algorithm)
+  * ----------------------------------------------------------------
+  * Devices that support this algorithm do everything in hardware
+  * and no software support is needed to handle them.
+  * Requesting these devices to LOCK is the only thing required,
+  * device is supposed to do everything in the hardware.
+  *
+  * ALGO_SW: (Software Algorithm)
+  * ----------------------------------------------------------------
+  * These are dumb devices, that require software to do everything
+  *
+  * ALGO_CUSTOM: (Customizable Agorithm)
+  * ----------------------------------------------------------------
+  * Devices having this algorithm can be customized to have specific
+  * algorithms in the frontend driver, rather than simply doing a
+  * software zig-zag. In this case the zigzag maybe hardware assisted
+  * or it maybe completely done in hardware. In all cases, usage of
+  * this algorithm, in conjunction with the search and track
+  * callbacks, utilizes the driver specific algorithm.
+  *
+  * ALGO_RECOVERY: (Recovery Algorithm)
+  * ----------------------------------------------------------------
+  * These devices has AUTO recovery capabilities from LOCK failure
+  */
+ enum dvbfe_algo {
+ 	DVBFE_ALGO_HW			= (1 <<  0),
+ 	DVBFE_ALGO_SW			= (1 <<  1),
+ 	DVBFE_ALGO_CUSTOM		= (1 <<  2),
+ 	DVBFE_ALGO_RECOVERY		= (1 <<  31)
+ };
+ 
+ struct tuner_state {
+ 	u32 frequency;
+ 	u32 tunerstep;
+ 	u32 ifreq;
+ 	u32 bandwidth;
+ 	u32 iqsense;
+ 	u32 refclock;
+ };
+ 
+ /*
+  * search callback possible return status
+  *
+  * DVBFE_ALGO_SEARCH_SUCCESS
+  * The frontend search algorithm completed and returned succesfully
+  *
+  * DVBFE_ALGO_SEARCH_ASLEEP
+  * The frontend search algorithm is sleeping
+  *
+  * DVBFE_ALGO_SEARCH_FAILED
+  * The frontend search for a signal failed
+  *
+  * DVBFE_ALGO_SEARCH_INVALID
+  * The frontend search algorith was probably supplied with invalid
+  * parameters and the search is an invalid one
+  *
+  * DVBFE_ALGO_SEARCH_ERROR
+  * The frontend search algorithm failed due to some error
+  *
+  * DVBFE_ALGO_SEARCH_AGAIN
+  * The frontend search algorithm was requested to search again
+  */
+ enum dvbfe_search {
+ 	DVBFE_ALGO_SEARCH_SUCCESS	= (1 <<  0),
+ 	DVBFE_ALGO_SEARCH_ASLEEP	= (1 <<  1),
+ 	DVBFE_ALGO_SEARCH_FAILED	= (1 <<  2),
+ 	DVBFE_ALGO_SEARCH_INVALID	= (1 <<  3),
+ 	DVBFE_ALGO_SEARCH_AGAIN		= (1 <<  4),
+ 	DVBFE_ALGO_SEARCH_ERROR		= (1 << 31),
+ };
+ 
+ struct dvb_tuner_ops {
+ 
+ 	struct dvb_tuner_info info;
+ 
+ 	int (*release)(struct dvb_frontend *fe);
+ 	int (*init)(struct dvb_frontend *fe);
+ 	int (*sleep)(struct dvb_frontend *fe);
+ 
+ 	/** This is for simple PLLs - set all parameters in one go. */
+ 	int (*set_params)(struct dvb_frontend *fe, struct dvb_frontend_parameters *p);
+ 
+ 	/** This is support for demods like the mt352 - fills out the supplied buffer with what to write. */
+ 	int (*calc_regs)(struct dvb_frontend *fe, struct dvb_frontend_parameters *p, u8 *buf, int buf_len);
+ 
+ 	int (*get_frequency)(struct dvb_frontend *fe, u32 *frequency);
+ 	int (*get_bandwidth)(struct dvb_frontend *fe, u32 *bandwidth);
+ 
+ #define TUNER_STATUS_LOCKED 1
+ 	int (*get_status)(struct dvb_frontend *fe, u32 *status);
+ 
+ 	/**
+ 	 * These are provided seperately from set_params in order to facilitate silicon
+ 	 * tuners which require sophisticated tuning loops, controlling each parameter seperately.
+ 	 */
+ 	int (*set_state)(struct dvb_frontend *fe, enum tuner_param param, struct tuner_state *state);
+ 	int (*get_state)(struct dvb_frontend *fe, enum tuner_param param, struct tuner_state *state);
+ };
+ 
  struct dvb_frontend_ops {
  
  	struct dvb_frontend_info info;
  
  	void (*release)(struct dvb_frontend* fe);
+ 	void (*release_sec)(struct dvb_frontend* fe);
  
  	int (*init)(struct dvb_frontend* fe);
  	int (*sleep)(struct dvb_frontend* fe);
  
+ 	int (*write)(struct dvb_frontend* fe, u8* buf, int len);
+ 
  	/* if this is set, it overrides the default swzigzag */
  	int (*tune)(struct dvb_frontend* fe,
  		    struct dvb_frontend_parameters* params,
  		    unsigned int mode_flags,
  		    int *delay,
  		    fe_status_t *status);
+ 	/* get frontend tuning algorithm from the module */
+ 	enum dvbfe_algo (*get_frontend_algo)(struct dvb_frontend *fe);
  
  	/* these two are only used for the swzigzag code */
  	int (*set_frontend)(struct dvb_frontend* fe, struct dvb_frontend_parameters* params);
***************
*** 86,91 ****
--- 253,273 ----
  	int (*enable_high_lnb_voltage)(struct dvb_frontend* fe, long arg);
  	int (*dishnetwork_send_legacy_command)(struct dvb_frontend* fe, unsigned long cmd);
  	int (*i2c_gate_ctrl)(struct dvb_frontend* fe, int enable);
+ 	int (*ts_bus_ctrl)(struct dvb_frontend* fe, int acquire);
+ 
+ 	/* These callbacks are based on the superseding IOCTL's	*/
+ 	int (*set_params)(struct dvb_frontend *fe, struct dvbfe_params *fe_params);
+ 	int (*get_params)(struct dvb_frontend *fe, struct dvbfe_params *fe_params);
+ 	int (*get_info)(struct dvb_frontend *fe, struct dvbfe_info *fe_info);
+ 	int (*get_delsys)(struct dvb_frontend *fe, enum dvbfe_delsys *fe_delsys);
+ 
+ 	/* These callbacks are for devices that implement their own
+ 	 * tuning algorithms, rather than a simple swzigzag
+ 	 */
+ 	enum dvbfe_search (*search)(struct dvb_frontend *fe, struct dvbfe_params *fe_params);
+ 	int (*track)(struct dvb_frontend *fe, struct dvbfe_params *fe_params);
+ 
+ 	struct dvb_tuner_ops tuner_ops;
  };
  
  #define MAX_EVENT 8
***************
*** 100,110 ****
  };
  
  struct dvb_frontend {
! 	struct dvb_frontend_ops* ops;
  	struct dvb_adapter *dvb;
  	void* demodulator_priv;
  	void* frontend_priv;
! 	void* misc_priv;
  };
  
  extern int dvb_register_frontend(struct dvb_adapter* dvb,
--- 282,294 ----
  };
  
  struct dvb_frontend {
! 	struct dvb_frontend_ops ops;
  	struct dvb_adapter *dvb;
  	void* demodulator_priv;
+ 	void* tuner_priv;
  	void* frontend_priv;
! 	void* sec_priv;
! 	u32   legacy;
  };
  
  extern int dvb_register_frontend(struct dvb_adapter* dvb,
***************
*** 112,120 ****
--- 296,320 ----
  
  extern int dvb_unregister_frontend(struct dvb_frontend* fe);
  
+ extern void dvb_frontend_detach(struct dvb_frontend* fe);
+ 
  extern void dvb_frontend_reinitialise(struct dvb_frontend *fe);
  
  extern void dvb_frontend_sleep_until(struct timeval *waketime, u32 add_usec);
  extern s32 timeval_usec_diff(struct timeval lasttime, struct timeval curtime);
  
+ extern void decode_dvbs2_modcod(u32 modcod,
+ 				enum dvbfe_modulation *modulation,
+ 				enum dvbfe_fec *fec);
+ 
+ 
+ extern int newapi_to_olddrv(struct dvbfe_params *params,
+ 			    struct dvb_frontend_parameters *p,
+ 			    enum dvbfe_delsys delsys);
+ 
+ extern int olddrv_to_newapi(struct dvb_frontend *fe,
+ 			    struct dvbfe_params *params,
+ 			    struct dvb_frontend_parameters *p,
+ 			    enum fe_type fe_type);
+ 
  #endif
diff -rcN linux/drivers/media/dvb/dvb-core/dvb_math.c UFS922_Orig/drivers/media/dvb/dvb-core/dvb_math.c
*** linux/drivers/media/dvb/dvb-core/dvb_math.c	1970-01-01 01:00:00.000000000 +0100
--- UFS922_Orig/drivers/media/dvb/dvb-core/dvb_math.c	2009-02-10 19:24:55.000000000 +0100
***************
*** 0 ****
--- 1,145 ----
+ /*
+  * dvb-math provides some complex fixed-point math
+  * operations shared between the dvb related stuff
+  *
+  * Copyright (C) 2006 Christoph Pfister (christophpfister@gmail.com)
+  *
+  * This library is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU Lesser General Public License as
+  * published by the Free Software Foundation; either version 2.1 of
+  * the License, or (at your option) any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+  * GNU Lesser General Public License for more details.
+  *
+  * You should have received a copy of the GNU Lesser General Public
+  * License along with this library; if not, write to the Free Software
+  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+  */
+ 
+ #include <linux/bitops.h>
+ #include <linux/kernel.h>
+ #include <linux/module.h>
+ #include <asm/bug.h>
+ #include "dvb_math.h"
+ 
+ static const unsigned short logtable[256] = {
+ 	0x0000, 0x0171, 0x02e0, 0x044e, 0x05ba, 0x0725, 0x088e, 0x09f7,
+ 	0x0b5d, 0x0cc3, 0x0e27, 0x0f8a, 0x10eb, 0x124b, 0x13aa, 0x1508,
+ 	0x1664, 0x17bf, 0x1919, 0x1a71, 0x1bc8, 0x1d1e, 0x1e73, 0x1fc6,
+ 	0x2119, 0x226a, 0x23ba, 0x2508, 0x2656, 0x27a2, 0x28ed, 0x2a37,
+ 	0x2b80, 0x2cc8, 0x2e0f, 0x2f54, 0x3098, 0x31dc, 0x331e, 0x345f,
+ 	0x359f, 0x36de, 0x381b, 0x3958, 0x3a94, 0x3bce, 0x3d08, 0x3e41,
+ 	0x3f78, 0x40af, 0x41e4, 0x4319, 0x444c, 0x457f, 0x46b0, 0x47e1,
+ 	0x4910, 0x4a3f, 0x4b6c, 0x4c99, 0x4dc5, 0x4eef, 0x5019, 0x5142,
+ 	0x526a, 0x5391, 0x54b7, 0x55dc, 0x5700, 0x5824, 0x5946, 0x5a68,
+ 	0x5b89, 0x5ca8, 0x5dc7, 0x5ee5, 0x6003, 0x611f, 0x623a, 0x6355,
+ 	0x646f, 0x6588, 0x66a0, 0x67b7, 0x68ce, 0x69e4, 0x6af8, 0x6c0c,
+ 	0x6d20, 0x6e32, 0x6f44, 0x7055, 0x7165, 0x7274, 0x7383, 0x7490,
+ 	0x759d, 0x76aa, 0x77b5, 0x78c0, 0x79ca, 0x7ad3, 0x7bdb, 0x7ce3,
+ 	0x7dea, 0x7ef0, 0x7ff6, 0x80fb, 0x81ff, 0x8302, 0x8405, 0x8507,
+ 	0x8608, 0x8709, 0x8809, 0x8908, 0x8a06, 0x8b04, 0x8c01, 0x8cfe,
+ 	0x8dfa, 0x8ef5, 0x8fef, 0x90e9, 0x91e2, 0x92db, 0x93d2, 0x94ca,
+ 	0x95c0, 0x96b6, 0x97ab, 0x98a0, 0x9994, 0x9a87, 0x9b7a, 0x9c6c,
+ 	0x9d5e, 0x9e4f, 0x9f3f, 0xa02e, 0xa11e, 0xa20c, 0xa2fa, 0xa3e7,
+ 	0xa4d4, 0xa5c0, 0xa6ab, 0xa796, 0xa881, 0xa96a, 0xaa53, 0xab3c,
+ 	0xac24, 0xad0c, 0xadf2, 0xaed9, 0xafbe, 0xb0a4, 0xb188, 0xb26c,
+ 	0xb350, 0xb433, 0xb515, 0xb5f7, 0xb6d9, 0xb7ba, 0xb89a, 0xb97a,
+ 	0xba59, 0xbb38, 0xbc16, 0xbcf4, 0xbdd1, 0xbead, 0xbf8a, 0xc065,
+ 	0xc140, 0xc21b, 0xc2f5, 0xc3cf, 0xc4a8, 0xc580, 0xc658, 0xc730,
+ 	0xc807, 0xc8de, 0xc9b4, 0xca8a, 0xcb5f, 0xcc34, 0xcd08, 0xcddc,
+ 	0xceaf, 0xcf82, 0xd054, 0xd126, 0xd1f7, 0xd2c8, 0xd399, 0xd469,
+ 	0xd538, 0xd607, 0xd6d6, 0xd7a4, 0xd872, 0xd93f, 0xda0c, 0xdad9,
+ 	0xdba5, 0xdc70, 0xdd3b, 0xde06, 0xded0, 0xdf9a, 0xe063, 0xe12c,
+ 	0xe1f5, 0xe2bd, 0xe385, 0xe44c, 0xe513, 0xe5d9, 0xe69f, 0xe765,
+ 	0xe82a, 0xe8ef, 0xe9b3, 0xea77, 0xeb3b, 0xebfe, 0xecc1, 0xed83,
+ 	0xee45, 0xef06, 0xefc8, 0xf088, 0xf149, 0xf209, 0xf2c8, 0xf387,
+ 	0xf446, 0xf505, 0xf5c3, 0xf680, 0xf73e, 0xf7fb, 0xf8b7, 0xf973,
+ 	0xfa2f, 0xfaea, 0xfba5, 0xfc60, 0xfd1a, 0xfdd4, 0xfe8e, 0xff47
+ };
+ 
+ unsigned int intlog2(u32 value)
+ {
+ 	/**
+ 	 *	returns: log2(value) * 2^24
+ 	 *	wrong result if value = 0 (log2(0) is undefined)
+ 	 */
+ 	unsigned int msb;
+ 	unsigned int logentry;
+ 	unsigned int significand;
+ 	unsigned int interpolation;
+ 
+ 	if (unlikely(value == 0)) {
+ 		WARN_ON(1);
+ 		return 0;
+ 	}
+ 
+ 	/* first detect the msb (count begins at 0) */
+ 	msb = fls(value) - 1;
+ 
+ 	/**
+ 	 *	now we use a logtable after the following method:
+ 	 *
+ 	 *	log2(2^x * y) * 2^24 = x * 2^24 + log2(y) * 2^24
+ 	 *	where x = msb and therefore 1 <= y < 2
+ 	 *	first y is determined by shifting the value left
+ 	 *	so that msb is bit 31
+ 	 *		0x00231f56 -> 0x8C7D5800
+ 	 *	the result is y * 2^31 -> "significand"
+ 	 *	then the highest 9 bits are used for a table lookup
+ 	 *	the highest bit is discarded because it's always set
+ 	 *	the highest nine bits in our example are 100011000
+ 	 *	so we would use the entry 0x18
+ 	 */
+ 	significand = value << (31 - msb);
+ 	logentry = (significand >> 23) & 0xff;
+ 
+ 	/**
+ 	 *	last step we do is interpolation because of the
+ 	 *	limitations of the log table the error is that part of
+ 	 *	the significand which isn't used for lookup then we
+ 	 *	compute the ratio between the error and the next table entry
+ 	 *	and interpolate it between the log table entry used and the
+ 	 *	next one the biggest error possible is 0x7fffff
+ 	 *	(in our example it's 0x7D5800)
+ 	 *	needed value for next table entry is 0x800000
+ 	 *	so the interpolation is
+ 	 *	(error / 0x800000) * (logtable_next - logtable_current)
+ 	 *	in the implementation the division is moved to the end for
+ 	 *	better accuracy there is also an overflow correction if
+ 	 *	logtable_next is 256
+ 	 */
+ 	interpolation = ((significand & 0x7fffff) *
+ 			((logtable[(logentry + 1) & 0xff] -
+ 			  logtable[logentry]) & 0xffff)) >> 15;
+ 
+ 	/* now we return the result */
+ 	return ((msb << 24) + (logtable[logentry] << 8) + interpolation);
+ }
+ EXPORT_SYMBOL(intlog2);
+ 
+ unsigned int intlog10(u32 value)
+ {
+ 	/**
+ 	 *	returns: log10(value) * 2^24
+ 	 *	wrong result if value = 0 (log10(0) is undefined)
+ 	 */
+ 	u64 log;
+ 
+ 	if (unlikely(value == 0)) {
+ 		WARN_ON(1);
+ 		return 0;
+ 	}
+ 
+ 	log = intlog2(value);
+ 
+ 	/**
+ 	 *	we use the following method:
+ 	 *	log10(x) = log2(x) * log10(2)
+ 	 */
+ 
+ 	return (log * 646456993) >> 31;
+ }
+ EXPORT_SYMBOL(intlog10);
diff -rcN linux/drivers/media/dvb/dvb-core/dvb_math.h UFS922_Orig/drivers/media/dvb/dvb-core/dvb_math.h
*** linux/drivers/media/dvb/dvb-core/dvb_math.h	1970-01-01 01:00:00.000000000 +0100
--- UFS922_Orig/drivers/media/dvb/dvb-core/dvb_math.h	2009-02-10 19:24:55.000000000 +0100
***************
*** 0 ****
--- 1,58 ----
+ /*
+  * dvb-math provides some complex fixed-point math
+  * operations shared between the dvb related stuff
+  *
+  * Copyright (C) 2006 Christoph Pfister (christophpfister@gmail.com)
+  *
+  * This library is free software; you can redistribute it and/or modify
+  * it under the terms of the GNU Lesser General Public License as
+  * published by the Free Software Foundation; either version 2.1 of
+  * the License, or (at your option) any later version.
+  *
+  * This program is distributed in the hope that it will be useful,
+  * but WITHOUT ANY WARRANTY; without even the implied warranty of
+  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+  * GNU Lesser General Public License for more details.
+  *
+  * You should have received a copy of the GNU Lesser General Public
+  * License along with this library; if not, write to the Free Software
+  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+  */
+ 
+ #ifndef __DVB_MATH_H
+ #define __DVB_MATH_H
+ 
+ #include <linux/types.h>
+ 
+ /**
+  * computes log2 of a value; the result is shifted left by 24 bits
+  *
+  * to use rational values you can use the following method:
+  *   intlog2(value) = intlog2(value * 2^x) - x * 2^24
+  *
+  * example: intlog2(8) will give 3 << 24 = 3 * 2^24
+  * example: intlog2(9) will give 3 << 24 + ... = 3.16... * 2^24
+  * example: intlog2(1.5) = intlog2(3) - 2^24 = 0.584... * 2^24
+  *
+  * @param value The value (must be != 0)
+  * @return log2(value) * 2^24
+  */
+ extern unsigned int intlog2(u32 value);
+ 
+ /**
+  * computes log10 of a value; the result is shifted left by 24 bits
+  *
+  * to use rational values you can use the following method:
+  *   intlog10(value) = intlog10(value * 10^x) - x * 2^24
+  *
+  * example: intlog10(1000) will give 3 << 24 = 3 * 2^24
+  *   due to the implementation intlog10(1000) might be not exactly 3 * 2^24
+  *
+  * look at intlog2 for similar examples
+  *
+  * @param value The value (must be != 0)
+  * @return log10(value) * 2^24
+  */
+ extern unsigned int intlog10(u32 value);
+ 
+ #endif
diff -rcN linux/drivers/media/dvb/dvb-core/dvb_net.c UFS922_Orig/drivers/media/dvb/dvb-core/dvb_net.c
*** linux/drivers/media/dvb/dvb-core/dvb_net.c	2009-05-16 19:37:05.000000000 +0200
--- UFS922_Orig/drivers/media/dvb/dvb-core/dvb_net.c	2009-02-10 19:24:55.000000000 +0100
***************
*** 12,18 ****
   *                          Hilmar Linder <hlinder@cosy.sbg.ac.at>
   *                      and Wolfram Stering <wstering@cosy.sbg.ac.at>
   *
!  * ULE Decaps according to draft-ietf-ipdvb-ule-03.txt.
   *
   * This program is free software; you can redistribute it and/or
   * modify it under the terms of the GNU General Public License
--- 12,18 ----
   *                          Hilmar Linder <hlinder@cosy.sbg.ac.at>
   *                      and Wolfram Stering <wstering@cosy.sbg.ac.at>
   *
!  * ULE Decaps according to RFC 4326.
   *
   * This program is free software; you can redistribute it and/or
   * modify it under the terms of the GNU General Public License
***************
*** 42,47 ****
--- 42,50 ----
   *                     Bugfixes and robustness improvements.
   *                     Filtering on dest MAC addresses, if present (D-Bit = 0)
   *                     ULE_DEBUG compile-time option.
+  * Apr 2006: cp v3:    Bugfixes and compliency with RFC 4326 (ULE) by
+  *                       Christian Praehauser <cpraehaus@cosy.sbg.ac.at>,
+  *                       Paris Lodron University of Salzburg.
   */
  
  /*
***************
*** 49,57 ****
   *
   * Unloading does not work for 2.6.9 kernels: a refcount doesn't go to zero.
   *
-  * TS_FEED callback is called once for every single TS cell although it is
-  * registered (in dvb_net_feed_start()) for 100 TS cells (used for dvb_net_ule()).
-  *
   */
  
  #include <linux/module.h>
--- 52,57 ----
***************
*** 62,68 ****
--- 62,71 ----
  #include <linux/uio.h>
  #include <asm/uaccess.h>
  #include <linux/crc32.h>
+ #include "compat.h"
+ #if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,15)
  #include <linux/mutex.h>
+ #endif
  
  #include "dvb_demux.h"
  #include "dvb_net.h"
***************
*** 89,94 ****
--- 92,100 ----
  
  #ifdef ULE_DEBUG
  
+ #define MAC_ADDR_PRINTFMT "%.2x:%.2x:%.2x:%.2x:%.2x:%.2x"
+ #define MAX_ADDR_PRINTFMT_ARGS(macap) (macap)[0],(macap)[1],(macap)[2],(macap)[3],(macap)[4],(macap)[5]
+ 
  #define isprint(c)	((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9'))
  
  static void hexdump( const unsigned char *buf, unsigned short len )
***************
*** 124,129 ****
--- 130,138 ----
  	int in_use;
  	struct net_device_stats stats;
  	u16 pid;
+ #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)
+ 	struct net_device *net;
+ #endif
  	struct dvb_net *host;
  	struct dmx_demux *demux;
  	struct dmx_section_feed *secfeed;
***************
*** 152,158 ****
--- 161,171 ----
  	unsigned char ule_bridged;		/* Whether the ULE_BRIDGED extension header was found. */
  	int ule_sndu_remain;			/* Nr. of bytes still required for current ULE SNDU. */
  	unsigned long ts_count;			/* Current ts cell counter. */
+ #if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,15)
  	struct mutex mutex;
+ #else
+ 	struct semaphore mutex;
+ #endif
  };
  
  
***************
*** 214,219 ****
--- 227,234 ----
  #define ULE_TEST	0
  #define ULE_BRIDGED	1
  
+ #define ULE_OPTEXTHDR_PADDING 0
+ 
  static int ule_test_sndu( struct dvb_net_priv *p )
  {
  	return -1;
***************
*** 221,234 ****
  
  static int ule_bridged_sndu( struct dvb_net_priv *p )
  {
! 	/* BRIDGE SNDU handling sucks in draft-ietf-ipdvb-ule-03.txt.
! 	 * This has to be the last extension header, otherwise it won't work.
! 	 * Blame the authors!
  	 */
  	p->ule_bridged = 1;
  	return 0;
  }
  
  
  /** Handle ULE extension headers.
   *  Function is called after a successful CRC32 verification of an ULE SNDU to complete its decoding.
--- 236,263 ----
  
  static int ule_bridged_sndu( struct dvb_net_priv *p )
  {
! 	struct ethhdr *hdr = (struct ethhdr*) p->ule_next_hdr;
! 	if(ntohs(hdr->h_proto) < 1536) {
! 		int framelen = p->ule_sndu_len - ((p->ule_next_hdr+sizeof(struct ethhdr)) - p->ule_skb->data);
! 		/* A frame Type < 1536 for a bridged frame, introduces a LLC Length field. */
! 		if(framelen != ntohs(hdr->h_proto)) {
! 			return -1;
! 		}
! 	}
! 	/* Note:
! 	 * From RFC4326:
! 	 *  "A bridged SNDU is a Mandatory Extension Header of Type 1.
! 	 *   It must be the final (or only) extension header specified in the header chain of a SNDU."
! 	 * The 'ule_bridged' flag will cause the extension header processing loop to terminate.
  	 */
  	p->ule_bridged = 1;
  	return 0;
  }
  
+ static int ule_exthdr_padding(struct dvb_net_priv *p)
+ {
+ 	return 0;
+ }
  
  /** Handle ULE extension headers.
   *  Function is called after a successful CRC32 verification of an ULE SNDU to complete its decoding.
***************
*** 242,248 ****
  		{ [0] = ule_test_sndu, [1] = ule_bridged_sndu, [2] = NULL,  };
  
  	/* Table of optional extension header handlers.  The header type is the index. */
! 	static int (*ule_optional_ext_handlers[255])( struct dvb_net_priv *p ) = { NULL, };
  
  	int ext_len = 0;
  	unsigned char hlen = (p->ule_sndu_type & 0x0700) >> 8;
--- 271,278 ----
  		{ [0] = ule_test_sndu, [1] = ule_bridged_sndu, [2] = NULL,  };
  
  	/* Table of optional extension header handlers.  The header type is the index. */
! 	static int (*ule_optional_ext_handlers[255])( struct dvb_net_priv *p ) =
! 		{ [0] = ule_exthdr_padding, [1] = NULL, };
  
  	int ext_len = 0;
  	unsigned char hlen = (p->ule_sndu_type & 0x0700) >> 8;
***************
*** 253,277 ****
  		/* Mandatory extension header */
  		if (ule_mandatory_ext_handlers[htype]) {
  			ext_len = ule_mandatory_ext_handlers[htype]( p );
! 			p->ule_next_hdr += ext_len;
! 			if (! p->ule_bridged) {
! 				p->ule_sndu_type = ntohs( *(unsigned short *)p->ule_next_hdr );
! 				p->ule_next_hdr += 2;
! 			} else {
! 				p->ule_sndu_type = ntohs( *(unsigned short *)(p->ule_next_hdr + ((p->ule_dbit ? 2 : 3) * ETH_ALEN)) );
! 				/* This assures the extension handling loop will terminate. */
  			}
  		} else
  			ext_len = -1;	/* SNDU has to be discarded. */
  	} else {
  		/* Optional extension header.  Calculate the length. */
! 		ext_len = hlen << 2;
  		/* Process the optional extension header according to its type. */
  		if (ule_optional_ext_handlers[htype])
  			(void)ule_optional_ext_handlers[htype]( p );
  		p->ule_next_hdr += ext_len;
! 		p->ule_sndu_type = ntohs( *(unsigned short *)p->ule_next_hdr );
! 		p->ule_next_hdr += 2;
  	}
  
  	return ext_len;
--- 283,313 ----
  		/* Mandatory extension header */
  		if (ule_mandatory_ext_handlers[htype]) {
  			ext_len = ule_mandatory_ext_handlers[htype]( p );
! 			if(ext_len >= 0) {
! 				p->ule_next_hdr += ext_len;
! 				if (!p->ule_bridged) {
! 					p->ule_sndu_type = ntohs(*(unsigned short *)p->ule_next_hdr);
! 					p->ule_next_hdr += 2;
! 				} else {
! 					p->ule_sndu_type = ntohs(*(unsigned short *)(p->ule_next_hdr + ((p->ule_dbit ? 2 : 3) * ETH_ALEN)));
! 					/* This assures the extension handling loop will terminate. */
! 				}
  			}
+ 			// else: extension handler failed or SNDU should be discarded
  		} else
  			ext_len = -1;	/* SNDU has to be discarded. */
  	} else {
  		/* Optional extension header.  Calculate the length. */
! 		ext_len = hlen << 1;
  		/* Process the optional extension header according to its type. */
  		if (ule_optional_ext_handlers[htype])
  			(void)ule_optional_ext_handlers[htype]( p );
  		p->ule_next_hdr += ext_len;
! 		p->ule_sndu_type = ntohs( *(unsigned short *)(p->ule_next_hdr-2) );
! 		/*
! 		 * note: the length of the next header type is included in the
! 		 * length of THIS optional extension header
! 		 */
  	}
  
  	return ext_len;
***************
*** 284,291 ****
  	p->ule_next_hdr = p->ule_skb->data;
  	do {
  		l = handle_one_ule_extension( p );
! 		if (l == -1) return -1;	/* Stop extension header processing and discard SNDU. */
  		total_ext_len += l;
  
  	} while (p->ule_sndu_type < 1536);
  
--- 320,333 ----
  	p->ule_next_hdr = p->ule_skb->data;
  	do {
  		l = handle_one_ule_extension( p );
! 		if (l < 0)
! 			return l;	/* Stop extension header processing and discard SNDU. */
  		total_ext_len += l;
+ #ifdef ULE_DEBUG
+ 		dprintk("handle_ule_extensions: ule_next_hdr=%p, ule_sndu_type=%i, "
+ 			"l=%i, total_ext_len=%i\n", p->ule_next_hdr,
+ 			(int) p->ule_sndu_type, l, total_ext_len);
+ #endif
  
  	} while (p->ule_sndu_type < 1536);
  
***************
*** 355,362 ****
  				if (priv->ule_skb) {
  					dev_kfree_skb( priv->ule_skb );
  					/* Prepare for next SNDU. */
! 					((struct dvb_net_priv *) dev->priv)->stats.rx_errors++;
! 					((struct dvb_net_priv *) dev->priv)->stats.rx_frame_errors++;
  				}
  				reset_ule(priv);
  				priv->need_pusi = 1;
--- 397,404 ----
  				if (priv->ule_skb) {
  					dev_kfree_skb( priv->ule_skb );
  					/* Prepare for next SNDU. */
! 					priv->stats.rx_errors++;
! 					priv->stats.rx_frame_errors++;
  				}
  				reset_ule(priv);
  				priv->need_pusi = 1;
***************
*** 396,422 ****
  			}
  		}
  
- 		/* Check continuity counter. */
  		if (new_ts) {
  			if ((ts[3] & 0x0F) == priv->tscc)
  				priv->tscc = (priv->tscc + 1) & 0x0F;
  			else {
  				/* TS discontinuity handling: */
  				printk(KERN_WARNING "%lu: TS discontinuity: got %#x, "
! 				       "exptected %#x.\n", priv->ts_count, ts[3] & 0x0F, priv->tscc);
  				/* Drop partly decoded SNDU, reset state, resync on PUSI. */
  				if (priv->ule_skb) {
  					dev_kfree_skb( priv->ule_skb );
  					/* Prepare for next SNDU. */
  					// reset_ule(priv);  moved to below.
! 					((struct dvb_net_priv *) dev->priv)->stats.rx_errors++;
! 					((struct dvb_net_priv *) dev->priv)->stats.rx_frame_errors++;
  				}
  				reset_ule(priv);
  				/* skip to next PUSI. */
  				priv->need_pusi = 1;
- 				ts += TS_SZ;
- 				priv->ts_count++;
  				continue;
  			}
  			/* If we still have an incomplete payload, but PUSI is
--- 438,462 ----
  			}
  		}
  
  		if (new_ts) {
+ 			/* Check continuity counter. */
  			if ((ts[3] & 0x0F) == priv->tscc)
  				priv->tscc = (priv->tscc + 1) & 0x0F;
  			else {
  				/* TS discontinuity handling: */
  				printk(KERN_WARNING "%lu: TS discontinuity: got %#x, "
! 				       "expected %#x.\n", priv->ts_count, ts[3] & 0x0F, priv->tscc);
  				/* Drop partly decoded SNDU, reset state, resync on PUSI. */
  				if (priv->ule_skb) {
  					dev_kfree_skb( priv->ule_skb );
  					/* Prepare for next SNDU. */
  					// reset_ule(priv);  moved to below.
! 					priv->stats.rx_errors++;
! 					priv->stats.rx_frame_errors++;
  				}
  				reset_ule(priv);
  				/* skip to next PUSI. */
  				priv->need_pusi = 1;
  				continue;
  			}
  			/* If we still have an incomplete payload, but PUSI is
***************
*** 425,431 ****
  			 * cells (continuity counter wrap). */
  			if (ts[1] & TS_PUSI) {
  				if (! priv->need_pusi) {
! 					if (*from_where > 181) {
  						/* Pointer field is invalid.  Drop this TS cell and any started ULE SNDU. */
  						printk(KERN_WARNING "%lu: Invalid pointer "
  						       "field: %u.\n", priv->ts_count, *from_where);
--- 465,471 ----
  			 * cells (continuity counter wrap). */
  			if (ts[1] & TS_PUSI) {
  				if (! priv->need_pusi) {
! 					if (!(*from_where < (ts_remain-1)) || *from_where != priv->ule_sndu_remain) {
  						/* Pointer field is invalid.  Drop this TS cell and any started ULE SNDU. */
  						printk(KERN_WARNING "%lu: Invalid pointer "
  						       "field: %u.\n", priv->ts_count, *from_where);
***************
*** 438,445 ****
  						}
  						reset_ule(priv);
  						priv->need_pusi = 1;
- 						ts += TS_SZ;
- 						priv->ts_count++;
  						continue;
  					}
  					/* Skip pointer field (we're processing a
--- 478,483 ----
***************
*** 452,459 ****
  				if (priv->ule_sndu_remain > 183) {
  					/* Current SNDU lacks more data than there could be available in the
  					 * current TS cell. */
! 					((struct dvb_net_priv *) dev->priv)->stats.rx_errors++;
! 					((struct dvb_net_priv *) dev->priv)->stats.rx_length_errors++;
  					printk(KERN_WARNING "%lu: Expected %d more SNDU bytes, but "
  					       "got PUSI (pf %d, ts_remain %d).  Flushing incomplete payload.\n",
  					       priv->ts_count, priv->ule_sndu_remain, ts[4], ts_remain);
--- 490,497 ----
  				if (priv->ule_sndu_remain > 183) {
  					/* Current SNDU lacks more data than there could be available in the
  					 * current TS cell. */
! 					priv->stats.rx_errors++;
! 					priv->stats.rx_length_errors++;
  					printk(KERN_WARNING "%lu: Expected %d more SNDU bytes, but "
  					       "got PUSI (pf %d, ts_remain %d).  Flushing incomplete payload.\n",
  					       priv->ts_count, priv->ule_sndu_remain, ts[4], ts_remain);
***************
*** 492,501 ****
  				} else
  					priv->ule_dbit = 0;
  
! 				if (priv->ule_sndu_len > 32763 ||
! 				    priv->ule_sndu_len < ((priv->ule_dbit) ? 4 : 4 + ETH_ALEN)) {
  					printk(KERN_WARNING "%lu: Invalid ULE SNDU length %u. "
  					       "Resyncing.\n", priv->ts_count, priv->ule_sndu_len);
  					priv->ule_sndu_len = 0;
  					priv->need_pusi = 1;
  					new_ts = 1;
--- 530,540 ----
  				} else
  					priv->ule_dbit = 0;
  
! 				if (priv->ule_sndu_len < 5) {
  					printk(KERN_WARNING "%lu: Invalid ULE SNDU length %u. "
  					       "Resyncing.\n", priv->ts_count, priv->ule_sndu_len);
+ 					priv->stats.rx_errors++;
+ 					priv->stats.rx_length_errors++;
  					priv->ule_sndu_len = 0;
  					priv->need_pusi = 1;
  					new_ts = 1;
***************
*** 575,581 ****
  				{ &utype, sizeof utype },
  				{ priv->ule_skb->data, priv->ule_skb->len - 4 }
  			};
! 			unsigned long ule_crc = ~0L, expected_crc;
  			if (priv->ule_dbit) {
  				/* Set D-bit for CRC32 verification,
  				 * if it was set originally. */
--- 614,620 ----
  				{ &utype, sizeof utype },
  				{ priv->ule_skb->data, priv->ule_skb->len - 4 }
  			};
! 			u32 ule_crc = ~0L, expected_crc;
  			if (priv->ule_dbit) {
  				/* Set D-bit for CRC32 verification,
  				 * if it was set originally. */
***************
*** 588,594 ****
  				       *((u8 *)priv->ule_skb->tail - 2) << 8 |
  				       *((u8 *)priv->ule_skb->tail - 1);
  			if (ule_crc != expected_crc) {
! 				printk(KERN_WARNING "%lu: CRC32 check FAILED: %#lx / %#lx, SNDU len %d type %#x, ts_remain %d, next 2: %x.\n",
  				       priv->ts_count, ule_crc, expected_crc, priv->ule_sndu_len, priv->ule_sndu_type, ts_remain, ts_remain > 2 ? *(unsigned short *)from_where : 0);
  
  #ifdef ULE_DEBUG
--- 627,633 ----
  				       *((u8 *)priv->ule_skb->tail - 2) << 8 |
  				       *((u8 *)priv->ule_skb->tail - 1);
  			if (ule_crc != expected_crc) {
! 				printk(KERN_WARNING "%lu: CRC32 check FAILED: %08x / %08x, SNDU len %d type %#x, ts_remain %d, next 2: %x.\n",
  				       priv->ts_count, ule_crc, expected_crc, priv->ule_sndu_len, priv->ule_sndu_type, ts_remain, ts_remain > 2 ? *(unsigned short *)from_where : 0);
  
  #ifdef ULE_DEBUG
***************
*** 609,666 ****
  				ule_dump = 1;
  #endif
  
! 				((struct dvb_net_priv *) dev->priv)->stats.rx_errors++;
! 				((struct dvb_net_priv *) dev->priv)->stats.rx_crc_errors++;
  				dev_kfree_skb(priv->ule_skb);
  			} else {
  				/* CRC32 verified OK. */
  				/* Handle ULE Extension Headers. */
  				if (priv->ule_sndu_type < 1536) {
  					/* There is an extension header.  Handle it accordingly. */
! 					int l = handle_ule_extensions( priv );
  					if (l < 0) {
  						/* Mandatory extension header unknown or TEST SNDU.  Drop it. */
  						// printk( KERN_WARNING "Dropping SNDU, extension headers.\n" );
! 						dev_kfree_skb( priv->ule_skb );
  						goto sndu_done;
  					}
! 					skb_pull( priv->ule_skb, l );
  				}
  
! 				/* CRC32 was OK. Remove it from skb. */
! 				priv->ule_skb->tail -= 4;
! 				priv->ule_skb->len -= 4;
! 
! 				/* Filter on receiver's destination MAC address, if present. */
! 				if (!priv->ule_dbit) {
! 					/* The destination MAC address is the next data in the skb. */
! 					if (memcmp( priv->ule_skb->data, dev->dev_addr, ETH_ALEN )) {
! 						/* MAC addresses don't match.  Drop SNDU. */
! 						// printk( KERN_WARNING "Dropping SNDU, MAC address.\n" );
! 						dev_kfree_skb( priv->ule_skb );
! 						goto sndu_done;
! 					}
! 					if (! priv->ule_bridged) {
! 						skb_push( priv->ule_skb, ETH_ALEN + 2 );
! 						ethh = (struct ethhdr *)priv->ule_skb->data;
! 						memcpy( ethh->h_dest, ethh->h_source, ETH_ALEN );
! 						memset( ethh->h_source, 0, ETH_ALEN );
! 						ethh->h_proto = htons( priv->ule_sndu_type );
! 					} else {
! 						/* Skip the Receiver destination MAC address. */
! 						skb_pull( priv->ule_skb, ETH_ALEN );
! 					}
! 				} else {
! 					if (! priv->ule_bridged) {
! 						skb_push( priv->ule_skb, ETH_HLEN );
! 						ethh = (struct ethhdr *)priv->ule_skb->data;
! 						memcpy( ethh->h_dest, dev->dev_addr, ETH_ALEN );
! 						memset( ethh->h_source, 0, ETH_ALEN );
! 						ethh->h_proto = htons( priv->ule_sndu_type );
! 					} else {
! 						/* skb is in correct state; nothing to do. */
  					}
  				}
  				priv->ule_bridged = 0;
  
  				/* Stuff into kernel's protocol stack. */
--- 648,750 ----
  				ule_dump = 1;
  #endif
  
! 				priv->stats.rx_errors++;
! 				priv->stats.rx_crc_errors++;
  				dev_kfree_skb(priv->ule_skb);
  			} else {
  				/* CRC32 verified OK. */
+ 				u8 dest_addr[ETH_ALEN];
+ 				static const u8 bc_addr[ETH_ALEN] =
+ 					{ [ 0 ... ETH_ALEN-1] = 0xff };
+ 
+ 				/* CRC32 was OK. Remove it from skb. */
+ 				priv->ule_skb->tail -= 4;
+ 				priv->ule_skb->len -= 4;
+ 
+ 				if (!priv->ule_dbit) {
+ 					/*
+ 					 * The destination MAC address is the
+ 					 * next data in the skb.  It comes
+ 					 * before any extension headers.
+ 					 *
+ 					 * Check if the payload of this SNDU
+ 					 * should be passed up the stack.
+ 					 */
+ 					register int drop = 0;
+ 					if (priv->rx_mode != RX_MODE_PROMISC) {
+ 						if (priv->ule_skb->data[0] & 0x01) {
+ 							/* multicast or broadcast */
+ 							if (memcmp(priv->ule_skb->data, bc_addr, ETH_ALEN)) {
+ 								/* multicast */
+ 								if (priv->rx_mode == RX_MODE_MULTI) {
+ 									int i;
+ 									for(i = 0; i < priv->multi_num && memcmp(priv->ule_skb->data, priv->multi_macs[i], ETH_ALEN); i++)
+ 										;
+ 									if (i == priv->multi_num)
+ 										drop = 1;
+ 								} else if (priv->rx_mode != RX_MODE_ALL_MULTI)
+ 									drop = 1; /* no broadcast; */
+ 								/* else: all multicast mode: accept all multicast packets */
+ 							}
+ 							/* else: broadcast */
+ 						}
+ 						else if (memcmp(priv->ule_skb->data, dev->dev_addr, ETH_ALEN))
+ 							drop = 1;
+ 						/* else: destination address matches the MAC address of our receiver device */
+ 					}
+ 					/* else: promiscious mode; pass everything up the stack */
+ 
+ 					if (drop) {
+ #ifdef ULE_DEBUG
+ 						dprintk("Dropping SNDU: MAC destination address does not match: dest addr: "MAC_ADDR_PRINTFMT", dev addr: "MAC_ADDR_PRINTFMT"\n",
+ 							MAX_ADDR_PRINTFMT_ARGS(priv->ule_skb->data), MAX_ADDR_PRINTFMT_ARGS(dev->dev_addr));
+ #endif
+ 						dev_kfree_skb(priv->ule_skb);
+ 						goto sndu_done;
+ 					}
+ 					else
+ 					{
+ 						memcpy(dest_addr,  priv->ule_skb->data, ETH_ALEN);
+ 						skb_pull(priv->ule_skb, ETH_ALEN);
+ 					}
+ 				}
+ 
  				/* Handle ULE Extension Headers. */
  				if (priv->ule_sndu_type < 1536) {
  					/* There is an extension header.  Handle it accordingly. */
! 					int l = handle_ule_extensions(priv);
  					if (l < 0) {
  						/* Mandatory extension header unknown or TEST SNDU.  Drop it. */
  						// printk( KERN_WARNING "Dropping SNDU, extension headers.\n" );
! 						dev_kfree_skb(priv->ule_skb);
  						goto sndu_done;
  					}
! 					skb_pull(priv->ule_skb, l);
  				}
  
! 				/*
! 				 * Construct/assure correct ethernet header.
! 				 * Note: in bridged mode (priv->ule_bridged !=
! 				 * 0) we already have the (original) ethernet
! 				 * header at the start of the payload (after
! 				 * optional dest. address and any extension
! 				 * headers).
! 				 */
! 
! 				if (!priv->ule_bridged) {
! 					skb_push(priv->ule_skb, ETH_HLEN);
! 					ethh = (struct ethhdr *)priv->ule_skb->data;
! 					if (!priv->ule_dbit) {
! 						 /* dest_addr buffer is only valid if priv->ule_dbit == 0 */
! 						memcpy(ethh->h_dest, dest_addr, ETH_ALEN);
! 						memset(ethh->h_source, 0, ETH_ALEN);
  					}
+ 					else /* zeroize source and dest */
+ 						memset( ethh, 0, ETH_ALEN*2 );
+ 
+ 					ethh->h_proto = htons(priv->ule_sndu_type);
  				}
+ 				/* else:  skb is in correct state; nothing to do. */
  				priv->ule_bridged = 0;
  
  				/* Stuff into kernel's protocol stack. */
***************
*** 669,676 ****
  				 * receive the packet anyhow. */
  				/* if (priv->ule_dbit && skb->pkt_type == PACKET_OTHERHOST)
  					priv->ule_skb->pkt_type = PACKET_HOST; */
! 				((struct dvb_net_priv *) dev->priv)->stats.rx_packets++;
! 				((struct dvb_net_priv *) dev->priv)->stats.rx_bytes += priv->ule_skb->len;
  				netif_rx(priv->ule_skb);
  			}
  			sndu_done:
--- 753,760 ----
  				 * receive the packet anyhow. */
  				/* if (priv->ule_dbit && skb->pkt_type == PACKET_OTHERHOST)
  					priv->ule_skb->pkt_type = PACKET_HOST; */
! 				priv->stats.rx_packets++;
! 				priv->stats.rx_bytes += priv->ule_skb->len;
  				netif_rx(priv->ule_skb);
  			}
  			sndu_done:
***************
*** 737,743 ****
  	}
  /* it seems some ISPs manage to screw up here, so we have to
   * relax the error checks... */
! #if 0
  	if ((pkt[5] & 0xfd) != 0xc1) {
  		/* drop scrambled or broken packets */
  #else
--- 821,827 ----
  	}
  /* it seems some ISPs manage to screw up here, so we have to
   * relax the error checks... */
! #if 0 /* keep */
  	if ((pkt[5] & 0xfd) != 0xc1) {
  		/* drop scrambled or broken packets */
  #else
***************
*** 945,951 ****
  		dprintk("%s: start filtering\n", __FUNCTION__);
  		priv->secfeed->start_filtering(priv->secfeed);
  	} else if (priv->feedtype == DVB_NET_FEEDTYPE_ULE) {
! 		struct timespec timeout = { 0, 30000000 }; // 30 msec
  
  		/* we have payloads encapsulated in TS */
  		dprintk("%s: alloc tsfeed\n", __FUNCTION__);
--- 1029,1035 ----
  		dprintk("%s: start filtering\n", __FUNCTION__);
  		priv->secfeed->start_filtering(priv->secfeed);
  	} else if (priv->feedtype == DVB_NET_FEEDTYPE_ULE) {
! 		struct timespec timeout = { 0, 10000000 }; // 10 msec
  
  		/* we have payloads encapsulated in TS */
  		dprintk("%s: alloc tsfeed\n", __FUNCTION__);
***************
*** 957,966 ****
  
  		/* Set netdevice pointer for ts decaps callback. */
  		priv->tsfeed->priv = (void *)dev;
! 		ret = priv->tsfeed->set(priv->tsfeed, priv->pid,
! 					TS_PACKET, DMX_TS_PES_OTHER,
  					32768,     /* circular buffer size */
! 					timeout);
  
  		if (ret < 0) {
  			printk("%s: could not set ts feed\n", dev->name);
--- 1041,1053 ----
  
  		/* Set netdevice pointer for ts decaps callback. */
  		priv->tsfeed->priv = (void *)dev;
! 		ret = priv->tsfeed->set(priv->tsfeed,
! 					priv->pid, /* pid */
! 					TS_PACKET, /* type */
! 					DMX_TS_PES_OTHER, /* pes type */
  					32768,     /* circular buffer size */
! 					timeout    /* timeout */
! 					);
  
  		if (ret < 0) {
  			printk("%s: could not set ts feed\n", dev->name);
***************
*** 1046,1059 ****
--- 1133,1160 ----
  }
  
  
+ #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
  static void wq_set_multicast_list (void *data)
+ #else
+ static void wq_set_multicast_list (struct work_struct *work)
+ #endif
  {
+ #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
  	struct net_device *dev = data;
  	struct dvb_net_priv *priv = dev->priv;
+ #else
+ 	struct dvb_net_priv *priv =
+ 		container_of(work, struct dvb_net_priv, set_multicast_list_wq);
+ 	struct net_device *dev = priv->net;
+ #endif
  
  	dvb_net_feed_stop(dev);
  	priv->rx_mode = RX_MODE_UNI;
+ #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)
  	spin_lock_bh(&dev->xmit_lock);
+ #else
+ 	netif_tx_lock_bh(dev);
+ #endif
  
  	if (dev->flags & IFF_PROMISC) {
  		dprintk("%s: promiscuous mode\n", dev->name);
***************
*** 1078,1084 ****
--- 1179,1189 ----
  		}
  	}
  
+ #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,18)
  	spin_unlock_bh(&dev->xmit_lock);
+ #else
+ 	netif_tx_unlock_bh(dev);
+ #endif
  	dvb_net_feed_start(dev);
  }
  
***************
*** 1090,1098 ****
--- 1195,1213 ----
  }
  
  
+ #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
  static void wq_restart_net_feed (void *data)
+ #else
+ static void wq_restart_net_feed (struct work_struct *work)
+ #endif
  {
+ #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
  	struct net_device *dev = data;
+ #else
+ 	struct dvb_net_priv *priv =
+ 		container_of(work, struct dvb_net_priv, restart_net_feed_wq);
+ 	struct net_device *dev = priv->net;
+ #endif
  
  	if (netif_running(dev)) {
  		dvb_net_feed_stop(dev);
***************
*** 1199,1204 ****
--- 1314,1322 ----
  	dvbnet->device[if_num] = net;
  
  	priv = net->priv;
+ #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,20)
+ 	priv->net = net;
+ #endif
  	priv->demux = dvbnet->demux;
  	priv->pid = pid;
  	priv->rx_mode = RX_MODE_UNI;
***************
*** 1207,1214 ****
--- 1325,1337 ----
  	priv->feedtype = feedtype;
  	reset_ule(priv);
  
+ #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,20)
  	INIT_WORK(&priv->set_multicast_list_wq, wq_set_multicast_list, net);
  	INIT_WORK(&priv->restart_net_feed_wq, wq_restart_net_feed, net);
+ #else
+ 	INIT_WORK(&priv->set_multicast_list_wq, wq_set_multicast_list);
+ 	INIT_WORK(&priv->restart_net_feed_wq, wq_restart_net_feed);
+ #endif
  	mutex_init(&priv->mutex);
  
  	net->base_addr = pid;
diff -rcN linux/drivers/media/dvb/dvb-core/dvb_ringbuffer.c UFS922_Orig/drivers/media/dvb/dvb-core/dvb_ringbuffer.c
*** linux/drivers/media/dvb/dvb-core/dvb_ringbuffer.c	2006-06-18 03:49:35.000000000 +0200
--- UFS922_Orig/drivers/media/dvb/dvb-core/dvb_ringbuffer.c	2009-02-10 19:24:55.000000000 +0100
***************
*** 26,32 ****
  
  
  
- #define __KERNEL_SYSCALLS__
  #include <linux/errno.h>
  #include <linux/kernel.h>
  #include <linux/module.h>
--- 26,31 ----
diff -rcN linux/drivers/media/dvb/dvb-core/Kconfig UFS922_Orig/drivers/media/dvb/dvb-core/Kconfig
*** linux/drivers/media/dvb/dvb-core/Kconfig	2006-06-18 03:49:35.000000000 +0200
--- UFS922_Orig/drivers/media/dvb/dvb-core/Kconfig	2009-02-10 19:24:55.000000000 +0100
***************
*** 9,11 ****
--- 9,24 ----
  	  in-kernel drivers will select this automatically if needed.
  	  If unsure say N.
  
+ config DVB_CORE_ATTACH
+ 	bool "Load and attach frontend modules as needed"
+ 	depends on DVB_CORE
+ 	depends on MODULES
+ 	help
+ 	  Remove the static dependency of DVB card drivers on all
+ 	  frontend modules for all possible card variants. Instead,
+ 	  allow the card drivers to only load the frontend modules
+ 	  they require. This saves several KBytes of memory.
+ 
+ 	  Note: You will need module-init-tools v3.2 or later for this feature.
+ 
+ 	  If unsure say Y.
diff -rcN linux/drivers/media/dvb/dvb-core//Makefile UFS922_Orig/drivers/media/dvb/dvb-core/Makefile
*** linux/drivers/media/dvb/dvb-core/Makefile	2006-06-18 03:49:35.000000000 +0200
--- UFS922_Orig/drivers/media/dvb/dvb-core/Makefile	2009-02-10 19:24:55.000000000 +0100
***************
*** 2,9 ****
  # Makefile for the kernel DVB device drivers.
  #
  
! dvb-core-objs = dvbdev.o dmxdev.o dvb_demux.o dvb_filter.o \
! 		dvb_ca_en50221.o dvb_frontend.o \
! 		dvb_net.o dvb_ringbuffer.o
  
  obj-$(CONFIG_DVB_CORE) += dvb-core.o
--- 2,9 ----
  # Makefile for the kernel DVB device drivers.
  #
  
! dvb-core-objs := dvbdev.o dmxdev.o dvb_demux.o dvb_filter.o 	\
! 		 dvb_ca_en50221.o dvb_frontend.o 		\
! 		 dvb_net.o dvb_ringbuffer.o dvb_math.o
  
  obj-$(CONFIG_DVB_CORE) += dvb-core.o
diff -rcN linux/include/linux/dvb/audio.h UFS922_Orig/include/linux/dvb/audio.h
*** linux/include/linux/dvb/audio.h	2006-06-18 03:49:35.000000000 +0200
--- UFS922_Orig/include/linux/dvb/audio.h	2009-02-10 19:25:30.000000000 +0100
***************
*** 47,53 ****
  typedef enum {
  	AUDIO_STEREO,
  	AUDIO_MONO_LEFT,
! 	AUDIO_MONO_RIGHT
  } audio_channel_select_t;
  
  
--- 47,55 ----
  typedef enum {
  	AUDIO_STEREO,
  	AUDIO_MONO_LEFT,
! 	AUDIO_MONO_RIGHT,
! 	AUDIO_MONO,
! 	AUDIO_STEREO_SWAPPED
  } audio_channel_select_t;
  
  
***************
*** 133,137 ****
--- 135,140 ----
   * extracted by the PES parser.
   */
  #define AUDIO_GET_PTS              _IOR('o', 19, __u64)
+ #define AUDIO_BILINGUAL_CHANNEL_SELECT _IO('o', 20)
  
  #endif /* _DVBAUDIO_H_ */
diff -rcN linux/include/linux/dvb/ca.h UFS922_Orig/include/linux/dvb/ca.h
*** linux/include/linux/dvb/ca.h	2006-06-18 03:49:35.000000000 +0200
--- UFS922_Orig/include/linux/dvb/ca.h	2009-02-21 12:23:07.000000000 +0100
***************
*** 39,44 ****
--- 39,46 ----
  	unsigned int flags;
  #define CA_CI_MODULE_PRESENT 1 /* module (or card) inserted */
  #define CA_CI_MODULE_READY   2
+ /* Dagobert: I'd like to have this information also in user land */
+ #define CA_CI_MODULE_INVALID 3
  } ca_slot_info_t;
  
  
diff -rcN linux/include/linux/dvb/dmx.h UFS922_Orig/include/linux/dvb/dmx.h
*** linux/include/linux/dvb/dmx.h	2006-06-18 03:49:35.000000000 +0200
--- UFS922_Orig/include/linux/dvb/dmx.h	2009-02-10 19:25:30.000000000 +0100
***************
*** 88,107 ****
  #define DMX_PES_PCR      DMX_PES_PCR0
  
  
- typedef enum
- {
- 	DMX_SCRAMBLING_EV,
- 	DMX_FRONTEND_EV
- } dmx_event_t;
- 
- 
- typedef enum
- {
- 	DMX_SCRAMBLING_OFF,
- 	DMX_SCRAMBLING_ON
- } dmx_scrambling_status_t;
- 
- 
  typedef struct dmx_filter
  {
  	__u8  filter[DMX_FILTER_SIZE];
--- 88,93 ----
***************
*** 132,148 ****
  	__u32          flags;
  };
  
- 
- struct dmx_event
- {
- 	dmx_event_t         event;
- 	time_t              timeStamp;
- 	union
- 	{
- 		dmx_scrambling_status_t scrambling;
- 	} u;
- };
- 
  typedef struct dmx_caps {
  	__u32 caps;
  	int num_decoders;
--- 118,123 ----
***************
*** 171,177 ****
  #define DMX_SET_FILTER           _IOW('o', 43, struct dmx_sct_filter_params)
  #define DMX_SET_PES_FILTER       _IOW('o', 44, struct dmx_pes_filter_params)
  #define DMX_SET_BUFFER_SIZE      _IO('o', 45)
- #define DMX_GET_EVENT            _IOR('o', 46, struct dmx_event)
  #define DMX_GET_PES_PIDS         _IOR('o', 47, __u16[5])
  #define DMX_GET_CAPS             _IOR('o', 48, dmx_caps_t)
  #define DMX_SET_SOURCE           _IOW('o', 49, dmx_source_t)
--- 146,151 ----
diff -rcN linux/include/linux/dvb/frontend.h UFS922_Orig/include/linux/dvb/frontend.h
*** linux/include/linux/dvb/frontend.h	2006-06-18 03:49:35.000000000 +0200
--- UFS922_Orig/include/linux/dvb/frontend.h	2009-02-10 19:25:30.000000000 +0100
***************
*** 7,12 ****
--- 7,14 ----
   *		    Andre Draszik <ad@convergence.de>
   *		    for convergence integrated media GmbH
   *
+  * Copyright (C) 2006, 2007 Manu Abraham <abraham.manu@gmail.com>
+  *
   * This program is free software; you can redistribute it and/or
   * modify it under the terms of the GNU Lesser General Public License
   * as published by the Free Software Foundation; either version 2.1
***************
*** 33,41 ****
  	FE_QPSK,
  	FE_QAM,
  	FE_OFDM,
! 	FE_ATSC
  } fe_type_t;
! 
  
  typedef enum fe_caps {
  	FE_IS_STUPID			= 0,
--- 35,49 ----
  	FE_QPSK,
  	FE_QAM,
  	FE_OFDM,
! 	FE_ATSC,
! 	FE_DVBS2	// S2, QPSK+8PSK
  } fe_type_t;
! typedef enum fe_rolloff {
! 	FE_ROLLOFF_35    = 0,
!         FE_ROLLOFF_25    = 1,
!         FE_ROLLOFF_20    = 2,
!         FE_ROLLOFF_UNKNOWN =3
! } fe_rollof_t;
  
  typedef enum fe_caps {
  	FE_IS_STUPID			= 0,
***************
*** 147,153 ****
  	FEC_6_7,
  	FEC_7_8,
  	FEC_8_9,
! 	FEC_AUTO
  } fe_code_rate_t;
  
  
--- 155,166 ----
  	FEC_6_7,
  	FEC_7_8,
  	FEC_8_9,
!         FEC_AUTO,
!         FEC_1_4,   // S2
!         FEC_1_3,   // S2
!         FEC_2_5,   // S2
!         FEC_3_5,   // S2
!         FEC_9_10   // S2
  } fe_code_rate_t;
  
  
***************
*** 160,166 ****
  	QAM_256,
  	QAM_AUTO,
  	VSB_8,
! 	VSB_16
  } fe_modulation_t;
  
  typedef enum fe_transmit_mode {
--- 173,181 ----
  	QAM_256,
  	QAM_AUTO,
  	VSB_8,
! 	VSB_16,
! 	QPSK_S2,  // S2
! 	PSK8    // S2
  } fe_modulation_t;
  
  typedef enum fe_transmit_mode {
***************
*** 234,245 ****
  };
  
  
- struct dvb_frontend_event {
- 	fe_status_t status;
- 	struct dvb_frontend_parameters parameters;
- };
- 
- 
  /**
   * When set, this flag will disable any zigzagging or other "normal" tuning
   * behaviour. Additionally, there will be no automatic monitoring of the lock
--- 249,254 ----
***************
*** 270,277 ****
  #define FE_SET_FRONTEND		   _IOW('o', 76, struct dvb_frontend_parameters)
  #define FE_GET_FRONTEND		   _IOR('o', 77, struct dvb_frontend_parameters)
  #define FE_SET_FRONTEND_TUNE_MODE  _IO('o', 81) /* unsigned int */
- #define FE_GET_EVENT		   _IOR('o', 78, struct dvb_frontend_event)
  
  #define FE_DISHNETWORK_SEND_LEGACY_CMD _IO('o', 80) /* unsigned int */
  
  #endif /*_DVBFRONTEND_H_*/
--- 279,712 ----
  #define FE_SET_FRONTEND		   _IOW('o', 76, struct dvb_frontend_parameters)
  #define FE_GET_FRONTEND		   _IOR('o', 77, struct dvb_frontend_parameters)
  #define FE_SET_FRONTEND_TUNE_MODE  _IO('o', 81) /* unsigned int */
  
  #define FE_DISHNETWORK_SEND_LEGACY_CMD _IO('o', 80) /* unsigned int */
  
+ /*
+  * References:
+  * DVB-S : EN 300 421
+  * DVB-S2: EN 302 307, TR 102 376, EN 301 210
+  * DVB-C : EN 300 429
+  * DVB-T : EN 300 744
+  * DVB-H : EN 300 304
+  * ATSC  : A/53A
+  */
+ 
+ /*
+  * Delivery Systems
+  * needs to set/queried for multistandard frontends
+  */
+ enum dvbfe_delsys {
+ 	DVBFE_DELSYS_DVBS		= (1 <<  0),
+ 	DVBFE_DELSYS_DSS		= (1 <<  1),
+ 	DVBFE_DELSYS_DVBS2		= (1 <<  2),
+ 	DVBFE_DELSYS_DVBC		= (1 <<  3),
+ 	DVBFE_DELSYS_DVBT		= (1 <<  4),
+ 	DVBFE_DELSYS_DVBH		= (1 <<  5),
+ 	DVBFE_DELSYS_ATSC		= (1 <<  6),
+ 	DVBFE_DELSYS_DUMMY		= (1 << 31)
+ };
+ #define DVBFE_GET_DELSYS		_IOR('o', 82, enum dvbfe_delsys)
+ 
+ /*
+  * Modulation types
+  */
+ enum dvbfe_modulation {
+ 	DVBFE_MOD_NONE			= (0 <<  0),
+ 	DVBFE_MOD_BPSK			= (1 <<  0),
+ 	DVBFE_MOD_QPSK			= (1 <<  1),
+ 	DVBFE_MOD_OQPSK			= (1 <<  2),
+ 	DVBFE_MOD_8PSK			= (1 <<  3),
+ 	DVBFE_MOD_16APSK		= (1 <<  4),
+ 	DVBFE_MOD_32APSK		= (1 <<  5),
+ 	DVBFE_MOD_QAM4			= (1 <<  6),
+ 	DVBFE_MOD_QAM16			= (1 <<  7),
+ 	DVBFE_MOD_QAM32			= (1 <<  8),
+ 	DVBFE_MOD_QAM64			= (1 <<  9),
+ 	DVBFE_MOD_QAM128		= (1 << 10),
+ 	DVBFE_MOD_QAM256		= (1 << 11),
+ 	DVBFE_MOD_QAM512		= (1 << 12),
+ 	DVBFE_MOD_QAM1024		= (1 << 13),
+ 	DVBFE_MOD_QAMAUTO		= (1 << 14),
+ 	DVBFE_MOD_OFDM			= (1 << 15),
+ 	DVBFE_MOD_COFDM			= (1 << 16),
+ 	DVBFE_MOD_VSB8			= (1 << 17),
+ 	DVBFE_MOD_VSB16			= (1 << 18),
+ 	DVBFE_MOD_AUTO			= (1 << 31)
+ };
+ 
+ /*
+  * Convolution Code Rate (Viterbi Inner Code Rate)
+  * DVB-S2 uses LDPC. Information on LDPC can be found at
+  * http://www.ldpc-codes.com
+  */
+ enum dvbfe_fec {
+ 	DVBFE_FEC_NONE			= (0 <<  0),
+ 	DVBFE_FEC_1_4			= (1 <<  0),
+ 	DVBFE_FEC_1_3			= (1 <<  1),
+ 	DVBFE_FEC_2_5			= (1 <<  2),
+ 	DVBFE_FEC_1_2			= (1 <<  3),
+ 	DVBFE_FEC_3_5			= (1 <<  4),
+ 	DVBFE_FEC_2_3			= (1 <<  5),
+ 	DVBFE_FEC_3_4			= (1 <<  6),
+ 	DVBFE_FEC_4_5			= (1 <<  7),
+ 	DVBFE_FEC_5_6			= (1 <<  8),
+ 	DVBFE_FEC_6_7			= (1 <<  9),
+ 	DVBFE_FEC_7_8			= (1 << 10),
+ 	DVBFE_FEC_8_9			= (1 << 11),
+ 	DVBFE_FEC_9_10			= (1 << 12),
+ 	DVBFE_FEC_AUTO			= (1 << 31)
+ };
+ 
+ /*
+  * Frontend Inversion (I/Q Swap)
+  */
+ enum dvbfe_inversion {
+ 	DVBFE_INVERSION_OFF		= 0,
+ 	DVBFE_INVERSION_ON,
+ 	DVBFE_INVERSION_AUTO
+ };
+ enum dvbfe_rolloff {
+ 	DVBFE_ROLLOFF_35		= (0 <<  0),
+ 	DVBFE_ROLLOFF_25		= (1 <<  0),
+ 	DVBFE_ROLLOFF_20		= (2 <<  0),
+ 	DVBFE_ROLLOFF_UNKNOWN		= (3 <<  0)
+ };
+ /*
+  * DVB-S parameters
+  */
+ struct dvbs_params {
+ 	__u32				symbol_rate;
+ 
+ 	enum dvbfe_modulation		modulation;
+ 	enum dvbfe_fec			fec;
+         enum dvbfe_rolloff              rolloff;
+ };
+ 
+ /*
+  * DSS parameters
+  */
+ struct dss_params {
+ 	__u32				symbol_rate;
+ 
+ 	enum dvbfe_modulation		modulation;
+ 	enum dvbfe_fec			fec;
+         __u8                            pad[32];
+ };
+ 
+ /*
+  * DVB-S2 parameters
+  */
+ struct dvbs2_params {
+ 	__u32				symbol_rate;
+ 
+ 	enum dvbfe_modulation		modulation;
+ 	enum dvbfe_fec			fec;
+ 
+ 	/* Informational fields only	*/
+ 	enum dvbfe_rolloff		rolloff;
+ 
+ 	__u8				matype_1;
+ 	__u8				matype_2;
+ 	__u8				upl_1;
+ 	__u8				upl_2;
+ 	__u8				dfl_1;
+ 	__u8				dfl_2;
+ 	__u8				sync;
+ 	__u8				syncd_1;
+ 	__u8				syncd_2;
+ 
+ 	__u8				pad[32];
+ };
+ 
+ /*
+  * DVB-C parameters
+  */
+ struct dvbc_params {
+ 	__u32				symbol_rate;
+ 	enum dvbfe_modulation		modulation;
+ 	enum dvbfe_fec			fec;
+ };
+ 
+ /*
+  * DVB-T Channel bandwidth
+  */
+ enum dvbfe_bandwidth {
+ 	DVBFE_BANDWIDTH_8_MHZ		= (1 <<  0),
+ 	DVBFE_BANDWIDTH_7_MHZ		= (1 <<  1),
+ 	DVBFE_BANDWIDTH_6_MHZ		= (1 <<  2),
+ 	DVBFE_BANDWIDTH_5_MHZ		= (1 <<  3),
+ 	DVBFE_BANDWIDTH_AUTO		= (1 << 31)
+ };
+ 
+ /*
+  * DVB-T/DVB-H transmission mode
+  */
+ enum dvbfe_transmission_mode {
+ 	DVBFE_TRANSMISSION_MODE_2K	= (1 <<  0),
+ 	DVBFE_TRANSMISSION_MODE_4K	= (1 <<  1),
+ 	DVBFE_TRANSMISSION_MODE_8K	= (1 <<  2),
+ 	DVBFE_TRANSMISSION_MODE_AUTO	= (1 << 31)
+ };
+ 
+ /*
+  * DVB-T/DVB-H Guard interval
+  */
+ enum dvbfe_guard_interval {
+ 	DVBFE_GUARD_INTERVAL_1_32	= (1 <<  1),
+ 	DVBFE_GUARD_INTERVAL_1_16	= (1 <<  2),
+ 	DVBFE_GUARD_INTERVAL_1_8	= (1 <<  3),
+ 	DVBFE_GUARD_INTERVAL_1_4	= (1 <<  4),
+ 	DVBFE_GUARD_INTERVAL_AUTO	= (1 << 31)
+ };
+ 
+ /*
+  * DVB-T/DVB-H Hierarchial modulation
+  */
+ enum dvbfe_hierarchy {
+ 	DVBFE_HIERARCHY_OFF		= (1 <<  0),
+ 	DVBFE_HIERARCHY_ON		= (1 <<  1),
+ 	DVBFE_HIERARCHY_AUTO		= (1 <<  2)
+ };
+ 
+ /*
+  * DVB-T/DVB-H Rolloff's
+  */
+ enum dvbfe_alpha {
+ 	DVBFE_ALPHA_1			= (1 <<  0),
+ 	DVBFE_ALPHA_2			= (1 <<  1),
+ 	DVBFE_ALPHA_4			= (1 <<  2)
+ };
+ 
+ /*
+  * Stream priority for Hierachial coding
+  */
+ enum dvbfe_stream_priority {
+ 	DVBFE_STREAM_PRIORITY_HP	= (0 << 0),
+ 	DVBFE_STREAM_PRIORITY_LP	= (1 << 0)
+ };
+ 
+ /*
+  * DVB-T parameters
+  */
+ struct dvbt_params {
+ 	enum dvbfe_modulation		constellation;
+ 	enum dvbfe_bandwidth		bandwidth;
+ 	enum dvbfe_fec			code_rate_HP;
+ 	enum dvbfe_fec			code_rate_LP;
+ 	enum dvbfe_transmission_mode	transmission_mode;
+ 	enum dvbfe_guard_interval	guard_interval;
+ 	enum dvbfe_hierarchy		hierarchy;
+ 	enum dvbfe_alpha		alpha;
+ 	enum dvbfe_stream_priority	priority;
+ 
+ 	__u8				pad[32];
+ };
+ 
+ /*
+  * DVB-H Interleaver type
+  */
+ enum dvbfe_interleaver {
+ 	DVBFE_INTERLEAVER_NATIVE	= (1 <<  0),
+ 	DVBFE_INTERLEAVER_INDEPTH	= (1 <<  1),
+ 	DVBFE_INTERLEAVER_AUTO		= (1 << 31)
+ };
+ 
+ /*
+  * DVB-H MPE-FEC Indicator
+  */
+ enum dvbfe_mpefec {
+ 	DVBFE_MPEFEC_OFF		= (1 <<  0),
+ 	DVBFE_MPEFEC_ON			= (1 <<  1)
+ };
+ 
+ /*
+  * DVB-H Timeslicing Indicator
+  */
+ enum dvbfe_timeslicing {
+ 	DVBFE_TIMESLICING_OFF		= (1 <<  0),
+ 	DVBFE_TIMESLICING_ON		= (1 <<  1)
+ };
+ 
+ /*
+  * DVB-H parameters
+  */
+ struct dvbh_params {
+ 	enum dvbfe_modulation		constellation;
+ 	enum dvbfe_fec			code_rate_HP;
+ 	enum dvbfe_fec			code_rate_LP;
+ 	enum dvbfe_transmission_mode	transmission_mode;
+ 	enum dvbfe_guard_interval	guard_interval;
+ 	enum dvbfe_hierarchy		hierarchy;
+ 	enum dvbfe_alpha		alpha;
+ 	enum dvbfe_interleaver		interleaver;
+ 	enum dvbfe_mpefec		mpefec;
+ 	enum dvbfe_timeslicing		timeslicing;
+ 	enum dvbfe_stream_priority	priority;
+ 
+ 	__u32				bandwidth;
+ 	__u8				pad[32];
+ };
+ 
+ /*
+  * ATSC parameters
+  */
+ struct atsc_params {
+ 	enum dvbfe_modulation		modulation;
+ 
+ 	__u8				pad[32];
+ };
+ 
+ /*
+  * DVB Frontend Tuning Parameters
+  */
+ struct dvbfe_params {
+ 	__u32				frequency;
+ 	enum fe_spectral_inversion	inversion;
+ 	enum dvbfe_delsys		delivery;
+ 
+ 	__u8				pad[32];
+ 
+ 	union {
+ 		struct dvbs_params	dvbs;
+ 		struct dss_params	dss;
+ 		struct dvbs2_params	dvbs2;
+ 		struct dvbc_params	dvbc;
+ 		struct dvbt_params	dvbt;
+ 		struct dvbh_params	dvbh;
+ 		struct atsc_params	atsc;
+ 
+ 		__u8			pad[128];
+ 	} delsys;
+ };
+ #define DVBFE_SET_PARAMS		_IOW('o', 83, struct dvbfe_params)
+ #define DVBFE_GET_PARAMS		_IOWR('o', 84, struct dvbfe_params)
+ 
+ /*
+  * DVB-S capability bitfields
+  */
+ struct dvbfe_dvbs_info {
+ 	enum dvbfe_modulation		modulation;
+ 	enum dvbfe_fec			fec;
+ };
+ 
+ /*
+  * DSS capability bitfields
+  */
+ struct dvbfe_dss_info {
+ 	enum dvbfe_modulation		modulation;
+ 	enum dvbfe_fec			fec;
+ };
+ 
+ /*
+  * DVB-S2 capability bitfields
+  */
+ struct dvbfe_dvbs2_info {
+ 	enum dvbfe_modulation		modulation;
+ 	enum dvbfe_fec			fec;
+ 
+ 	__u8				pad[32];
+ };
+ 
+ /*
+  * DVB-C capability bitfields
+  */
+ struct dvbfe_dvbc_info {
+ 	enum dvbfe_modulation		modulation;
+ };
+ 
+ /*
+  * DVB-T capability bitfields
+  */
+ struct dvbfe_dvbt_info {
+ 	enum dvbfe_modulation		modulation;
+ 	enum dvbfe_stream_priority	stream_priority;
+ 
+ 	__u8				pad[32];
+ };
+ 
+ /*
+  * DVB-H capability bitfields
+  */
+ struct dvbfe_dvbh_info {
+ 	enum dvbfe_modulation		modulation;
+ 	enum dvbfe_stream_priority	stream_priority;
+ 
+ 	__u8				pad[32];
+ };
+ 
+ /*
+  * ATSC capability bitfields
+  */
+ struct dvbfe_atsc_info {
+ 	enum dvbfe_modulation		modulation;
+ 
+ 	__u8				pad[32];
+ };
+ 
+ /*
+  * DVB Frontend related Information
+  */
+ struct dvbfe_info {
+ 	char				name[128];
+ 
+ 	/* For Multi Standard tuners, set "delivery"
+ 	 * to the relevant delivery system to retrieve the
+ 	 * relevant delivery system related information.
+ 	 */
+ 	enum dvbfe_delsys		delivery;
+ 
+ 	union {
+ 		struct dvbfe_dvbs_info	dvbs;
+ 		struct dvbfe_dss_info	dss;
+ 		struct dvbfe_dvbs2_info	dvbs2;
+ 		struct dvbfe_dvbc_info	dvbc;
+ 		struct dvbfe_dvbt_info	dvbt;
+ 		struct dvbfe_dvbh_info	dvbh;
+ 		struct dvbfe_atsc_info	atsc;
+ 
+ 		__u8			pad[128];
+ 	} delsys;
+ 
+ 	__u32				frequency_min;
+ 	__u32				frequency_max;
+ 	__u32				frequency_step;
+ 	__u32				frequency_tolerance;
+ 	__u32				symbol_rate_min;
+ 	__u32				symbol_rate_max;
+ 	__u32				symbol_rate_tolerance;
+ 
+ 	enum fe_spectral_inversion	inversion;
+ 
+ 	__u8				pad[128];
+ };
+ #define DVBFE_GET_INFO			_IOWR('o', 85, struct dvbfe_info)
+ 
+ enum dvbfe_status {
+ 	DVBFE_HAS_SIGNAL		= (1 <<  0),	/*  something above noise floor	*/
+ 	DVBFE_HAS_CARRIER		= (1 <<  1),	/*  Signal found		*/
+ 	DVBFE_HAS_VITERBI		= (1 <<  2),	/*  FEC is stable		*/
+ 	DVBFE_HAS_SYNC			= (1 <<  3),	/*  SYNC found			*/
+ 	DVBFE_HAS_LOCK			= (1 <<  4),	/*  OK ..			*/
+ 	DVBFE_TIMEDOUT			= (1 <<  5),	/*  no lock in last ~2 s	*/
+ 	DVBFE_STATUS_DUMMY		= (1 << 31)
+ };
+ 
+ /*
+  * DVB Frontend events
+  */
+ struct dvbfe_events {
+ 	enum dvbfe_status		status;
+ 
+ 	__u8				pad[32];
+ };
+ 
+ struct dvb_frontend_event {
+ 	fe_status_t status;
+ 	struct dvb_frontend_parameters parameters;
+ 	struct dvbfe_events fe_events;
+ 	struct dvbfe_params fe_params;
+ };
+ #define FE_GET_EVENT		   _IOR('o', 78, struct dvb_frontend_event)
+ 
  #endif /*_DVBFRONTEND_H_*/
diff -rcN linux/include/linux/dvb/version.h UFS922_Orig/include/linux/dvb/version.h
*** linux/include/linux/dvb/version.h	2006-06-18 03:49:35.000000000 +0200
--- UFS922_Orig/include/linux/dvb/version.h	2009-02-10 19:25:30.000000000 +0100
***************
*** 24,29 ****
  #define _DVBVERSION_H_
  
  #define DVB_API_VERSION 3
! #define DVB_API_VERSION_MINOR 1
  
  #endif /*_DVBVERSION_H_*/
--- 24,29 ----
  #define _DVBVERSION_H_
  
  #define DVB_API_VERSION 3
! #define DVB_API_VERSION_MINOR 2
  
  #endif /*_DVBVERSION_H_*/
diff -rcN linux/include/linux/dvb/video.h UFS922_Orig/include/linux/dvb/video.h
*** linux/include/linux/dvb/video.h	2006-06-18 03:49:35.000000000 +0200
--- UFS922_Orig/include/linux/dvb/video.h	2009-02-10 19:25:30.000000000 +0100
***************
*** 80,93 ****
--- 80,172 ----
  } video_play_state_t;
  
  
+ /* Decoder commands */
+ #define VIDEO_CMD_PLAY        (0)
+ #define VIDEO_CMD_STOP        (1)
+ #define VIDEO_CMD_FREEZE      (2)
+ #define VIDEO_CMD_CONTINUE    (3)
+ 
+ /* Flags for VIDEO_CMD_FREEZE */
+ #define VIDEO_CMD_FREEZE_TO_BLACK     	(1 << 0)
+ 
+ /* Flags for VIDEO_CMD_STOP */
+ #define VIDEO_CMD_STOP_TO_BLACK      	(1 << 0)
+ #define VIDEO_CMD_STOP_IMMEDIATELY     	(1 << 1)
+ 
+ /* Play input formats: */
+ /* The decoder has no special format requirements */
+ #define VIDEO_PLAY_FMT_NONE         (0)
+ /* The decoder requires full GOPs */
+ #define VIDEO_PLAY_FMT_GOP          (1)
+ 
+ /* The structure must be zeroed before use by the application
+    This ensures it can be extended safely in the future. */
+ /*struct video_command {
+ 	__u32 cmd;
+ 	__u32 flags;
+ 	union {
+ 		struct {
+ 			__u64 pts;
+ 		} stop;
+ 
+ 		struct {
+ 			__u32 speed;
+ 			__u32 format;
+ 		} play;
+ 
+ 		struct {
+ 			__u32 data[16];
+ 		} raw;
+ 	};
+ };*/
+ struct video_command {
+ 	unsigned int cmd;
+ 	unsigned int flags;
+ 	union {
+ 		struct {
+ 			unsigned long long pts;
+ 		} stop;
+ 
+ 		struct {
+ 			/* 0 or 1000 specifies normal speed,
+ 			   1 specifies forward single stepping,
+ 			   -1 specifies backward single stepping,
+ 			   >1: playback at speed/1000 of the normal speed,
+ 			   <-1: reverse playback at (-speed/1000) of the normal speed. */
+ 			int          speed;
+ 			unsigned int format;
+ 		} play;
+ 
+ 		struct {
+ 			unsigned int data[16];
+ 		} raw;
+ 
+ 		struct {
+ 			unsigned int    option; /* really dvb_option_t but like this so don't modify kernel sources too much */
+ 			unsigned int    value;
+ 		} option;
+ 
+ 	};
+ };
+ /* FIELD_UNKNOWN can be used if the hardware does not know whether
+    the Vsync is for an odd, even or progressive (i.e. non-interlaced)
+    field. */
+ #define VIDEO_VSYNC_FIELD_UNKNOWN  	(0)
+ #define VIDEO_VSYNC_FIELD_ODD 		(1)
+ #define VIDEO_VSYNC_FIELD_EVEN		(2)
+ #define VIDEO_VSYNC_FIELD_PROGRESSIVE	(3)
+ 
  struct video_event {
  	int32_t type;
  #define VIDEO_EVENT_SIZE_CHANGED	1
  #define VIDEO_EVENT_FRAME_RATE_CHANGED	2
+ #define VIDEO_EVENT_DECODER_STOPPED 	3
+ #define VIDEO_EVENT_VSYNC 		4
  	time_t timestamp;
  	union {
  		video_size_t size;
  		unsigned int frame_rate;	/* in frames per 1000sec */
+ 		unsigned char vsync_field;	/* unknown/odd/even/progressive */
  	} u;
  };
  
***************
*** 213,216 ****
--- 292,301 ----
   */
  #define VIDEO_GET_PTS              _IOR('o', 57, __u64)
  
+ /* Read the number of displayed frames since the decoder was started */
+ #define VIDEO_GET_FRAME_COUNT  	   _IOR('o', 58, __u64)
+ 
+ #define VIDEO_COMMAND     	   _IOWR('o', 59, struct video_command)
+ #define VIDEO_TRY_COMMAND 	   _IOWR('o', 60, struct video_command)
+ 
  #endif /*_DVBVIDEO_H_*/
diff -Naur linux-orig/drivers/media/dvb/dvb-core/dmxdev.c linux/drivers/media/dvb/dvb-core/dmxdev.c
--- linux-orig/drivers/media/dvb/dvb-core/dmxdev.c	2009-06-07 14:13:04.000000000 +0200
+++ linux/drivers/media/dvb/dvb-core/dmxdev.c	2009-06-20 17:20:04.000000000 +0200
@@ -379,11 +379,18 @@
 	switch (dmxdevfilter->type) {
 	case DMXDEV_TYPE_SEC:
 		del_timer(&dmxdevfilter->timer);
-		dmxdevfilter->feed.sec->stop_filtering(dmxdevfilter->feed.sec);
+		dmxdevfilter->feed_sec->stop_filtering(dmxdevfilter->feed_sec);
 		break;
 	case DMXDEV_TYPE_PES:
-		dmxdevfilter->feed.ts->stop_filtering(dmxdevfilter->feed.ts);
-		break;
+        {
+                struct dmxdev_feed *feed=dmxdevfilter->feeds;
+		/* stop all feeds */
+                while (feed) {
+                        feed->ts->stop_filtering(feed->ts);
+                        feed=feed->next;
+                }
+                break;
+        }
 	default:
 		return -EINVAL;
 	}
@@ -397,9 +404,17 @@
 
 	switch (filter->type) {
 	case DMXDEV_TYPE_SEC:
-		return filter->feed.sec->start_filtering(filter->feed.sec);
+		return filter->feed_sec->start_filtering(filter->feed_sec);
 	case DMXDEV_TYPE_PES:
-		return filter->feed.ts->start_filtering(filter->feed.ts);
+        {
+                struct dmxdev_feed *feed=filter->feeds;
+		/* start all feeds */
+                while (feed) {
+                        feed->ts->start_filtering(feed->ts);
+                        feed=feed->next;
+                }
+                break;
+        }
 	default:
 		return -EINVAL;
 	}
@@ -424,7 +439,7 @@
 		}
 
 	filter->dev->demux->release_section_feed(dmxdev->demux,
-						 filter->feed.sec);
+						 filter->feed_sec);
 
 	return 0;
 }
@@ -436,25 +451,32 @@
 
 	switch (dmxdevfilter->type) {
 	case DMXDEV_TYPE_SEC:
-		if (!dmxdevfilter->feed.sec)
+		if (!dmxdevfilter->feed_sec)
 			break;
 		dvb_dmxdev_feed_stop(dmxdevfilter);
 		if (dmxdevfilter->filter.sec)
-			dmxdevfilter->feed.sec->
-			    release_filter(dmxdevfilter->feed.sec,
+			dmxdevfilter->feed_sec->
+			    release_filter(dmxdevfilter->feed_sec,
 					   dmxdevfilter->filter.sec);
 		dvb_dmxdev_feed_restart(dmxdevfilter);
-		dmxdevfilter->feed.sec = NULL;
+		dmxdevfilter->feed_sec = NULL;
 		break;
 	case DMXDEV_TYPE_PES:
-		if (!dmxdevfilter->feed.ts)
-			break;
+	{
+		struct dmxdev_feed *feed=dmxdevfilter->feeds;
+
 		dvb_dmxdev_feed_stop(dmxdevfilter);
-		dmxdevfilter->dev->demux->
-		    release_ts_feed(dmxdevfilter->dev->demux,
-				    dmxdevfilter->feed.ts);
-		dmxdevfilter->feed.ts = NULL;
+
+		/* remove all feeds */
+		while (feed) {
+			dmxdevfilter->dev->demux->
+				release_ts_feed(dmxdevfilter->dev->demux,
+					feed->ts);
+			feed->ts=NULL;
+			feed=feed->next;
+		}
 		break;
+	}
 	default:
 		if (dmxdevfilter->state == DMXDEV_STATE_ALLOCATED)
 			return 0;
@@ -467,14 +489,87 @@
 
 static inline int dvb_dmxdev_filter_reset(struct dmxdev_filter *dmxdevfilter)
 {
-	if (dmxdevfilter->state < DMXDEV_STATE_SET)
+	struct dmxdev_feed *feed=dmxdevfilter->feeds;
+
+	if (dmxdevfilter->state<DMXDEV_STATE_SET)
 		return 0;
 
+	/* free all */
+	while (feed) {
+		struct dmxdev_feed *n=feed;
+		if (feed->ts)
+			printk("!!! ts still allocated\n");
+		feed=feed->next;
+		vfree(n);
+	}
+
+	dmxdevfilter->feeds=NULL;
 	dmxdevfilter->type = DMXDEV_TYPE_NONE;
 	dvb_dmxdev_filter_state_set(dmxdevfilter, DMXDEV_STATE_ALLOCATED);
 	return 0;
 }
 
+static int dvb_dmxdev_start_feed(struct dmxdev *dmxdev, struct dmxdev_filter *filter,
+                                struct dmxdev_feed *feed)
+{
+	struct dmx_pes_filter_params *para = &filter->params.pes;
+	struct timespec timeout = { 0 };
+	struct dmx_ts_feed **tsfeed = &feed->ts;
+	int ret;
+	int ts_type;
+	enum dmx_ts_pes ts_pes;
+	dmx_output_t otype;
+
+	*tsfeed = 0;
+
+		/* determine which format to output */
+	otype = para->output;
+
+	ts_pes = (enum dmx_ts_pes)para->pes_type;
+
+	if (otype == DMX_OUT_DECODER)
+		ts_type = TS_DECODER;
+	else
+		ts_type = 0;                                                    
+
+	/* DMX_OUT_TS_TAP expects TS headers */
+	if (otype == DMX_OUT_TS_TAP)
+		ts_type |= TS_PACKET;
+
+	/* DMX_OUT_TAP used to expect PES packets. */
+	if (otype == DMX_OUT_TAP) {
+		ts_type |= TS_PACKET;
+
+		/*now, if somebody specified something else than DMX_PES_OTHER, we assume TS filtering. */
+		if (ts_pes == DMX_PES_OTHER) /* i.e. DMX_PES_OTHER for backward compat. */
+			ts_type |= TS_PAYLOAD_ONLY;
+	}
+
+	ret = dmxdev->demux->allocate_ts_feed(dmxdev->demux, tsfeed,
+						dvb_dmxdev_ts_callback);
+
+	if (ret < 0)
+		return ret;
+
+	(*tsfeed)->priv=filter;
+
+	ret = (*tsfeed)->set(*tsfeed, feed->pid, ts_type, ts_pes, 32768,
+				timeout);
+
+	if (ret < 0) {                                                          
+		dmxdev->demux->release_ts_feed(dmxdev->demux, *tsfeed);
+		return ret;
+	}
+
+	ret = feed->ts->start_filtering(feed->ts);
+	if (ret < 0) {
+		dmxdev->demux->release_ts_feed(dmxdev->demux, *tsfeed);
+		return ret;
+	}
+
+	return 0;
+}
+
 static int dvb_dmxdev_filter_start(struct dmxdev_filter *filter)
 {
 	struct dmxdev *dmxdev = filter->dev;
@@ -503,7 +598,7 @@
 	{
 		struct dmx_sct_filter_params *para = &filter->params.sec;
 		struct dmx_section_filter **secfilter = &filter->filter.sec;
-		struct dmx_section_feed **secfeed = &filter->feed.sec;
+		struct dmx_section_feed **secfeed = &filter->feed_sec;
 
 		*secfilter = NULL;
 		*secfeed = NULL;
@@ -514,7 +609,7 @@
 			if (dmxdev->filter[i].state >= DMXDEV_STATE_GO &&
 			    dmxdev->filter[i].type == DMXDEV_TYPE_SEC &&
 			    dmxdev->filter[i].params.sec.pid == para->pid) {
-				*secfeed = dmxdev->filter[i].feed.sec;
+				*secfeed = dmxdev->filter[i].feed_sec;
 				break;
 			}
 		}
@@ -545,7 +640,7 @@
 		ret = (*secfeed)->allocate_filter(*secfeed, secfilter);
 		if (ret < 0) {
 			dvb_dmxdev_feed_restart(filter);
-			filter->feed.sec->start_filtering(*secfeed);
+			filter->feed_sec->start_filtering(*secfeed);
 			dprintk("could not get filter\n");
 			return ret;
 		}
@@ -567,7 +662,7 @@
 
 		filter->todo = 0;
 
-		ret = filter->feed.sec->start_filtering(filter->feed.sec);
+		ret = filter->feed_sec->start_filtering(filter->feed_sec);
 		if (ret < 0)
 			return ret;
 
@@ -576,51 +671,14 @@
 	}
 	case DMXDEV_TYPE_PES:
 	{
-		struct timespec timeout = { 0 };
-		struct dmx_pes_filter_params *para = &filter->params.pes;
-		dmx_output_t otype;
-		int ret;
-		int ts_type;
-		enum dmx_ts_pes ts_pes;
-		struct dmx_ts_feed **tsfeed = &filter->feed.ts;
-
-		filter->feed.ts = NULL;
-		otype = para->output;
-
-		ts_pes = (enum dmx_ts_pes)para->pes_type;
-
-		if (ts_pes < DMX_PES_OTHER)
-			ts_type = TS_DECODER;
-		else
-			ts_type = 0;
-
-		if (otype == DMX_OUT_TS_TAP)
-			ts_type |= TS_PACKET;
-
-		if (otype == DMX_OUT_TAP)
-			ts_type |= TS_PAYLOAD_ONLY | TS_PACKET;
-
-		ret = dmxdev->demux->allocate_ts_feed(dmxdev->demux,
-						      tsfeed,
-						      dvb_dmxdev_ts_callback);
-		if (ret < 0)
-			return ret;
-
-		(*tsfeed)->priv = filter;
+		struct dmxdev_feed *feed=filter->feeds;
 
-		ret = (*tsfeed)->set(*tsfeed, para->pid, ts_type, ts_pes,
-				     32768, timeout);
-		if (ret < 0) {
-			dmxdev->demux->release_ts_feed(dmxdev->demux,
-						       *tsfeed);
-			return ret;
-		}
-
-		ret = filter->feed.ts->start_filtering(filter->feed.ts);
-		if (ret < 0) {
-			dmxdev->demux->release_ts_feed(dmxdev->demux,
-						       *tsfeed);
-			return ret;
+		/* start all feeds */
+		while (feed) {
+			if (dvb_dmxdev_start_feed(dmxdev, filter, feed)) {
+				printk(".. feed start failed. we should unroll now.\n");
+			}
+			feed=feed->next;
 		}
 
 		break;
@@ -662,7 +720,7 @@
 	dvb_ringbuffer_init(&dmxdevfilter->buffer, NULL, 8192);
 	dmxdevfilter->type = DMXDEV_TYPE_NONE;
 	dvb_dmxdev_filter_state_set(dmxdevfilter, DMXDEV_STATE_ALLOCATED);
-	dmxdevfilter->feed.ts = NULL;
+	dmxdevfilter->feeds = NULL;
 	init_timer(&dmxdevfilter->timer);
 
 	mutex_unlock(&dmxdev->mutex);
@@ -702,6 +760,59 @@
 		filter->mode[i] ^= 0xff;
 }
 
+static int dvb_dmxdev_add_pid(struct dmxdev *dmxdev,
+				struct dmxdev_filter *dmxdevfilter,
+				__u16 pid)
+{
+	struct dmxdev_feed *feed=vmalloc(sizeof(struct dmxdev_feed));
+ 
+	if (feed == NULL)
+		return -ENOMEM;
+ 
+	memset(feed, 0, sizeof(struct dmxdev_feed));
+ 
+	feed->pid=pid;
+ 
+	feed->next=dmxdevfilter->feeds;
+	dmxdevfilter->feeds=feed;
+ 
+	if (dmxdevfilter->state >= DMXDEV_STATE_GO) {
+		int ret = dvb_dmxdev_start_feed(dmxdev, dmxdevfilter, feed);
+		if (ret) {
+			printk("add_pid: start feed failed..\n");
+			return ret;
+		}
+	}
+ 
+	return 0;
+}
+ 
+static int dvb_dmxdev_remove_pid(struct dmxdev *dmxdev,
+		struct dmxdev_filter *dmxdevfilter,
+		__u16 pid)
+{
+	struct dmxdev_feed **feed=&dmxdevfilter->feeds;
+
+	while (*feed) {
+		if ((*feed)->pid == pid) {
+			struct dmxdev_feed *f=*feed;
+			if (f->ts) {  // feed active
+				f->ts->stop_filtering(f->ts);
+				dmxdevfilter->dev->demux->release_ts_feed(
+					dmxdevfilter->dev->demux,
+					f->ts);
+				f->ts=NULL;
+			}
+			*feed=(*feed)->next;
+			vfree(f);
+			continue;
+		}
+		feed=&(*feed)->next;
+	}
+
+	return 0;
+}
+
 static int dvb_dmxdev_filter_set(struct dmxdev *dmxdev,
 				 struct dmxdev_filter *dmxdevfilter,
 				 struct dmx_sct_filter_params *params)
@@ -727,6 +838,7 @@
 				     struct dmx_pes_filter_params *params)
 {
 	dvb_dmxdev_filter_stop(dmxdevfilter);
+	dvb_dmxdev_filter_reset(dmxdevfilter);
 
 	if (params->pes_type > DMX_PES_OTHER || params->pes_type < 0)
 		return -EINVAL;
@@ -737,6 +849,12 @@
 
 	dvb_dmxdev_filter_state_set(dmxdevfilter, DMXDEV_STATE_SET);
 
+	if (dmxdevfilter->params.pes.pid <= 0x2000) {
+		int result = dvb_dmxdev_add_pid(dmxdev, dmxdevfilter, dmxdevfilter->params.pes.pid);
+		if (result)
+			return result;
+	}
+ 
 	if (params->flags & DMX_IMMEDIATE_START)
 		return dvb_dmxdev_filter_start(dmxdevfilter);
 
@@ -791,17 +909,19 @@
 	struct dmxdev_filter *dmxdevfilter = file->private_data;
 	int ret;
 
-	if (mutex_lock_interruptible(&dmxdevfilter->mutex))
-		return -ERESTARTSYS;
+	if (dmxdevfilter->type == DMXDEV_TYPE_SEC) {
+		if (mutex_lock_interruptible(&dmxdevfilter->mutex))
+			return -ERESTARTSYS;
 
-	if (dmxdevfilter->type == DMXDEV_TYPE_SEC)
 		ret = dvb_dmxdev_read_sec(dmxdevfilter, file, buf, count, ppos);
+
+		mutex_unlock(&dmxdevfilter->mutex);
+	}
 	else
 		ret = dvb_dmxdev_buffer_read(&dmxdevfilter->buffer,
 					     file->f_flags & O_NONBLOCK,
 					     buf, count, ppos);
 
-	mutex_unlock(&dmxdevfilter->mutex);
 	return ret;
 }
 
@@ -881,6 +1001,24 @@
 		ret = dmxdev->demux->get_caps(dmxdev->demux, parg);
 		break;
 
+	case DMX_ADD_PID:
+		if (mutex_lock_interruptible(&dmxdevfilter->mutex)) {
+			mutex_unlock(&dmxdev->mutex);
+			return -ERESTARTSYS;
+		}
+		ret = dvb_dmxdev_add_pid(dmxdev, dmxdevfilter, arg);
+		mutex_unlock(&dmxdevfilter->mutex);
+		break;
+ 
+	case DMX_REMOVE_PID:
+		if (mutex_lock_interruptible(&dmxdevfilter->mutex)) {
+			mutex_unlock(&dmxdev->mutex);
+			return -ERESTARTSYS;
+		}
+		ret = dvb_dmxdev_remove_pid(dmxdev, dmxdevfilter, arg);
+		mutex_unlock(&dmxdevfilter->mutex);
+		break;
+
 	case DMX_SET_SOURCE:
 		if (!dmxdev->demux->set_source) {
 			ret = -EINVAL;
diff -Naur linux-orig/drivers/media/dvb/dvb-core/dmxdev.h linux/drivers/media/dvb/dvb-core/dmxdev.h
--- linux-orig/drivers/media/dvb/dvb-core/dmxdev.h	2009-06-07 14:13:04.000000000 +0200
+++ linux/drivers/media/dvb/dvb-core/dmxdev.h	2009-06-20 16:51:53.000000000 +0200
@@ -62,15 +62,20 @@
 	} filter;
 
 	union {
-		struct dmx_ts_feed *ts;
-		struct dmx_section_feed *sec;
-	} feed;
-
-	union {
 		struct dmx_sct_filter_params sec;
 		struct dmx_pes_filter_params pes;
 	} params;
 
+	struct dmx_section_feed *feed_sec;
+ 
+	struct dmxdev_feed {
+		int pid;
+ 
+		struct dmx_ts_feed *ts;
+ 
+		struct dmxdev_feed *next;
+	} *feeds;
+
 	enum dmxdev_type type;
 	enum dmxdev_state state;
 	struct dmxdev *dev;
diff -Naur linux-orig/include/linux/dvb/dmx.h linux/include/linux/dvb/dmx.h
--- linux-orig/include/linux/dvb/dmx.h 2009-06-01 02:34:40.000000000 +0200
+++ linux/include/linux/dvb/dmx.h      2006-06-07 15:40:47.000000000 +0200
@@ -150,5 +150,7 @@
 #define DMX_GET_CAPS             _IOR('o', 48, dmx_caps_t)
 #define DMX_SET_SOURCE           _IOW('o', 49, dmx_source_t)
 #define DMX_GET_STC              _IOWR('o', 50, struct dmx_stc)
+#define DMX_ADD_PID             _IO('o', 51)
+#define DMX_REMOVE_PID          _IO('o', 52)

 #endif /*_DVBDMX_H_*/
diff -Naur linux-orig/drivers/media/dvb/dvb-core/dvb_demux.c linux/drivers/media/dvb/dvb-core/dvb_demux.c
--- linux-orig/drivers/media/dvb/dvb-core/dvb_demux.c	2009-06-07 14:13:05.000000000 +0200
+++ linux/drivers/media/dvb/dvb-core/dvb_demux.c	2009-06-20 16:55:25.000000000 +0200
@@ -380,36 +380,18 @@
 	}
 }
 
-#define DVR_FEED(f)							\
-	(((f)->type == DMX_TYPE_TS) &&					\
-	((f)->feed.ts.is_filtering) &&					\
-	(((f)->ts_type & (TS_PACKET|TS_PAYLOAD_ONLY)) == TS_PACKET))
-
 static void dvb_dmx_swfilter_packet(struct dvb_demux *demux, const u8 *buf, int count)
 {
 	struct dvb_demux_feed *feed;
 	struct list_head *pos, *head = &demux->feed_list;
 	u16 pid = ts_pid(buf);
-	int dvr_done = 0;
 
 	list_for_each(pos, head) {
 		feed = list_entry(pos, struct dvb_demux_feed, list_head);
 
-		if ((feed->pid != pid) && (feed->pid != 0x2000))
-			continue;
-
-		/* copy each packet only once to the dvr device, even
-		 * if a PID is in multiple filters (e.g. video + PCR) */
-		if ((DVR_FEED(feed)) && (dvr_done++))
-			continue;
-
-		if (feed->pid == pid) {
+		if (feed->pid == pid)
 			dvb_dmx_swfilter_packet_type(feed, buf, count);
-			if (DVR_FEED(feed))
-				continue;
-		}
-
-		if (feed->pid == 0x2000)
+		else if (feed->pid == 0x2000)
 			feed->cb.ts(buf, count, NULL, 0, &feed->feed.ts, DMX_OK);
 	}
 }
--- linux/drivers/media/dvb/dvb-core/dvb_demux.c	2010-03-18 12:18:24.000000000 -0400
+++ linux/drivers/media/dvb/dvb-core/dvb_demux.c	2010-03-18 12:19:04.000000000 -0400
@@ -396,6 +396,8 @@
 	}
 }
 
+EXPORT_SYMBOL(dvb_dmx_swfilter_packet);
+
 void dvb_dmx_swfilter_packets(struct dvb_demux *demux, const u8 *buf,
 			      size_t count)
 {
 
--- linux/drivers/media/dvb/dvb-core/dvb_demux.h	2010-03-21 22:41:52.000000000 -0400
+++ linux/drivers/media/dvb/dvb-core/dvb_demux.h	2010-03-21 22:45:32.000000000 -0400
@@ -138,6 +138,7 @@
 
 int dvb_dmx_init(struct dvb_demux *dvbdemux);
 void dvb_dmx_release(struct dvb_demux *dvbdemux);
+static void dvb_dmx_swfilter_packet(struct dvb_demux *demux, const u8 *buf, int count);
 void dvb_dmx_swfilter_packets(struct dvb_demux *dvbdmx, const u8 *buf,
 			      size_t count);
 void dvb_dmx_swfilter(struct dvb_demux *demux, const u8 *buf, size_t count);
