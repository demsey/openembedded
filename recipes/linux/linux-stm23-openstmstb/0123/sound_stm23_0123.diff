diff -rcN linux-sh4-2.6.23.17_stm23_0119-orig/sound//core/oss/pcm_oss.c linux-sh4/sound//core/oss/pcm_oss.c
*** linux-sh4-2.6.23.17_stm23_0119-orig/sound//core/oss/pcm_oss.c	2007-10-09 22:31:38.000000000 +0200
--- linux-sh4/sound//core/oss/pcm_oss.c	2009-07-18 20:38:57.000000000 +0200
***************
*** 203,209 ****
  	return changed;
  }
  
! static int snd_pcm_hw_param_mask(struct snd_pcm_substream *pcm,
  				 struct snd_pcm_hw_params *params,
  				 snd_pcm_hw_param_t var,
  				 const struct snd_mask *val)
--- 203,209 ----
  	return changed;
  }
  
! int snd_pcm_hw_param_mask(struct snd_pcm_substream *pcm,
  				 struct snd_pcm_hw_params *params,
  				 snd_pcm_hw_param_t var,
  				 const struct snd_mask *val)
***************
*** 219,225 ****
  	return 0;
  }
  
! static int _snd_pcm_hw_param_min(struct snd_pcm_hw_params *params,
  				 snd_pcm_hw_param_t var, unsigned int val,
  				 int dir)
  {
--- 219,227 ----
  	return 0;
  }
  
! EXPORT_SYMBOL_GPL(snd_pcm_hw_param_mask);
! 
! int _snd_pcm_hw_param_min(struct snd_pcm_hw_params *params,
  				 snd_pcm_hw_param_t var, unsigned int val,
  				 int dir)
  {
***************
*** 250,255 ****
--- 252,259 ----
  	return changed;
  }
  
+ EXPORT_SYMBOL_GPL(_snd_pcm_hw_param_min);
+ 
  /**
   * snd_pcm_hw_param_min
   * @pcm: PCM instance
***************
*** 397,403 ****
   * SNDRV_PCM_HW_PARAM_FORMAT, SNDRV_PCM_HW_PARAM_SUBFORMAT.
   * Return the value found.
    */
! static int snd_pcm_hw_param_near(struct snd_pcm_substream *pcm,
  				 struct snd_pcm_hw_params *params,
  				 snd_pcm_hw_param_t var, unsigned int best,
  				 int *dir)
--- 401,407 ----
   * SNDRV_PCM_HW_PARAM_FORMAT, SNDRV_PCM_HW_PARAM_SUBFORMAT.
   * Return the value found.
    */
! int snd_pcm_hw_param_near(struct snd_pcm_substream *pcm,
  				 struct snd_pcm_hw_params *params,
  				 snd_pcm_hw_param_t var, unsigned int best,
  				 int *dir)
***************
*** 466,471 ****
--- 470,477 ----
  	return v;
  }
  
+ EXPORT_SYMBOL_GPL(snd_pcm_hw_param_near);
+ 
  static int _snd_pcm_hw_param_set(struct snd_pcm_hw_params *params,
  				 snd_pcm_hw_param_t var, unsigned int val,
  				 int dir)
***************
*** 526,532 ****
   * values != VAL. Reduce configuration space accordingly.
   *  Return VAL or -EINVAL if the configuration space is empty
   */
! static int snd_pcm_hw_param_set(struct snd_pcm_substream *pcm,
  				struct snd_pcm_hw_params *params,
  				snd_pcm_hw_param_t var, unsigned int val,
  				int dir)
--- 532,538 ----
   * values != VAL. Reduce configuration space accordingly.
   *  Return VAL or -EINVAL if the configuration space is empty
   */
! int snd_pcm_hw_param_set(struct snd_pcm_substream *pcm,
  				struct snd_pcm_hw_params *params,
  				snd_pcm_hw_param_t var, unsigned int val,
  				int dir)
***************
*** 542,548 ****
  	return snd_pcm_hw_param_value(params, var, NULL);
  }
  
! static int _snd_pcm_hw_param_setinteger(struct snd_pcm_hw_params *params,
  					snd_pcm_hw_param_t var)
  {
  	int changed;
--- 548,556 ----
  	return snd_pcm_hw_param_value(params, var, NULL);
  }
  
! EXPORT_SYMBOL_GPL(snd_pcm_hw_param_set);
! 
! int _snd_pcm_hw_param_setinteger(struct snd_pcm_hw_params *params,
  					snd_pcm_hw_param_t var)
  {
  	int changed;
***************
*** 554,559 ****
--- 562,569 ----
  	return changed;
  }
  	
+ EXPORT_SYMBOL_GPL(_snd_pcm_hw_param_setinteger);
+ 
  /*
   * plugin
   */
diff -rcN linux-sh4-2.6.23.17_stm23_0119-orig/sound//core/pcm.c linux-sh4/sound//core/pcm.c
*** linux-sh4-2.6.23.17_stm23_0119-orig/sound//core/pcm.c	2009-06-06 20:17:15.000000000 +0200
--- linux-sh4/sound//core/pcm.c	2009-07-18 20:39:02.000000000 +0200
***************
*** 43,49 ****
  static int snd_pcm_dev_register(struct snd_device *device);
  static int snd_pcm_dev_disconnect(struct snd_device *device);
  
! static struct snd_pcm *snd_pcm_get(struct snd_card *card, int device)
  {
  	struct snd_pcm *pcm;
  
--- 43,49 ----
  static int snd_pcm_dev_register(struct snd_device *device);
  static int snd_pcm_dev_disconnect(struct snd_device *device);
  
! static struct snd_pcm *snd_pcm_search(struct snd_card *card, int device)
  {
  	struct snd_pcm *pcm;
  
***************
*** 54,90 ****
  	return NULL;
  }
  
- static int snd_pcm_next(struct snd_card *card, int device)
- {
- 	struct snd_pcm *pcm;
- 
- 	list_for_each_entry(pcm, &snd_pcm_devices, list) {
- 		if (pcm->card == card && pcm->device > device)
- 			return pcm->device;
- 		else if (pcm->card->number > card->number)
- 			return -1;
- 	}
- 	return -1;
- }
- 
- static int snd_pcm_add(struct snd_pcm *newpcm)
- {
- 	struct snd_pcm *pcm;
- 
- 	list_for_each_entry(pcm, &snd_pcm_devices, list) {
- 		if (pcm->card == newpcm->card && pcm->device == newpcm->device)
- 			return -EBUSY;
- 		if (pcm->card->number > newpcm->card->number ||
- 				(pcm->card == newpcm->card &&
- 				pcm->device > newpcm->device)) {
- 			list_add(&newpcm->list, pcm->list.prev);
- 			return 0;
- 		}
- 	}
- 	list_add_tail(&newpcm->list, &snd_pcm_devices);
- 	return 0;
- }
- 
  static int snd_pcm_control_ioctl(struct snd_card *card,
  				 struct snd_ctl_file *control,
  				 unsigned int cmd, unsigned long arg)
--- 54,59 ----
***************
*** 97,103 ****
  			if (get_user(device, (int __user *)arg))
  				return -EFAULT;
  			mutex_lock(&register_mutex);
! 			device = snd_pcm_next(card, device);
  			mutex_unlock(&register_mutex);
  			if (put_user(device, (int __user *)arg))
  				return -EFAULT;
--- 66,79 ----
  			if (get_user(device, (int __user *)arg))
  				return -EFAULT;
  			mutex_lock(&register_mutex);
!  			device = device < 0 ? 0 : device + 1;
!  			while (device < SNDRV_PCM_DEVICES) {
!  				if (snd_pcm_search(card, device))
!  					break;
!  				device++;
!  			}
!  			if (device == SNDRV_PCM_DEVICES)
!  				device = -1;
  			mutex_unlock(&register_mutex);
  			if (put_user(device, (int __user *)arg))
  				return -EFAULT;
***************
*** 123,129 ****
  			if (get_user(subdevice, &info->subdevice))
  				return -EFAULT;
  			mutex_lock(&register_mutex);
! 			pcm = snd_pcm_get(card, device);
  			if (pcm == NULL) {
  				err = -ENXIO;
  				goto _error;
--- 99,105 ----
  			if (get_user(subdevice, &info->subdevice))
  				return -EFAULT;
  			mutex_lock(&register_mutex);
! 			pcm = snd_pcm_search(card, device);
  			if (pcm == NULL) {
  				err = -ENXIO;
  				goto _error;
***************
*** 968,978 ****
  
  	snd_assert(pcm != NULL && device != NULL, return -ENXIO);
  	mutex_lock(&register_mutex);
! 	err = snd_pcm_add(pcm);
! 	if (err) {
! 		mutex_unlock(&register_mutex);
! 		return err;
! 	}
  	for (cidx = 0; cidx < 2; cidx++) {
  		int devtype = -1;
  		if (pcm->streams[cidx].substream == NULL)
--- 944,954 ----
  
  	snd_assert(pcm != NULL && device != NULL, return -ENXIO);
  	mutex_lock(&register_mutex);
!  	if (snd_pcm_search(pcm->card, pcm->device)) {
!   		mutex_unlock(&register_mutex);
!  		return -EBUSY;
!   	}
!  	list_add_tail(&pcm->list, &snd_pcm_devices);
  	for (cidx = 0; cidx < 2; cidx++) {
  		int devtype = -1;
  		if (pcm->streams[cidx].substream == NULL)
diff -rcN linux-sh4-2.6.23.17_stm23_0119-orig/sound//core/pcm_lib.c linux-sh4/sound//core/pcm_lib.c
*** linux-sh4-2.6.23.17_stm23_0119-orig/sound//core/pcm_lib.c	2009-06-06 20:17:14.000000000 +0200
--- linux-sh4/sound//core/pcm_lib.c	2009-07-18 20:39:07.000000000 +0200
***************
*** 2128,2130 ****
--- 2128,2133 ----
  }
  
  EXPORT_SYMBOL(snd_pcm_lib_readv);
+ EXPORT_SYMBOL(snd_pcm_tick_prepare);
+ EXPORT_SYMBOL(snd_pcm_update_hw_ptr);
+ EXPORT_SYMBOL(snd_pcm_start);
diff -rcN linux-sh4-2.6.23.17_stm23_0119-orig/sound//core/pcm_native.c linux-sh4/sound//core/pcm_native.c
*** linux-sh4-2.6.23.17_stm23_0119-orig/sound//core/pcm_native.c	2007-10-09 22:31:38.000000000 +0200
--- linux-sh4/sound//core/pcm_native.c	2009-07-18 20:39:10.000000000 +0200
***************
*** 1932,1937 ****
--- 1932,1939 ----
  	return 0;
  }
  
+ EXPORT_SYMBOL_GPL(snd_pcm_hw_constraints_init);
+ 
  int snd_pcm_hw_constraints_complete(struct snd_pcm_substream *substream)
  {
  	struct snd_pcm_runtime *runtime = substream->runtime;
***************
*** 2008,2013 ****
--- 2010,2017 ----
  	return 0;
  }
  
+ EXPORT_SYMBOL_GPL(snd_pcm_hw_constraints_complete);
+ 
  static void pcm_release_private(struct snd_pcm_substream *substream)
  {
  	snd_pcm_unlink(substream);
diff -rcN linux-sh4-2.6.23.17_stm23_0119-orig/sound//core/sound.c linux-sh4/sound//core/sound.c
*** linux-sh4-2.6.23.17_stm23_0119-orig/sound//core/sound.c	2009-06-06 20:17:15.000000000 +0200
--- linux-sh4/sound//core/sound.c	2009-07-18 23:53:24.000000000 +0200
***************
*** 114,119 ****
--- 114,120 ----
  		return NULL;
  	mutex_lock(&sound_mutex);
  	mreg = snd_minors[minor];
+ 
  	if (mreg && mreg->type == type)
  		private_data = mreg->private_data;
  	else
***************
*** 273,278 ****
--- 274,280 ----
  
  EXPORT_SYMBOL(snd_register_device_for_dev);
  
+ 
  /* find the matching minor record
   * return the index of snd_minor, or -1 if not found
   */
***************
*** 282,287 ****
--- 284,290 ----
  	struct snd_minor *mptr;
  
  	cardnum = card ? card->number : -1;
+ 
  	for (minor = 0; minor < ARRAY_SIZE(snd_minors); ++minor)
  		if ((mptr = snd_minors[minor]) != NULL &&
  		    mptr->type == type &&
***************
*** 291,296 ****
--- 294,306 ----
  	return -1;
  }
  
+ int snd_get_minor(int type, int card, int dev)
+ {
+ 	return find_snd_minor(type, snd_cards[card], dev);
+ }
+ 
+ EXPORT_SYMBOL(snd_get_minor);
+ 
  /**
   * snd_unregister_device - unregister the device on the given card
   * @type: the device type, SNDRV_DEVICE_TYPE_XXX
diff -rcN linux-sh4-2.6.23.17_stm23_0119-orig/sound//stm/audio_outputs.c linux-sh4/sound//stm/audio_outputs.c
*** linux-sh4-2.6.23.17_stm23_0119-orig/sound//stm/audio_outputs.c	1970-01-01 01:00:00.000000000 +0100
--- linux-sh4/sound//stm/audio_outputs.c	2009-07-18 22:55:30.000000000 +0200
***************
*** 0 ****
--- 1,268 ----
+ /*
+  *   STx7200 System-on-Chip audio outputs control driver
+  *
+  *   Copyright (c) 2005-2007 STMicroelectronics Limited
+  *
+  *   Author: Pawel MOLL <pawel.moll@st.com>
+  *
+  *   This program is free software; you can redistribute it and/or modify
+  *   it under the terms of the GNU General Public License as published by
+  *   the Free Software Foundation; either version 2 of the License, or
+  *   (at your option) any later version.
+  *
+  *   This program is distributed in the hope that it will be useful,
+  *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+  *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  *   GNU General Public License for more details.
+  *
+  *   You should have received a copy of the GNU General Public License
+  *   along with this program; if not, write to the Free Software
+  *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+  *
+  */
+ 
+ #include <linux/init.h>
+ #include <linux/io.h>
+ #include <linux/platform_device.h>
+ #include <linux/stm/soc.h>
+ #include <linux/stm/registers.h>
+ #include <sound/driver.h>
+ #include <sound/core.h>
+ #include <sound/info.h>
+ 
+ #undef TRACE /* See common.h debug features */
+ #define MAGIC 1 /* See common.h debug features */
+ #include "common.h"
+ 
+ 
+ 
+ /*
+  * Audio control instance structure
+  */
+ 
+ struct snd_stm_audio_outputs {
+ 	struct resource *mem_region;
+ 
+ 	void *base;
+ 
+ 	struct snd_info_entry *proc_entry;
+ 
+ 	snd_stm_magic_field;
+ };
+ 
+ 
+ 
+ /*
+  * ALSA lowlevel device implementation
+  */
+ 
+ static void snd_stm_audio_outputs_dump_registers(struct snd_info_entry *entry,
+ 		struct snd_info_buffer *buffer)
+ {
+ 	struct snd_stm_audio_outputs *audio_outputs = entry->private_data;
+ 
+ 	snd_assert(audio_outputs, return);
+ 	snd_stm_magic_assert(audio_outputs, return);
+ 
+ #if defined(CONFIG_CPU_SUBTYPE_STB7100) || defined(CONFIG_CPU_SUBTYPE_STX7111)
+ 	snd_iprintf(buffer, "AUDCFG_IO_CTRL (offset 0x00) = 0x%08x\n",
+ 			REGISTER_PEEK(audio_outputs->base, AUDCFG_IO_CTRL));
+ #endif
+ #if defined(CONFIG_CPU_SUBTYPE_STX7200)
+ 	snd_iprintf(buffer, "AUDCFG_IOMUX_CTRL (offset 0x00) = 0x%08x\n",
+ 			REGISTER_PEEK(audio_outputs->base, AUDCFG_IOMUX_CTRL));
+ 	snd_iprintf(buffer, "AUDCFG_HDMI_CTRL (offset 0x04) = 0x%08x\n",
+ 			REGISTER_PEEK(audio_outputs->base, AUDCFG_HDMI_CTRL));
+ 	snd_iprintf(buffer, "AUDCFG_RECOVERY_CTRL (offset 0x08) = 0x%08x\n",
+ 			REGISTER_PEEK(audio_outputs->base,
+ 			AUDCFG_RECOVERY_CTRL));
+ #endif
+ }
+ 
+ static int snd_stm_audio_outputs_register(struct snd_device *snd_device)
+ {
+ 	struct snd_stm_audio_outputs *audio_outputs = snd_device->device_data;
+ 
+ 	snd_assert(audio_outputs, return -EINVAL);
+ 	snd_stm_magic_assert(audio_outputs, return -EINVAL);
+ 
+ 	/* Enable audio outputs */
+ 
+ #if defined(CONFIG_CPU_SUBTYPE_STB7100)
+ 	REGISTER_POKE(audio_outputs->base, AUDCFG_IO_CTRL,
+ 			REGFIELD_VALUE(AUDCFG_IO_CTRL, SPDIF_EN, ENABLE) |
+ 			REGFIELD_VALUE(AUDCFG_IO_CTRL, DATA1_EN, OUTPUT) |
+ 			REGFIELD_VALUE(AUDCFG_IO_CTRL, DATA0_EN, OUTPUT) |
+ 			REGFIELD_VALUE(AUDCFG_IO_CTRL, PCM_CLK_EN, OUTPUT));
+ #endif
+ #if defined(CONFIG_CPU_SUBTYPE_STX7111)
+ 	REGISTER_POKE(audio_outputs->base, AUDCFG_IO_CTRL,
+ 			REGFIELD_VALUE(AUDCFG_IO_CTRL, PCMPLHDMI_EN, OUTPUT) |
+ 			REGFIELD_VALUE(AUDCFG_IO_CTRL, SPDIFHDMI_EN, OUTPUT) |
+ 			REGFIELD_VALUE(AUDCFG_IO_CTRL, PCM_CLK_EN, OUTPUT));
+ #endif
+ #if defined(CONFIG_CPU_SUBTYPE_STX7200)
+ 	REGISTER_POKE(audio_outputs->base, AUDCFG_IOMUX_CTRL,
+ 			REGFIELD_VALUE(AUDCFG_IOMUX_CTRL, SPDIF_EN, ENABLE) |
+ 			REGFIELD_VALUE(AUDCFG_IOMUX_CTRL, DATA2_EN, OUTPUT) |
+ 			REGFIELD_VALUE(AUDCFG_IOMUX_CTRL, DATA1_EN, OUTPUT) |
+ 			REGFIELD_VALUE(AUDCFG_IOMUX_CTRL, DATA0_EN, OUTPUT) |
+ 			REGFIELD_VALUE(AUDCFG_IOMUX_CTRL, PCM_CLK_EN, OUTPUT));
+ #endif
+ 
+ 	/* Additional procfs info */
+ 
+ 	snd_stm_info_register(&audio_outputs->proc_entry, "audio_outputs",
+ 			snd_stm_audio_outputs_dump_registers, audio_outputs);
+ 
+ 	return 0;
+ }
+ 
+ static int snd_stm_audio_outputs_disconnect(struct snd_device *snd_device)
+ {
+ 	struct snd_stm_audio_outputs *audio_outputs = snd_device->device_data;
+ 
+ 	snd_assert(audio_outputs, return -EINVAL);
+ 	snd_stm_magic_assert(audio_outputs, return -EINVAL);
+ 
+ 	/* Remove procfs entry */
+ 
+ 	snd_stm_info_unregister(audio_outputs->proc_entry);
+ 
+ 	/* Disable audio outputs */
+ 
+ #if defined(CONFIG_CPU_SUBTYPE_STB7100)
+ 	REGISTER_POKE(audio_outputs->base, AUDCFG_IO_CTRL,
+ 			REGFIELD_VALUE(AUDCFG_IO_CTRL, SPDIF_EN, DISABLE) |
+ 			REGFIELD_VALUE(AUDCFG_IO_CTRL, DATA1_EN, INPUT) |
+ 			REGFIELD_VALUE(AUDCFG_IO_CTRL, DATA0_EN, INPUT) |
+ 			REGFIELD_VALUE(AUDCFG_IO_CTRL, PCM_CLK_EN, INPUT));
+ #endif
+ #if defined(CONFIG_CPU_SUBTYPE_STX7111)
+ 	REGISTER_POKE(audio_outputs->base, AUDCFG_IO_CTRL,
+ 			REGFIELD_VALUE(AUDCFG_IO_CTRL, PCMPLHDMI_EN, INPUT) |
+ 			REGFIELD_VALUE(AUDCFG_IO_CTRL, SPDIFHDMI_EN, INPUT) |
+ 			REGFIELD_VALUE(AUDCFG_IO_CTRL, PCM_CLK_EN, INPUT));
+ #endif
+ #if defined(CONFIG_CPU_SUBTYPE_STX7200)
+ 	REGISTER_POKE(audio_outputs->base, AUDCFG_IOMUX_CTRL,
+ 			REGFIELD_VALUE(AUDCFG_IOMUX_CTRL, SPDIF_EN, DISABLE) |
+ 			REGFIELD_VALUE(AUDCFG_IOMUX_CTRL, DATA2_EN, INPUT) |
+ 			REGFIELD_VALUE(AUDCFG_IOMUX_CTRL, DATA1_EN, INPUT) |
+ 			REGFIELD_VALUE(AUDCFG_IOMUX_CTRL, DATA0_EN, INPUT) |
+ 			REGFIELD_VALUE(AUDCFG_IOMUX_CTRL, PCM_CLK_EN, INPUT));
+ #endif
+ 
+ 	return 0;
+ }
+ 
+ static struct snd_device_ops snd_stm_audio_outputs_snd_device_ops = {
+ 	.dev_register = snd_stm_audio_outputs_register,
+ 	.dev_disconnect = snd_stm_audio_outputs_disconnect,
+ };
+ 
+ 
+ 
+ /*
+  * Platform driver routines
+  */
+ 
+ static int __init snd_stm_audio_outputs_probe(struct platform_device *pdev)
+ {
+ 	int result = 0;
+ 	struct snd_stm_audio_outputs *audio_outputs;
+ 	struct snd_card *card;
+ 
+ 	snd_printd("--- Probing device '%s'...\n", pdev->dev.bus_id);
+ 
+ 	audio_outputs = kzalloc(sizeof(*audio_outputs), GFP_KERNEL);
+ 	if (!audio_outputs) {
+ 		snd_stm_printe("Can't allocate memory "
+ 				"for a device description!\n");
+ 		result = -ENOMEM;
+ 		goto error_alloc;
+ 	}
+ 	snd_stm_magic_set(audio_outputs);
+ 
+ 	result = snd_stm_memory_request(pdev, &audio_outputs->mem_region,
+ 			&audio_outputs->base);
+ 	if (result < 0) {
+ 		snd_stm_printe("Memory region request failed!\n");
+ 		goto error_memory_request;
+ 	}
+ 
+ 	card = snd_stm_cards_default();
+ 	snd_assert(card, return -EINVAL);
+ 	snd_printd("Audio output controls will be a member of a card '%s'\n",
+ 		card->id);
+ 
+ 	/* Register HDMI route control */
+ 
+ 	/* TODO */
+ 
+ 
+ 	/* ALSA component */
+ 
+ 	result = snd_device_new(card, SNDRV_DEV_LOWLEVEL, audio_outputs,
+ 			&snd_stm_audio_outputs_snd_device_ops);
+ 	if (result < 0) {
+ 		snd_stm_printe("ALSA low level device creation failed!\n");
+ 		goto error_device;
+ 	}
+ 
+ 	/* Done now */
+ 
+ 	platform_set_drvdata(pdev, audio_outputs);
+ 
+ 	snd_printd("--- Probed successfully!\n");
+ 
+ 	return result;
+ 
+ error_device:
+ 	snd_stm_memory_release(audio_outputs->mem_region, audio_outputs->base);
+ error_memory_request:
+ 	snd_stm_magic_clear(audio_outputs);
+ 	kfree(audio_outputs);
+ error_alloc:
+ 	return result;
+ }
+ 
+ static int snd_stm_audio_outputs_remove(struct platform_device *pdev)
+ {
+ 	struct snd_stm_audio_outputs *audio_outputs =
+ 			platform_get_drvdata(pdev);
+ 
+ 	snd_assert(audio_outputs, return -EINVAL);
+ 	snd_stm_magic_assert(audio_outputs, return -EINVAL);
+ 
+ 	snd_stm_memory_release(audio_outputs->mem_region, audio_outputs->base);
+ 
+ 	snd_stm_magic_clear(audio_outputs);
+ 	kfree(audio_outputs);
+ 
+ 	return 0;
+ }
+ 
+ static struct platform_driver snd_stm_audio_outputs_driver = {
+ 	.driver = {
+ 		.name = "audio_outputs",
+ 	},
+ 	.probe = snd_stm_audio_outputs_probe,
+ 	.remove = snd_stm_audio_outputs_remove,
+ };
+ 
+ 
+ 
+ /*
+  * Initialization
+  */
+ 
+ int __init snd_stm_audio_outputs_init(void)
+ {
+ 	return platform_driver_register(&snd_stm_audio_outputs_driver);
+ }
+ 
+ void snd_stm_audio_outputs_cleanup(void)
+ {
+ 	platform_driver_unregister(&snd_stm_audio_outputs_driver);
+ }
diff -rcN linux-sh4-2.6.23.17_stm23_0119-orig/sound//stm/common.c linux-sh4/sound//stm/common.c
*** linux-sh4-2.6.23.17_stm23_0119-orig/sound//stm/common.c	2009-06-06 20:17:15.000000000 +0200
--- linux-sh4/sound//stm/common.c	2009-07-18 22:08:46.000000000 +0200
***************
*** 3,9 ****
   *
   *   Copyright (c) 2005-2007 STMicroelectronics Limited
   *
!  *   Author: Pawel Moll <pawel.moll@st.com>
   *
   *   This program is free software; you can redistribute it and/or modify
   *   it under the terms of the GNU General Public License as published by
--- 3,9 ----
   *
   *   Copyright (c) 2005-2007 STMicroelectronics Limited
   *
!  *   Author: Pawel MOLL <pawel.moll@st.com>
   *
   *   This program is free software; you can redistribute it and/or modify
   *   it under the terms of the GNU General Public License as published by
***************
*** 25,31 ****
  #include <linux/io.h>
  #include <linux/mm.h>
  #include <linux/platform_device.h>
- #include <linux/bpa2.h>
  #include <linux/stm/soc.h>
  #include <sound/driver.h>
  #include <sound/core.h>
--- 25,30 ----
***************
*** 34,40 ****
  #include <sound/pcm_params.h>
  #include <sound/asoundef.h>
  
! #define COMPONENT common
  #include "common.h"
  
  
--- 33,39 ----
  #include <sound/pcm_params.h>
  #include <sound/asoundef.h>
  
! #undef TRACE
  #include "common.h"
  
  
***************
*** 43,106 ****
   * Cards management
   */
  
! static struct snd_card *snd_stm_card;
! static int snd_stm_card_registered;
  
! struct snd_card *snd_stm_card_new(int index, const char *id,
! 		struct module *module)
  {
! 	snd_stm_assert(snd_stm_card == NULL, return NULL);
! 	snd_stm_assert(!snd_stm_card_registered, return NULL);
  
! 	snd_stm_card = snd_card_new(index, id, module, 0);
  
! 	return snd_stm_card;
! }
! EXPORT_SYMBOL(snd_stm_card_new);
  
! int snd_stm_card_register(void)
! {
! 	int result;
  
! 	snd_stm_assert(snd_stm_card != NULL, return -EINVAL);
! 	snd_stm_assert(!snd_stm_card_registered, return -EINVAL);
  
! 	result = snd_card_register(snd_stm_card);
  
! 	if (result == 0)
! 		snd_stm_card_registered = 1;
  
  	return result;
  }
- EXPORT_SYMBOL(snd_stm_card_register);
  
! int snd_stm_card_is_registered(void)
  {
! 	snd_stm_assert(snd_stm_card != NULL, return -EINVAL);
  
! 	return snd_stm_card_registered;
  }
- EXPORT_SYMBOL(snd_stm_card_is_registered);
  
! void snd_stm_card_free(void)
  {
! 	snd_stm_assert(snd_stm_card != NULL, return);
! 	snd_stm_assert(snd_stm_card_registered, return);
  
! 	snd_card_free(snd_stm_card);
  
! 	snd_stm_card_registered = 0;
! 	snd_stm_card = NULL;
  }
- EXPORT_SYMBOL(snd_stm_card_free);
  
! struct snd_card *snd_stm_card_get(void)
  {
! 	snd_stm_assert(snd_stm_card != NULL, return NULL);
! 
! 	return snd_stm_card;
  }
- EXPORT_SYMBOL(snd_stm_card_get);
  
  
  
--- 42,135 ----
   * Cards management
   */
  
! static struct snd_card *snd_stm_cards[SNDRV_CARDS];
! static struct snd_card *snd_stm_default;
  
! /* Card list initialization/cleanup */
! 
! int __init snd_stm_cards_init(const char *driver, struct snd_stm_card *cards,
! 		int num_cards)
  {
! 	int result = 0;
! 	int i;
  
! 	for (i = 0; i < num_cards; i++) {
! 		int card = cards[i].index;
  
! 		snd_stm_cards[card] = snd_card_new(card, cards[i].id,
! 				THIS_MODULE, 0);
! 		if (snd_stm_cards[card] == NULL) {
! 			snd_stm_cards_free();
! 			result = -ENOMEM;
! 			break;
! 		}
  
! 		if (snd_stm_default == NULL)
! 			snd_stm_default = snd_stm_cards[i];
  
! 		strcpy(snd_stm_cards[card]->driver, driver);
! 		strcpy(snd_stm_cards[card]->shortname, cards[i].short_name);
! 		strcpy(snd_stm_cards[card]->longname, cards[i].long_name);
! 
! 		snd_printd("Card %d ('%s') created:\n", card, cards[i].id);
! 		snd_printd("- driver: %s,\n", snd_stm_cards[card]->driver);
! 		snd_printd("- short name: %s,\n",
! 				snd_stm_cards[card]->shortname);
! 		snd_printd("- long name: %s.\n", snd_stm_cards[card]->longname);
! 	}
  
! 	return result;
! }
  
! int __init snd_stm_cards_register(void)
! {
! 	int result = -ENODEV;
! 	int i;
! 
! 	for (i = 0; i < SNDRV_CARDS; i++) {
! 		if (snd_stm_cards[i]) {
! 			result = snd_card_register(snd_stm_cards[i]);
! 			if (result < 0) {
! 				snd_stm_cards_free();
! 				break;
! 			}
! 		}
! 	}
  
  	return result;
  }
  
! void snd_stm_cards_free(void)
  {
! 	int i;
  
! 	for (i = 0; i < SNDRV_CARDS; i++) {
! 		if (snd_stm_cards[i]) {
! 			snd_card_free(snd_stm_cards[i]);
! 			snd_stm_cards[i] = NULL;
! 		}
! 	}
  }
  
! /* Card list access */
! 
! struct snd_card __init *snd_stm_cards_get(const char *id)
  {
! 	int i;
  
! 	for (i = 0; i < SNDRV_CARDS; i++)
! 		if (snd_stm_cards[i] &&
! 				strcmp(snd_stm_cards[i]->id, id) == 0)
! 			return snd_stm_cards[i];
  
! 	snd_stm_printe("Unknown card %s requested!\n", id);
! 	return NULL;
  }
  
! struct snd_card __init *snd_stm_cards_default(void)
  {
! 	return snd_stm_default;
  }
  
  
  
***************
*** 112,118 ****
  {
  }
  
! int snd_stm_add_platform_devices(struct platform_device **devices,
  		int cnt)
  {
  	int result = 0;
--- 141,147 ----
  {
  }
  
! int __init snd_stm_add_plaform_devices(struct platform_device **devices,
  		int cnt)
  {
  	int result = 0;
***************
*** 130,138 ****
  
  	return result;
  }
- EXPORT_SYMBOL(snd_stm_add_platform_devices);
  
! void snd_stm_remove_platform_devices(struct platform_device **devices,
  		int cnt)
  {
  	int i;
--- 159,166 ----
  
  	return result;
  }
  
! void __exit snd_stm_remove_plaform_devices(struct platform_device **devices,
  		int cnt)
  {
  	int i;
***************
*** 140,146 ****
  	for (i = 0; i < cnt; i++)
  		platform_device_unregister(devices[i]);
  }
! EXPORT_SYMBOL(snd_stm_remove_platform_devices);
  
  
  
--- 168,187 ----
  	for (i = 0; i < cnt; i++)
  		platform_device_unregister(devices[i]);
  }
! 
! static int snd_stm_bus_id_match(struct device *device, void *bus_id)
! {
! 	return strcmp(device->bus_id, bus_id) == 0;
! }
! 
! struct device *snd_stm_find_device(struct bus_type *bus,
! 		const char *bus_id)
! {
! 	if (bus == NULL)
! 		bus = &platform_bus_type;
! 	return bus_find_device(bus, NULL, (void *)bus_id, snd_stm_bus_id_match);
! }
! 
  
  
  
***************
*** 148,154 ****
   * Resources management
   */
  
! int snd_stm_memory_request(struct platform_device *pdev,
  		struct resource **mem_region, void **base_address)
  {
  	struct resource *resource;
--- 189,195 ----
   * Resources management
   */
  
! int __init snd_stm_memory_request(struct platform_device *pdev,
  		struct resource **mem_region, void **base_address)
  {
  	struct resource *resource;
***************
*** 169,175 ****
  				pdev->name);
  		return -EBUSY;
  	}
! 	snd_stm_printd(0, "Memory region: 0x%08x-0x%08x\n",
  			(*mem_region)->start, (*mem_region)->end);
  
  	*base_address = ioremap(resource->start,
--- 210,216 ----
  				pdev->name);
  		return -EBUSY;
  	}
! 	snd_printd("Memory region: 0x%08x-0x%08x\n",
  			(*mem_region)->start, (*mem_region)->end);
  
  	*base_address = ioremap(resource->start,
***************
*** 192,200 ****
  	iounmap(base_address);
  	release_resource(mem_region);
  }
- EXPORT_SYMBOL(snd_stm_memory_release);
  
! int snd_stm_irq_request(struct platform_device *pdev,
  		unsigned int *irq, irq_handler_t handler, void *dev_id)
  {
  	struct resource *resource;
--- 232,239 ----
  	iounmap(base_address);
  	release_resource(mem_region);
  }
  
! int  __init snd_stm_irq_request(struct platform_device *pdev,
  		unsigned int *irq, irq_handler_t handler, void *dev_id)
  {
  	struct resource *resource;
***************
*** 206,212 ****
  				"platform_get_resource(IORESOURCE_IRQ)!\n");
  		return -ENODEV;
  	}
! 	snd_stm_printd(0, "IRQ: %u\n", resource->start);
  
  	*irq = resource->start;
  
--- 245,251 ----
  				"platform_get_resource(IORESOURCE_IRQ)!\n");
  		return -ENODEV;
  	}
! 	snd_printd("IRQ: %u\n", resource->start);
  
  	*irq = resource->start;
  
***************
*** 216,230 ****
  		return -EINVAL;
  	}
  
- 	/* request_irq() enables the interrupt immediately; as it is
- 	 * lethal in concurrent audio environment, we want to have
- 	 * it disabled for most of the time... */
- 	disable_irq(*irq);
- 
  	return 0;
  }
  
! int snd_stm_fdma_request(struct platform_device *pdev, int *channel)
  {
  	static const char *fdmac_id[] = { STM_DMAC_ID, NULL };
  	static const char *fdma_cap_lb[] = { STM_DMA_CAP_LOW_BW, NULL };
--- 255,265 ----
  		return -EINVAL;
  	}
  
  	return 0;
  }
  
! int __init snd_stm_fdma_request(struct platform_device *pdev,
! 		unsigned int *channel)
  {
  	static const char *fdmac_id[] = { STM_DMAC_ID, NULL };
  	static const char *fdma_cap_lb[] = { STM_DMA_CAP_LOW_BW, NULL };
***************
*** 239,245 ****
  			return -ENODEV;
  		}
  	}
! 	snd_stm_printd(0, "FDMA channel: %d\n", *channel);
  
  	return 0;
  }
--- 274,280 ----
  			return -ENODEV;
  		}
  	}
! 	snd_printd("FDMA channel: %d\n", *channel);
  
  	return 0;
  }
***************
*** 252,258 ****
  
  static struct snd_info_entry *snd_stm_info_root;
  
! int snd_stm_info_create(void)
  {
  	int result = 0;
  
--- 287,293 ----
  
  static struct snd_info_entry *snd_stm_info_root;
  
! int __init snd_stm_info_init(void)
  {
  	int result = 0;
  
***************
*** 271,277 ****
  	return result;
  }
  
! void snd_stm_info_dispose(void)
  {
  	if (snd_stm_info_root)
  		snd_info_free_entry(snd_stm_info_root);
--- 306,312 ----
  	return result;
  }
  
! void snd_stm_info_cleanup(void)
  {
  	if (snd_stm_info_root)
  		snd_info_free_entry(snd_stm_info_root);
***************
*** 284,293 ****
  {
  	int result = 0;
  
- 	/* Skip the "snd_" prefix, if bus_id has been simply given */
- 	if (strncmp(name, "snd_", 4) == 0)
- 		name += 4;
- 
  	*entry = snd_info_create_module_entry(THIS_MODULE, name,
  			snd_stm_info_root);
  	if (*entry) {
--- 319,324 ----
***************
*** 302,511 ****
  	}
  	return result;
  }
- EXPORT_SYMBOL(snd_stm_info_register);
  
  void snd_stm_info_unregister(struct snd_info_entry *entry)
  {
  	if (entry)
  		snd_info_free_entry(entry);
  }
- EXPORT_SYMBOL(snd_stm_info_unregister);
  
  
  
  /*
!  * PCM buffer memory management
   */
  
! struct snd_stm_buffer {
! 	struct snd_pcm *pcm;
! 
! 	struct bpa2_part *bpa2_part;
! 
! 	int allocated;
! 	struct snd_pcm_substream *substream;
! 
! 	snd_stm_magic_field;
! };
! 
! #if defined(CONFIG_BPA2)
! static char *bpa2_part = CONFIG_SND_STM_BPA2_PARTITION_NAME;
! #else
! static char *bpa2_part = "";
! #endif
! module_param(bpa2_part, charp, S_IRUGO);
! 
! struct snd_stm_buffer *snd_stm_buffer_create(struct snd_pcm *pcm,
! 		struct device *device, int prealloc_size)
! {
! 	struct snd_stm_buffer *buffer;
! 
! 	snd_stm_printd(1, "snd_stm_buffer_init(pcm=%p, prealloc_size=%d)\n",
! 			pcm, prealloc_size);
! 
! 	snd_stm_assert(pcm, return NULL);
! 
! 	buffer = kzalloc(sizeof(*buffer), GFP_KERNEL);
! 	if (!buffer) {
! 		snd_stm_printe("Can't allocate memory for a buffer "
! 				"description!\n");
! 		return NULL;
! 	}
! 	snd_stm_magic_set(buffer);
! 	buffer->pcm = pcm;
! 
! #if defined(CONFIG_BPA2)
! 	buffer->bpa2_part = bpa2_find_part(bpa2_part);
! 	if (buffer->bpa2_part) {
! 		snd_stm_printd(0, "Using BPA2 partition '%s'...\n", bpa2_part);
! 		return buffer;
! 	}
! 
! 	buffer->bpa2_part = bpa2_find_part("bigphysarea");
! 	if (buffer->bpa2_part) {
! 		snd_stm_printd(0, "Using legacy 'bigphysarea' BPA2 "
! 				"partition...\n");
! 		return buffer;
! 	}
! #endif
! 
! 	if (snd_pcm_lib_preallocate_pages_for_all(pcm,
! 			SNDRV_DMA_TYPE_DEV, device,
! 			prealloc_size, prealloc_size) == 0) {
! 		snd_stm_printd(0, "Using pcm_lib's preallocated buffer "
! 				"(%d bytes)...\n", prealloc_size);
! 		return buffer;
! 	}
! 
! 	snd_stm_printe("Can't provide any memory for buffers!\n");
! 	kfree(buffer);
! 	return NULL;
! }
! 
! void snd_stm_buffer_dispose(struct snd_stm_buffer *buffer)
! {
! 	snd_stm_printd(1, "snd_stm_buffer_dispose(buffer=%p)\n", buffer);
! 
! 	snd_stm_assert(buffer, return);
! 	snd_stm_magic_assert(buffer, return);
! 	snd_stm_assert(!buffer->allocated, return);
! 
! 	/* snd_pcm_lib__preallocate*-ed buffer is freed automagically */
! 
! 	snd_stm_magic_clear(buffer);
! 	kfree(buffer);
! }
! 
! inline int snd_stm_buffer_is_allocated(struct snd_stm_buffer *buffer)
! {
! 	snd_stm_printd(1, "snd_stm_buffer_is_allocated(buffer=%p)\n",
! 			buffer);
! 
! 	snd_stm_assert(buffer, return -EINVAL);
! 	snd_stm_magic_assert(buffer, return -EINVAL);
! 
! 	return buffer->allocated;
! }
! 
! int snd_stm_buffer_alloc(struct snd_stm_buffer *buffer,
! 		struct snd_pcm_substream *substream, int size)
! {
! 	snd_stm_printd(1, "snd_stm_buffer_alloc(buffer=%p, substream=%p, "
! 			"size=%d)\n", buffer, substream, size);
! 
! 	snd_stm_assert(buffer, return -EINVAL);
! 	snd_stm_magic_assert(buffer, return -EINVAL);
! 	snd_stm_assert(!buffer->allocated, return -EINVAL);
! 	snd_stm_assert(size > 0, return -EINVAL);
! 
! 	if (buffer->bpa2_part) {
! #if defined(CONFIG_BPA2)
! 		struct snd_pcm_runtime *runtime = substream->runtime;
! 		int pages = (size + PAGE_SIZE - 1) / PAGE_SIZE;
! 
! 		runtime->dma_addr = bpa2_alloc_pages(buffer->bpa2_part, pages,
! 				0, GFP_KERNEL);
! 		if (runtime->dma_addr == 0) {
! 			snd_stm_printe("Can't get %d pages from BPA2!\n",
! 					pages);
! 			return -ENOMEM;
! 		}
! 		runtime->dma_bytes = size;
! 		runtime->dma_area = ioremap_nocache(runtime->dma_addr, size);
! #else
! 		snd_BUG();
! #endif
! 	} else {
! 		if (snd_pcm_lib_malloc_pages(substream, size) < 0) {
! 			snd_stm_printe("Can't allocate pages using pcm_lib!\n");
! 			return -ENOMEM;
! 		}
! 		/* runtime->dma_* are set by snd_pcm_lib_malloc_pages()
! 		 * (by snd_pcm_set_runtime_buffer() to be more specific.) */
! 	}
! 
! 	snd_stm_printd(1, "Allocated memory: dma_addr=0x%08x, dma_area=0x%p, "
! 			"dma_bytes=%u\n", substream->runtime->dma_addr,
! 			substream->runtime->dma_area,
! 			substream->runtime->dma_bytes);
! 
! 	buffer->substream = substream;
! 	buffer->allocated = 1;
! 
! 	return 0;
! }
! 
! void snd_stm_buffer_free(struct snd_stm_buffer *buffer)
! {
! 	struct snd_pcm_runtime *runtime;
! 
! 	snd_stm_printd(1, "snd_stm_buffer_free(buffer=%p)\n", buffer);
! 
! 	snd_stm_assert(buffer, return);
! 	snd_stm_magic_assert(buffer, return);
! 	snd_stm_assert(buffer->allocated, return);
! 
! 	runtime = buffer->substream->runtime;
! 
! 	snd_stm_printd(1, "Freeing dma_addr=0x%08x, dma_area=0x%p, "
! 			"dma_bytes=%u\n", runtime->dma_addr,
! 			runtime->dma_area, runtime->dma_bytes);
! 
! 	if (buffer->bpa2_part) {
! #if defined(CONFIG_BPA2)
! 		iounmap(runtime->dma_area);
! 
! 		bpa2_free_pages(buffer->bpa2_part, runtime->dma_addr);
! 		runtime->dma_area = NULL;
! 		runtime->dma_addr = 0;
! 		runtime->dma_bytes = 0;
! #else
! 		snd_BUG();
! #endif
! 	} else {
! 		snd_pcm_lib_free_pages(buffer->substream);
! 		/* runtime->dma_* are cleared by snd_pcm_lib_free_pages()
! 		 * (by snd_pcm_set_runtime_buffer() to be more specific.) */
! 	}
! 
! 	buffer->allocated = 0;
! 	buffer->substream = NULL;
! }
! 
! static struct page *snd_stm_buffer_mmap_nopage(struct vm_area_struct *area,
  		unsigned long address, int *type)
  {
  	/* No VMA expanding here! */
  	return NOPAGE_SIGBUS;
  }
  
! static struct vm_operations_struct snd_stm_buffer_mmap_vm_ops = {
  	.open =   snd_pcm_mmap_data_open,
  	.close =  snd_pcm_mmap_data_close,
! 	.nopage = snd_stm_buffer_mmap_nopage,
  };
  
! int snd_stm_buffer_mmap(struct snd_pcm_substream *substream,
  		struct vm_area_struct *area)
  {
  	struct snd_pcm_runtime *runtime = substream->runtime;
--- 333,365 ----
  	}
  	return result;
  }
  
  void snd_stm_info_unregister(struct snd_info_entry *entry)
  {
  	if (entry)
  		snd_info_free_entry(entry);
  }
  
  
  
  /*
!  * ALSA PCM buffer memory mapping
   */
  
! static struct page *snd_stm_mmap_nopage(struct vm_area_struct *area,
  		unsigned long address, int *type)
  {
  	/* No VMA expanding here! */
  	return NOPAGE_SIGBUS;
  }
  
! static struct vm_operations_struct snd_stm_mmap_vm_ops = {
  	.open =   snd_pcm_mmap_data_open,
  	.close =  snd_pcm_mmap_data_close,
! 	.nopage = snd_stm_mmap_nopage,
  };
  
! int snd_stm_mmap(struct snd_pcm_substream *substream,
  		struct vm_area_struct *area)
  {
  	struct snd_pcm_runtime *runtime = substream->runtime;
***************
*** 515,524 ****
  	unsigned long phys_size = runtime->dma_bytes + PAGE_SIZE -
  			runtime->dma_bytes % PAGE_SIZE;
  
! 	snd_stm_printd(1, "snd_stm_buffer_mmap(substream=%p, area=%p)\n",
! 			substream, area);
  
! 	snd_stm_printd(1, "Mmaping %lu bytes starting from 0x%08lx "
  			"(dma_addr=0x%08x, dma_size=%u, vm_pgoff=%lu, "
  			"vm_start=0x%lx, vm_end=0x%lx)...\n", map_size,
  			phys_addr, runtime->dma_addr, runtime->dma_bytes,
--- 369,378 ----
  	unsigned long phys_size = runtime->dma_bytes + PAGE_SIZE -
  			runtime->dma_bytes % PAGE_SIZE;
  
! 	snd_stm_printt("snd_stm_pcm_mmap(substream=0x%p)\n",
! 			substream);
  
! 	snd_stm_printt("Mmaping %lu bytes starting from 0x%08lx "
  			"(dma_addr=0x%08x, dma_size=%u, vm_pgoff=%lu, "
  			"vm_start=0x%lx, vm_end=0x%lx)...\n", map_size,
  			phys_addr, runtime->dma_addr, runtime->dma_bytes,
***************
*** 529,535 ****
  		return -EINVAL;
  	}
  
! 	area->vm_ops = &snd_stm_buffer_mmap_vm_ops;
  	area->vm_private_data = substream;
  	area->vm_flags |= VM_RESERVED;
  	area->vm_page_prot = pgprot_noncached(area->vm_page_prot);
--- 383,389 ----
  		return -EINVAL;
  	}
  
! 	area->vm_ops = &snd_stm_mmap_vm_ops;
  	area->vm_private_data = substream;
  	area->vm_flags |= VM_RESERVED;
  	area->vm_page_prot = pgprot_noncached(area->vm_page_prot);
***************
*** 557,570 ****
  #define FIXED_TRANSFER_BYTES max_transfer_bytes
  */
  
! #if defined(FIXED_TRANSFER_BYTES)
  
  int snd_stm_pcm_transfer_bytes(unsigned int bytes_per_frame,
  		unsigned int max_transfer_bytes)
  {
  	int transfer_bytes = FIXED_TRANSFER_BYTES;
  
! 	snd_stm_printd(1, "snd_stm_pcm_transfer_bytes(bytes_per_frame=%u, "
  			"max_transfer_bytes=%u) = %u (FIXED)\n",
  			bytes_per_frame, max_transfer_bytes, transfer_bytes);
  
--- 411,424 ----
  #define FIXED_TRANSFER_BYTES max_transfer_bytes
  */
  
! #ifdef FIXED_TRANSFER_BYTES
  
  int snd_stm_pcm_transfer_bytes(unsigned int bytes_per_frame,
  		unsigned int max_transfer_bytes)
  {
  	int transfer_bytes = FIXED_TRANSFER_BYTES;
  
! 	snd_stm_printt("snd_stm_pcm_transfer_bytes(bytes_per_frame=%u, "
  			"max_transfer_bytes=%u) = %u (FIXED)\n",
  			bytes_per_frame, max_transfer_bytes, transfer_bytes);
  
***************
*** 591,597 ****
  			transfer_bytes *= 2)
  		;
  
! 	snd_stm_printd(2, "snd_stm_pcm_transfer_bytes(bytes_per_frame=%u, "
  			"max_transfer_bytes=%u) = %u\n", bytes_per_frame,
  			max_transfer_bytes, transfer_bytes);
  
--- 445,451 ----
  			transfer_bytes *= 2)
  		;
  
! 	snd_stm_printt("snd_stm_pcm_transfer_bytes(bytes_per_frame=%u, "
  			"max_transfer_bytes=%u) = %u\n", bytes_per_frame,
  			max_transfer_bytes, transfer_bytes);
  
***************
*** 661,667 ****
  
  	return 0;
  }
- EXPORT_SYMBOL(snd_stm_ctl_boolean_info);
  
  int snd_stm_ctl_iec958_info(struct snd_kcontrol *kcontrol,
  		struct snd_ctl_elem_info *uinfo)
--- 515,520 ----
***************
*** 714,721 ****
  {
  	int result;
  
! 	snd_stm_assert(a != NULL, return -EINVAL);
! 	snd_stm_assert(b != NULL, return -EINVAL);
  
  	result = memcmp(a->status, b->status, sizeof(a->status));
  	if (result == 0)
--- 567,574 ----
  {
  	int result;
  
! 	snd_assert(a != NULL, return -EINVAL);
! 	snd_assert(b != NULL, return -EINVAL);
  
  	result = memcmp(a->status, b->status, sizeof(a->status));
  	if (result == 0)
diff -urN linux-sh4-2.6.23.17_stm23_0119-orig/sound//stm/common.h linux-sh4/sound//stm/common.h
--- linux-sh4-2.6.23.17_stm23_0119-orig/sound//stm/common.h	2009-06-06 20:17:15.000000000 +0200
+++ linux-sh4/sound//stm/common.h	2009-07-18 22:02:28.000000000 +0200
@@ -5,11 +5,9 @@
 #ifndef __SOUND_STM_COMMON_H
 #define __SOUND_STM_COMMON_H
 
-#include <linux/kernel.h>
 #include <linux/interrupt.h>
 #include <linux/mm.h>
 #include <linux/platform_device.h>
-#include <linux/stringify.h>
 #include <linux/stm/soc.h>
 #include <linux/stm/stm-dma.h>
 #include <sound/driver.h>
@@ -22,64 +20,38 @@
 
 
 /*
- * Frequency synthesizers control interface
+ * Audio frequency synthesizer description (platform data)
  */
 
-struct snd_stm_fsynth_channel;
-
-struct snd_stm_fsynth_channel *snd_stm_fsynth_get_channel(const char *bus_id,
-		int output);
+struct snd_stm_fsynth_info {
+	const char *card_id;
 
-int snd_stm_fsynth_add_adjustement_ctl(
-		struct snd_stm_fsynth_channel *fsynth_channel,
-		struct snd_card *card, int card_device);
+	int channels_from, channels_to;
+};
 
-int snd_stm_fsynth_set_frequency(struct snd_stm_fsynth_channel *fsynth_channel,
+int snd_stm_fsynth_set_frequency(struct device *device, int channel,
 		int frequency);
 
+int snd_stm_fsynth_add_adjustement_ctl(struct device *device, int channel,
+		struct snd_card *card, int card_device);
+
 
 
 /*
  * Converters (DAC, ADC, I2S-SPDIF etc.) control interface
  */
 
-struct snd_stm_conv_source;
-struct snd_stm_conv_group;
-struct snd_stm_conv_converter;
-
-struct snd_stm_conv_source *snd_stm_conv_register_source(struct bus_type *bus,
-		const char *bus_id, int channels_num,
+struct snd_stm_conv *snd_stm_conv_get_attached(struct device *source);
+int snd_stm_conv_add_route_ctl(struct device *source,
 		struct snd_card *card, int card_device);
-int snd_stm_conv_unregister_source(struct snd_stm_conv_source *source);
 
-int snd_stm_conv_get_card_device(struct snd_stm_conv_converter *converter);
+unsigned int snd_stm_conv_get_format(struct snd_stm_conv *conv);
+int snd_stm_conv_get_oversampling(struct snd_stm_conv *conv);
 
-struct snd_stm_conv_group *snd_stm_conv_request_group(
-		struct snd_stm_conv_source *source);
-int snd_stm_conv_release_group(struct snd_stm_conv_group *group);
-
-const char *snd_stm_conv_get_name(struct snd_stm_conv_group *group);
-unsigned int snd_stm_conv_get_format(struct snd_stm_conv_group *group);
-int snd_stm_conv_get_oversampling(struct snd_stm_conv_group *group);
-
-int snd_stm_conv_enable(struct snd_stm_conv_group *group,
-		int channel_from, int channel_to);
-int snd_stm_conv_disable(struct snd_stm_conv_group *group);
-int snd_stm_conv_mute(struct snd_stm_conv_group *group);
-int snd_stm_conv_unmute(struct snd_stm_conv_group *group);
-
-
-
-/*
- * Audio frequency synthesizer description (platform data)
- */
-
-struct snd_stm_fsynth_info {
-	int channels_from, channels_to;
-	int no_fs_en; /* Set if FS_EN bits are not to be set */
-	int value_pcm_clk_sel; /* PCM_CLK_SEL "use fsynth clock" value */
-	int value_ref_clk_in; /* REF_CLK_IN "use 30Mhz clock" value */
-};
+int snd_stm_conv_enable(struct snd_stm_conv *conv);
+int snd_stm_conv_disable(struct snd_stm_conv *conv);
+int snd_stm_conv_mute(struct snd_stm_conv *conv);
+int snd_stm_conv_unmute(struct snd_stm_conv *conv);
 
 
 
@@ -87,11 +59,13 @@
  * Internal audio DAC description (platform data)
  */
 
-struct snd_stm_conv_int_dac_info {
-	int ver;
+struct snd_stm_conv_internal_dac_info {
+	const char *name;
+
+	const char *card_id;
+	int card_device;
 
 	const char *source_bus_id;
-	int channel_from, channel_to;
 };
 
 
@@ -99,11 +73,15 @@
  * I2S to SPDIF converter description (platform data)
  */
 
-struct snd_stm_conv_i2sspdif_info {
-	int ver;
+struct snd_stm_conv_i2s_spdif_info {
+	const char *name;
+
+	const char *card_id;
+	int card_device;
 
 	const char *source_bus_id;
-	int channel_from, channel_to;
+
+	int full_channel_status;
 };
 
 
@@ -114,16 +92,21 @@
 
 struct snd_stm_pcm_player_info {
 	const char *name;
-	int ver;
 
+	const char *card_id;
 	int card_device;
+
 	const char *fsynth_bus_id;
 	int fsynth_output;
 
-	unsigned int channels;
+	unsigned int channels_num;
+	unsigned int *channels;
 
 	unsigned char fdma_initiator;
 	unsigned int fdma_request_line;
+	int fdma_max_transfer_size;
+
+	int invert_sclk_edge_falling;
 };
 
 
@@ -134,14 +117,16 @@
 
 struct snd_stm_pcm_reader_info {
 	const char *name;
-	int ver;
 
+	const char *card_id;
 	int card_device;
 
-	int channels;
+	int channels_num;
+	int *channels;
 
 	unsigned char fdma_initiator;
 	unsigned int fdma_request_line;
+	int fdma_max_transfer_size;
 };
 
 
@@ -152,35 +137,25 @@
 
 struct snd_stm_spdif_player_info {
 	const char *name;
-	int ver;
 
+	const char *card_id;
 	int card_device;
+
 	const char *fsynth_bus_id;
 	int fsynth_output;
 
 	unsigned char fdma_initiator;
 	unsigned int fdma_request_line;
+	int fdma_max_transfer_size;
 };
 
 
 
 /*
- * PCM buffer memory management
+ * Buffer memory mapping operation
  */
 
-struct snd_stm_buffer;
-
-struct snd_stm_buffer *snd_stm_buffer_create(struct snd_pcm *pcm,
-		struct device *device, int prealloc_size);
-void snd_stm_buffer_dispose(struct snd_stm_buffer *buffer);
-
-int snd_stm_buffer_is_allocated(struct snd_stm_buffer *buffer);
-
-int snd_stm_buffer_alloc(struct snd_stm_buffer *buffer,
-		struct snd_pcm_substream *substream, int size);
-void snd_stm_buffer_free(struct snd_stm_buffer *buffer);
-
-int snd_stm_buffer_mmap(struct snd_pcm_substream *substream,
+int snd_stm_mmap(struct snd_pcm_substream *substream,
 		struct vm_area_struct *area);
 
 
@@ -222,24 +197,41 @@
  */
 
 /* Add/remove a list of platform devices */
-int snd_stm_add_platform_devices(struct platform_device **devices,
+int __init snd_stm_add_plaform_devices(struct platform_device **devices,
 		int cnt);
-void snd_stm_remove_platform_devices(struct platform_device **devices,
+void __exit snd_stm_remove_plaform_devices(struct platform_device **devices,
 		int cnt);
 
+/* Leave bus NULL to use default (platform) bus */
+struct device *snd_stm_find_device(struct bus_type *bus,
+		const char *bus_id);
+
 
 
 /*
- * ALSA card management
+ * Components management
  */
 
-struct snd_card *snd_stm_card_new(int index, const char *id,
-		struct module *module);
-int snd_stm_card_register(void);
-int snd_stm_card_is_registered(void);
-void snd_stm_card_free(void);
+/* Card description */
+
+struct snd_stm_card {
+	int index;              /* card number */
+	const char *id;         /* unique, 15 chars max (plus '\0' as 16th) */
+	const char *short_name; /* 31 chars max (plus '\0' as 32nd) */
+	const char *long_name;  /* 79 chars max (plus '\0' as 80th) */
+};
+
+/* Card list initialization/cleanup */
+
+int __init snd_stm_cards_init(const char *device, struct snd_stm_card *cards,
+		int num_cards);
+int __init snd_stm_cards_register(void);
+void snd_stm_cards_free(void);
 
-struct snd_card *snd_stm_card_get(void);
+/* Card list access */
+
+struct snd_card __init *snd_stm_cards_get(const char *id);
+struct snd_card __init *snd_stm_cards_default(void);
 
 
 
@@ -247,8 +239,8 @@
  * ALSA procfs additional entries
  */
 
-int snd_stm_info_create(void);
-void snd_stm_info_dispose(void);
+int __init snd_stm_info_init(void);
+void snd_stm_info_cleanup(void);
 
 int snd_stm_info_register(struct snd_info_entry **entry,
 		const char *name,
@@ -262,47 +254,67 @@
  * Resources management
  */
 
-int snd_stm_memory_request(struct platform_device *pdev,
+int __init snd_stm_memory_request(struct platform_device *pdev,
 		struct resource **mem_region, void **base_address);
 void snd_stm_memory_release(struct resource *mem_region,
 		void *base_address);
 
-int snd_stm_irq_request(struct platform_device *pdev,
+int __init snd_stm_irq_request(struct platform_device *pdev,
 		unsigned int *irq, irq_handler_t handler, void *dev_id);
 #define snd_stm_irq_release(irq, dev_id) free_irq(irq, dev_id)
 
-int snd_stm_fdma_request(struct platform_device *pdev, int *channel);
+int __init snd_stm_fdma_request(struct platform_device *pdev,
+		unsigned int *channel);
 #define snd_stm_fdma_release(channel) free_dma(channel)
 
 
 
 /*
- * Core drivers initialization/exit
+ * Drivers initialization/cleanup
  */
 
-int snd_stm_fsynth_init(void);
-void snd_stm_fsynth_exit(void);
+#if defined(CONFIG_CPU_SUBTYPE_STB7100)
+int __init snd_stm_stx7100_init(void);
+void __exit snd_stm_stx7100_cleanup(void);
+#endif
+#if defined(CONFIG_CPU_SUBTYPE_STX7111)
+int __init snd_stm_stx7111_init(void);
+void __exit snd_stm_stx7111_cleanup(void);
+#endif
+#if defined(CONFIG_CPU_SUBTYPE_STX7200)
+int __init snd_stm_stx7200_init(void);
+void __exit snd_stm_stx7200_cleanup(void);
+#endif
 
-int snd_stm_conv_init(void);
-void snd_stm_conv_exit(void);
+int __init snd_stm_audio_outputs_init(void);
+void snd_stm_audio_outputs_cleanup(void);
 
-int snd_stm_conv_int_dac_init(void);
-void snd_stm_conv_int_dac_exit(void);
+int __init snd_stm_fsynth_init(void);
+void snd_stm_fsynth_cleanup(void);
 
-int snd_stm_conv_i2sspdif_init(void);
-void snd_stm_conv_i2sspdif_exit(void);
+int __init snd_stm_conv_init(void);
+void snd_stm_conv_cleanup(void);
 
-int snd_stm_pcm_player_init(void);
-void snd_stm_pcm_player_exit(void);
+int __init snd_stm_conv_dummy_init(void);
+void snd_stm_conv_dummy_cleanup(void);
 
-int snd_stm_pcm_reader_init(void);
-void snd_stm_pcm_reader_exit(void);
+int __init snd_stm_conv_internal_dac_init(void);
+void snd_stm_conv_internal_dac_cleanup(void);
 
-int snd_stm_spdif_player_init(void);
-void snd_stm_spdif_player_exit(void);
+int __init snd_stm_conv_i2s_spdif_init(void);
+void snd_stm_conv_i2s_spdif_cleanup(void);
 
-int snd_stm_synchro_init(void);
-void snd_stm_synchro_exit(void);
+int __init snd_stm_pcm_player_init(void);
+void snd_stm_pcm_player_cleanup(void);
+
+int __init snd_stm_pcm_reader_init(void);
+void snd_stm_pcm_reader_cleanup(void);
+
+int __init snd_stm_spdif_player_init(void);
+void snd_stm_spdif_player_cleanup(void);
+
+int __init snd_stm_synchro_init(void);
+void snd_stm_synchro_cleanup(void);
 
 
 
@@ -315,111 +327,66 @@
 void snd_stm_hex_dump(void *data, int size);
 void snd_stm_iec958_dump(const struct snd_aes_iec958 *vuc);
 
-/* Component name */
-
-#if !defined(COMPONENT)
-#error Please define COMPONENT name before including "common.h" !
-#endif
-static const char __maybe_unused *__snd_stm_component = __stringify(COMPONENT);
 
-/* Debug messages */
 
-#if defined(CONFIG_SND_DEBUG) || defined(DEBUG)
+/* Trace debug messages
+ * - even more debugs than with CONFIG_SND_DEBUG ;-)
+ * - enables snd_printd when CONFIG_SND_DEBUG is not defined :-)
+ * - define TRACE _before_ including common.h to enable in selected
+ *   submodule; alternatively you can change following "#ifdef TRACE"
+ *   to "#if 1" to force verbose output in all STM submodules. */
+
+#ifdef TRACE
+
+#	ifndef CONFIG_SND_DEBUG
+#		undef snd_printd
+#		define snd_printd(format, args...) \
+				snd_printk(KERN_INFO format, ## args)
+#	endif
 
-#define ___concat(a, b) a##b
-#define __concat(a, b) ___concat(a, b)
+#	define snd_stm_printt(format, args...) \
+			snd_printd(format, ## args)
 
-#if defined(DEBUG)
-static int __concat(debug_, COMPONENT) = DEBUG;
 #else
-static int __concat(debug_, COMPONENT) = -1;
-#endif
-module_param(__concat(debug_, COMPONENT), int, S_IRUGO | S_IWUSR);
 
-#if defined(CONFIG_SND_STM_DEBUG_LEVEL)
-extern int *snd_stm_debug_level;
-#define verbosity max(*snd_stm_debug_level, __concat(debug_, COMPONENT))
-#else
-#define verbosity __concat(debug_, COMPONENT)
-#endif
-
-#if defined(CONFIG_SND_VERBOSE_PRINTK)
-
-#define snd_stm_printd(level, format, args...) \
-		do { \
-			if (level <= verbosity) \
-				snd_printk(KERN_INFO format, ## args); \
-		} while (0)
-
-#define snd_stm_assert snd_assert
-
-#else
-
-#define snd_stm_printd(level, format, args...) \
-		do { \
-			if (level <= verbosity) \
-				printk(KERN_INFO "snd-stm:%s:%d: " format, \
-						__snd_stm_component, \
-						__LINE__, ## args); \
-		} while (0)
-
-#define snd_stm_assert(expr, args...) \
-		do { \
-			if (unlikely(!(expr))) { \
-				printk(KERN_ERR "snd-stm:%s:%d: BUG? " \
-						"(%s)\n", \
-						__snd_stm_component, \
-						__LINE__, \
-						__stringify(expr)); \
-				dump_stack(); \
-				args; \
-			} \
-		} while (0)
-#endif
-
-#else
-
-#define snd_stm_printd(...) /* nothing */
-
-#define snd_stm_assert snd_assert
+#	define snd_stm_printt(...)
 
 #endif
 
-/* Error messages */
+/* Error debug messages */
 
-#if defined(CONFIG_SND_VERBOSE_PRINTK)
 #define snd_stm_printe(format, args...) \
 		snd_printk(KERN_ERR format, ## args)
-#else
-#define snd_stm_printe(format, args...) \
-		printk(KERN_ERR "snd-stm:%s:%d: " format, \
-				__snd_stm_component, __LINE__, ## args)
-#endif
-
-/* Magic value checking in device structures */
-
-#if defined(CONFIG_SND_DEBUG) || defined(DEBUG)
 
-#define snd_stm_magic \
-		(((unsigned)(&__snd_stm_component) & 0xffff0000) >> 16 ^ \
-		((unsigned)(&__snd_stm_component) & 0xffff))
-#define snd_stm_magic_good (0x600d0000 | snd_stm_magic)
-#define snd_stm_magic_bad (0xbaad0000 | snd_stm_magic)
-#define snd_stm_magic_field unsigned __snd_stm_magic
-#define snd_stm_magic_set(object) \
-		(object)->__snd_stm_magic = snd_stm_magic_good
-#define snd_stm_magic_clear(object) \
-		(object)->__snd_stm_magic = snd_stm_magic_bad
-#define snd_stm_magic_assert(object, args...) \
-		snd_stm_assert((object)->__snd_stm_magic == \
-				snd_stm_magic_good, ## args)
+/* Magic value checking in device structures
+ * - define MAGIC as a unique value _before_ including
+ *   common.h to enable in selected submodule; alternatively you can
+ *   change following "#ifdef MAGIC" to "#if 1" to force magic
+ *   checking in all STM submodules. */
+
+#ifdef MAGIC
+
+	enum snd_stm_magic {
+		snd_stm_magic_good = 0x600da15a + MAGIC,
+		snd_stm_magic_bad  = 0xbaada15a + MAGIC
+	};
+
+#	define snd_stm_magic_field \
+			enum snd_stm_magic __magic
+#	define snd_stm_magic_set(object) \
+			(object)->__magic = snd_stm_magic_good
+#	define snd_stm_magic_clear(object) \
+			(object)->__magic = snd_stm_magic_bad
+#	define snd_stm_magic_assert(object, args...) \
+			snd_assert((object)->__magic == snd_stm_magic_good, \
+					## args)
 
 #else
 
-#	define snd_stm_magic_field /* nothing */
-#	define snd_stm_magic_set(object) /* nothing */
-#	define snd_stm_magic_clear(object) /* nothing */
-#	define snd_stm_magic_assert(object, args...) /* nothing */
+#	define snd_stm_magic_field
+#	define snd_stm_magic_set(object)
+#	define snd_stm_magic_clear(object)
+#	define snd_stm_magic_assert(object, args...)
 
 #endif
 
diff -rcN linux-sh4-2.6.23.17_stm23_0119-orig/sound//stm/conv.c linux-sh4/sound//stm/conv.c
*** linux-sh4-2.6.23.17_stm23_0119-orig/sound//stm/conv.c	2009-06-06 20:17:15.000000000 +0200
--- linux-sh4/sound//stm/conv.c	2009-07-18 21:57:49.000000000 +0200
***************
*** 3,9 ****
   *
   *   Copyright (c) 2005-2007 STMicroelectronics Limited
   *
!  *   Author: Pawel Moll <pawel.moll@st.com>
   *
   *   This program is free software; you can redistribute it and/or modify
   *   it under the terms of the GNU General Public License as published by
--- 3,9 ----
   *
   *   Copyright (c) 2005-2007 STMicroelectronics Limited
   *
!  *   Author: Pawel MOLL <pawel.moll@st.com>
   *
   *   This program is free software; you can redistribute it and/or modify
   *   it under the terms of the GNU General Public License as published by
***************
*** 23,1070 ****
  
  #include <linux/init.h>
  #include <linux/list.h>
- #include <linux/device.h>
- #include <sound/control.h>
  
! #define COMPONENT conv
  #include "common.h"
  
  
  
  /*
!  * Converters infrastructure description
   */
  
! struct snd_stm_conv_group;
! struct snd_stm_conv_source;
  
! struct snd_stm_conv_converter {
  	struct list_head list;
  
! 	struct snd_stm_conv_group *group;
  
! 	struct snd_stm_conv_ops *ops;
! 	void *priv;
  
! 	int source_channel_from;
! 	int source_channel_to;
! 
! 	int enabled;
! 	int muted_by_source;
! 	int muted_by_user;
! 	spinlock_t status_lock; /* Protects enabled and muted_by_* */
! 	struct snd_kcontrol *ctl_mute;
  
  	snd_stm_magic_field;
  };
  
! struct snd_stm_conv_group {
! 	struct list_head list;
! 
! 	struct snd_stm_conv_source *source;
! 
! 	struct list_head converters;
! 
! 	int enabled;
! 	int muted_by_source;
! 
! 	snd_stm_magic_field;
! 
! 	char name[1]; /* "Expandable" */
! };
! 
! struct snd_stm_conv_source {
! 	struct list_head list;
! 
! 	struct bus_type *bus;
! 	char bus_id[BUS_ID_SIZE];
! 	int channels_num;
! 	struct snd_card *card;
! 	int card_device;
! 
! 	struct snd_stm_conv_group *group_selected;
! 	struct snd_stm_conv_group *group_active;
! 	struct list_head groups;
! 	struct snd_kcontrol *ctl_route;
! 
! 	snd_stm_magic_field;
! };
! 
! LIST_HEAD(snd_stm_conv_sources); /* Sources list */
! DEFINE_MUTEX(snd_stm_conv_mutex); /* Big Converters Structure Lock ;-) */
! 
! 
! 
! /*
!  * Converter control interface implementation
!  */
! 
! const char *snd_stm_conv_get_name(struct snd_stm_conv_group *group)
! {
! 	snd_stm_printd(1, "snd_stm_conv_get_name(group=%p)\n", group);
! 
! 	snd_stm_assert(group, return NULL);
! 	snd_stm_magic_assert(group, return NULL);
! 
! 	return group->name;
! }
! 
! unsigned int snd_stm_conv_get_format(struct snd_stm_conv_group *group)
! {
! 	unsigned int result = 0;
! 	struct snd_stm_conv_converter *converter;
! 
! 	snd_stm_printd(1, "snd_stm_conv_get_format(group=%p)\n", group);
! 
! 	snd_stm_assert(group, return -EINVAL);
! 	snd_stm_magic_assert(group, return -EINVAL);
! 
! 	/* All configured converters must share the same input format -
! 	 * get first of them and check the rest; if any of converters
! 	 * has different opinion than others - raise an error! */
! 
! 	list_for_each_entry(converter, &group->converters, list) {
! 		unsigned int format = converter->ops->get_format(
! 				converter->priv);
! 
! 		if (result == 0) {
! 			result = format;
! 		} else if (format != result) {
! 			snd_stm_printe("Wrong format (0x%x) for converter %p"
! 					" (the rest says 0x%x)!\n", format,
! 					converter, result);
! 			snd_BUG();
! 		}
! 	}
! 
! 	return result;
! }
! 
! int snd_stm_conv_get_oversampling(struct snd_stm_conv_group *group)
! {
! 	int result = 0;
! 	struct snd_stm_conv_converter *converter;
! 
! 	snd_stm_printd(1, "snd_stm_conv_get_oversampling(group=%p)\n",
! 			group);
! 
! 	snd_stm_assert(group, return -EINVAL);
! 	snd_stm_magic_assert(group, return -EINVAL);
! 
! 	/* All configured converters must share the same oversampling value -
! 	 * get first of them and check the rest; if any of converters
! 	 * has different opinion than others - raise an error! */
! 
! 	list_for_each_entry(converter, &group->converters, list) {
! 		int oversampling;
! 
! 		snd_stm_assert(converter, return -EINVAL);
! 		snd_stm_magic_assert(converter, return -EINVAL);
! 
! 		oversampling = converter->ops->get_oversampling(
! 				converter->priv);
! 
! 		if (result == 0) {
! 			result = oversampling;
! 		} else if (oversampling != result) {
! 			snd_stm_printe("Wrong oversampling value (%d) for "
! 					"converter %p (the rest says %d)!\n",
! 					oversampling, converter, result);
! 			snd_BUG();
! 		}
! 	}
! 
! 	return result;
! }
! 
! int snd_stm_conv_enable(struct snd_stm_conv_group *group,
! 		int channel_from, int channel_to)
! {
! 	int result = 0;
! 	struct snd_stm_conv_converter *converter;
! 
! 	snd_stm_printd(1, "snd_stm_conv_enable(group=%p, channel_from=%d, "
! 			"channel_to=%d)\n", group, channel_from, channel_to);
! 
! 	snd_stm_assert(channel_to >= channel_from, return -EINVAL);
! 	snd_stm_assert(group, return -EINVAL);
! 	snd_stm_magic_assert(group, return -EINVAL);
! 	snd_stm_assert(!group->enabled, return -EINVAL);
! 
! 	group->enabled = 1;
! 
! 	list_for_each_entry(converter, &group->converters, list) {
! 		snd_stm_assert(converter, return -EINVAL);
! 		snd_stm_magic_assert(converter, return -EINVAL);
! 		snd_stm_assert(!converter->enabled, continue);
! 
! 		spin_lock(&converter->status_lock);
! 
! 		if ((channel_from <= converter->source_channel_from &&
! 				converter->source_channel_from <= channel_to) ||
! 				(channel_from <= converter->source_channel_to &&
! 				converter->source_channel_to <= channel_to)) {
! 			converter->enabled = 1;
! 
! 			if (converter->ops->set_enabled) {
! 				int done = converter->ops->set_enabled(1,
! 						converter->priv);
! 
! 				if (done != 0) {
! 					snd_stm_printe("Failed to enable "
! 							"converter %p!\n",
! 							converter);
! 					result = done;
! 				}
! 			}
! 		}
! 
! 		spin_unlock(&converter->status_lock);
! 	}
! 
! 	return result;
! }
! 
! int snd_stm_conv_disable(struct snd_stm_conv_group *group)
! {
! 	int result = 0;
! 	struct snd_stm_conv_converter *converter;
! 
! 	snd_stm_printd(1, "snd_stm_conv_disable(group=%p)\n", group);
! 
! 	snd_stm_assert(group, return -EINVAL);
! 	snd_stm_magic_assert(group, return -EINVAL);
! 	snd_stm_assert(group->enabled, return -EINVAL);
! 
! 	group->enabled = 0;
! 
! 	list_for_each_entry(converter, &group->converters, list) {
! 		snd_stm_assert(converter, return -EINVAL);
! 		snd_stm_magic_assert(converter, return -EINVAL);
! 
! 		spin_lock(&converter->status_lock);
! 
! 		if (converter->enabled) {
! 			converter->enabled = 0;
  
! 			if (converter->ops->set_enabled) {
! 				int done = converter->ops->set_enabled(0,
! 						converter->priv);
  
! 				if (done != 0) {
! 					snd_stm_printe("Failed to disable "
! 							"converter %p!\n",
! 							converter);
! 					result = done;
! 				}
! 			}
! 		}
! 
! 		spin_unlock(&converter->status_lock);
! 	}
! 
! 	return result;
  }
  
! int snd_stm_conv_mute(struct snd_stm_conv_group *group)
  {
! 	int result = 0;
! 	struct snd_stm_conv_converter *converter;
  
! 	snd_stm_printd(1, "snd_stm_conv_mute(group=%p)\n", group);
! 
! 	snd_stm_assert(group, return -EINVAL);
! 	snd_stm_magic_assert(group, return -EINVAL);
! 	snd_stm_assert(group->enabled, return -EINVAL);
! 	snd_stm_assert(!group->muted_by_source, return -EINVAL);
! 
! 	group->muted_by_source = 1;
! 
! 	list_for_each_entry(converter, &group->converters, list) {
! 		snd_stm_assert(converter, return -EINVAL);
! 		snd_stm_magic_assert(converter, return -EINVAL);
! 
! 		spin_lock(&converter->status_lock);
! 
! 		if (converter->enabled) {
! 			converter->muted_by_source = 1;
! 
! 			if (converter->ops->set_muted &&
! 					!converter->muted_by_user) {
! 				int done = converter->ops->set_muted(1,
! 						converter->priv);
! 
! 				if (done != 0) {
! 					snd_stm_printe("Failed to mute "
! 							"converter %p!\n",
! 							converter);
! 					result = done;
! 				}
! 			}
! 		}
! 
! 		spin_unlock(&converter->status_lock);
! 	}
! 
! 	return result;
! }
! 
! int snd_stm_conv_unmute(struct snd_stm_conv_group *group)
! {
! 	int result = 0;
! 	struct snd_stm_conv_converter *converter;
  
! 	snd_stm_printd(1, "snd_stm_conv_unmute(group=%p)\n", group);
  
! 	snd_stm_assert(group, return -EINVAL);
! 	snd_stm_magic_assert(group, return -EINVAL);
! 	snd_stm_assert(group->enabled, return -EINVAL);
! 	snd_stm_assert(group->muted_by_source, return -EINVAL);
! 
! 	group->muted_by_source = 0;
! 
! 	list_for_each_entry(converter, &group->converters, list) {
! 		snd_stm_assert(converter, return -EINVAL);
! 		snd_stm_magic_assert(converter, return -EINVAL);
! 
! 		spin_lock(&converter->status_lock);
! 
! 		if (converter->enabled) {
! 			converter->muted_by_source = 0;
! 
! 			if (converter->ops->set_muted &&
! 					!converter->muted_by_user) {
! 				int done = converter->ops->set_muted(0,
! 						converter->priv);
! 
! 				if (done != 0) {
! 					snd_stm_printe("Failed to unmute "
! 							"converter %p!\n",
! 							converter);
! 					result = done;
! 				}
! 			}
! 		}
  
! 		spin_unlock(&converter->status_lock);
  	}
  
- 	return result;
- }
- 
- 
- 
- /*
-  * ALSA controls
-  */
- 
- static int snd_stm_conv_ctl_mute_get(struct snd_kcontrol *kcontrol,
- 		struct snd_ctl_elem_value *ucontrol)
- {
- 	struct snd_stm_conv_converter *converter = snd_kcontrol_chip(kcontrol);
- 
- 	snd_stm_printd(1, "snd_stm_conv_ctl_mute_get(kcontrol=0x%p,"
- 			" ucontrol=0x%p)\n", kcontrol, ucontrol);
- 
- 	snd_stm_assert(converter, return -EINVAL);
- 	snd_stm_magic_assert(converter, return -EINVAL);
- 
- 	spin_lock(&converter->status_lock);
- 
- 	ucontrol->value.integer.value[0] = !converter->muted_by_user;
- 
- 	spin_unlock(&converter->status_lock);
- 
  	return 0;
  }
  
! static int snd_stm_conv_ctl_mute_put(struct snd_kcontrol *kcontrol,
! 		struct snd_ctl_elem_value *ucontrol)
  {
! 	struct snd_stm_conv_converter *converter = snd_kcontrol_chip(kcontrol);
! 	int changed = 0;
! 
! 	snd_stm_printd(1, "snd_stm_conv_ctl_mute_put(kcontrol=0x%p,"
! 			" ucontrol=0x%p)\n", kcontrol, ucontrol);
  
! 	snd_stm_assert(converter, return -EINVAL);
! 	snd_stm_magic_assert(converter, return -EINVAL);
  
! 	snd_stm_assert(converter->ops->set_muted, return -EINVAL);
! 
! 	spin_lock(&converter->status_lock);
! 
! 	if (ucontrol->value.integer.value[0] !=
! 			!converter->muted_by_user) {
! 		changed = 1;
! 
! 		converter->muted_by_user =
! 				!ucontrol->value.integer.value[0];
! 
! 		if (converter->enabled &&
! 				converter->muted_by_user &&
! 				!converter->muted_by_source)
! 			converter->ops->set_muted(1, converter->priv);
! 		else if (converter->enabled &&
! 				!converter->muted_by_user &&
! 				!converter->muted_by_source)
! 			converter->ops->set_muted(0, converter->priv);
! 	}
  
! 	spin_unlock(&converter->status_lock);
  
! 	return changed;
! }
! 
! static struct snd_kcontrol_new snd_stm_conv_ctl_mute = {
! 	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
! 	.name = "Master Playback Switch",
! 	.info = snd_stm_ctl_boolean_info,
! 	.get = snd_stm_conv_ctl_mute_get,
! 	.put = snd_stm_conv_ctl_mute_put,
! };
! 
! static int snd_stm_conv_ctl_mute_add(struct snd_stm_conv_converter *converter)
! {
! 	int result;
! 	struct snd_stm_conv_source *source;
! 	struct snd_kcontrol *ctl_mute;
! 
! 	snd_stm_printd(1, "snd_stm_conv_ctl_mute_add(converter=%p)\n",
! 			converter);
! 
! 	snd_stm_assert(converter, return -EINVAL);
! 	snd_stm_magic_assert(converter, return -EINVAL);
! 
! 	source = converter->group->source;
! 
! 	snd_stm_assert(source, return -EINVAL);
! 	snd_stm_magic_assert(source, return -EINVAL);
! 
! 	snd_stm_conv_ctl_mute.device = source->card_device;
! 
! 	ctl_mute = snd_ctl_new1(&snd_stm_conv_ctl_mute, converter);
! 	result = snd_ctl_add(source->card, ctl_mute);
! 	if (result >= 0) {
! 		/* We will have to manually dispose "hot-plugged" controls...
! 		 * ("normal" ones will be disposed during snd_card_free) */
! 		if (snd_stm_card_is_registered())
! 			converter->ctl_mute = ctl_mute;
! 
! 		snd_stm_conv_ctl_mute.index++;
! 	} else {
! 		snd_stm_printe("Error %d while adding mute ALSA control!\n",
! 				result);
! 	}
  
! 	return result;
  }
  
! 
! 
! static int snd_stm_conv_ctl_route_info(struct snd_kcontrol *kcontrol,
  		struct snd_ctl_elem_info *uinfo)
  {
! 	struct snd_stm_conv_source *source = snd_kcontrol_chip(kcontrol);
! 	struct snd_stm_conv_group *group;
! 	int item = 0;
  
! 	snd_stm_printd(1, "snd_stm_conv_ctl_route_info(kcontrol=0x%p,"
! 			" uinfo=0x%p)\n", kcontrol, uinfo);
  
! 	snd_stm_assert(source, return -EINVAL);
! 	snd_stm_magic_assert(source, return -EINVAL);
  
  	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
  	uinfo->count = 1;
  
! 	mutex_lock(&snd_stm_conv_mutex);
  
! 	list_for_each_entry(group, &source->groups, list) {
! 		if (list_is_last(&group->list, &source->groups) &&
! 				uinfo->value.enumerated.item > item)
! 			uinfo->value.enumerated.item = item;
! 		if (item == uinfo->value.enumerated.item)
! 			snprintf(uinfo->value.enumerated.name, 64, "%s",
! 					group->name);
! 		item++;
! 	};
! 
! 	uinfo->value.enumerated.items = item;
! 
! 	mutex_unlock(&snd_stm_conv_mutex);
  
  	return 0;
  }
  
! static int snd_stm_conv_ctl_route_get(struct snd_kcontrol *kcontrol,
  		struct snd_ctl_elem_value *ucontrol)
  {
! 	struct snd_stm_conv_source *source = snd_kcontrol_chip(kcontrol);
! 	struct snd_stm_conv_group *group;
! 	int item = 0;
  
! 	snd_stm_printd(1, "snd_stm_conv_ctl_route_get(kcontrol=0x%p,"
! 			" ucontrol=0x%p)\n", kcontrol, ucontrol);
  
! 	snd_stm_assert(source, return -EINVAL);
! 	snd_stm_magic_assert(source, return -EINVAL);
  
! 	mutex_lock(&snd_stm_conv_mutex);
  
! 	ucontrol->value.enumerated.item[0] = 0; /* First is default ;-) */
  
! 	list_for_each_entry(group, &source->groups, list) {
! 		if (group == source->group_selected) {
! 			ucontrol->value.enumerated.item[0] = item;
! 			break;
! 		}
! 		item++;
! 	};
! 
! 	mutex_unlock(&snd_stm_conv_mutex);
  
  	return 0;
  }
  
! static int snd_stm_conv_ctl_route_put(struct snd_kcontrol *kcontrol,
  		struct snd_ctl_elem_value *ucontrol)
  {
! 	int changed = 0;
! 	struct snd_stm_conv_source *source = snd_kcontrol_chip(kcontrol);
! 	struct snd_stm_conv_group *group;
! 	int item = 0;
! 
! 	snd_stm_printd(1, "snd_stm_conv_ctl_route_put(kcontrol=0x%p,"
! 			" ucontrol=0x%p)\n", kcontrol, ucontrol);
! 
! 	snd_stm_assert(source, return -EINVAL);
! 	snd_stm_magic_assert(source, return -EINVAL);
! 
! 	mutex_lock(&snd_stm_conv_mutex);
! 
! 	list_for_each_entry(group, &source->groups, list) {
! 		if (item == ucontrol->value.enumerated.item[0]) {
! 			if (group != source->group_selected) {
! 				changed = 1;
! 				source->group_selected = group;
! 			}
! 			break;
! 		}
! 		item++;
! 	}
! 
! 	mutex_unlock(&snd_stm_conv_mutex);
! 
! 	return changed;
! }
! 
! static struct snd_kcontrol_new snd_stm_conv_ctl_route = {
! 	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
! 	.name = "PCM Playback Route",
! 	.info = snd_stm_conv_ctl_route_info,
! 	.get = snd_stm_conv_ctl_route_get,
! 	.put = snd_stm_conv_ctl_route_put,
! };
! 
! static int snd_stm_conv_ctl_route_add(struct snd_stm_conv_source *source)
! {
! 	struct snd_kcontrol *ctl_route;
! 	int result;
  
! 	snd_stm_printd(1, "snd_stm_conv_ctl_route_add(source=%p)\n", source);
  
! 	snd_stm_assert(source, return -EINVAL);
! 	snd_stm_magic_assert(source, return -EINVAL);
  
! 	snd_stm_conv_ctl_route.device = source->card_device;
! 
! 	ctl_route = snd_ctl_new1(&snd_stm_conv_ctl_route, source);
! 	result = snd_ctl_add(source->card, ctl_route);
! 	if (result >= 0) {
! 		/* We will have to manually dispose "hot-plugged"
! 		 * controls... ("normal" ones will be disposed
! 		 * during snd_card_free) */
! 		if (snd_stm_card_is_registered())
! 			source->ctl_route = ctl_route;
  
! 		snd_stm_conv_ctl_route.index++;
! 	} else {
! 		snd_stm_printe("Error %d while adding route ALSA "
! 				"control!\n", result);
! 	}
  
! 	return result;
! }
  
! /*
!  * Converters router implementation
!  */
! 
! static inline int snd_stm_conv_more_than_one_entry(const struct list_head *head)
! {
! 	return !list_empty(head) && !list_is_last(head->next, head);
  }
  
! static struct snd_stm_conv_source *snd_stm_conv_get_source(
! 		struct bus_type *bus, const char *bus_id)
! {
! 	struct snd_stm_conv_source *source;
! 
! 	snd_stm_printd(1, "snd_stm_conv_get_source(bus=%p, bus_id='%s')\n",
! 			bus, bus_id);
! 
! 	snd_stm_assert(bus, return NULL);
! 	snd_stm_assert(bus_id, return NULL);
! 
! 	mutex_lock(&snd_stm_conv_mutex);
! 
! 	list_for_each_entry(source, &snd_stm_conv_sources, list)
! 		if (bus == source->bus && strcmp(bus_id, source->bus_id) == 0)
! 			goto done; /* Already known source */
! 
! 	/* First time see... */
! 
! 	source = kzalloc(sizeof(*source), GFP_KERNEL);
! 	if (!source) {
! 		snd_stm_printe("Can't allocate memory for source!\n");
! 		goto done;
! 	}
! 	snd_stm_magic_set(source);
! 
! 	source->bus = bus;
! 	strlcpy(source->bus_id, bus_id, BUS_ID_SIZE);
! 	INIT_LIST_HEAD(&source->groups);
! 
! 	list_add_tail(&source->list, &snd_stm_conv_sources);
! 
! done:
! 	mutex_unlock(&snd_stm_conv_mutex);
! 
! 	return source;
! }
  
! struct snd_stm_conv_source *snd_stm_conv_register_source(struct bus_type *bus,
! 		const char *bus_id, int channels_num,
  		struct snd_card *card, int card_device)
  {
! 	struct snd_stm_conv_source *source;
! 	struct snd_stm_conv_group *group;
! 
! 	snd_stm_printd(1, "snd_stm_conv_register_source(bus=%p, bus_id='%s', "
! 			"channels_num=%d, card=%p, card_device=%d)\n",
! 			bus, bus_id, channels_num, card, card_device);
! 
! 	snd_stm_assert(bus, return NULL);
! 	snd_stm_assert(bus_id, return NULL);
! 	snd_stm_assert(channels_num > 0, return NULL);
! 	snd_stm_assert(card, return NULL);
! 	snd_stm_assert(card_device >= 0, return NULL);
! 
! 	source = snd_stm_conv_get_source(bus, bus_id);
! 	if (!source) {
! 		snd_stm_printe("Can't get source structure!\n");
! 		return NULL;
! 	}
! 
! 	snd_stm_assert(source->channels_num == 0, return NULL);
! 	snd_stm_assert(!source->card, return NULL);
! 
! 	source->channels_num = channels_num;
! 	source->card = card;
! 	source->card_device = card_device;
! 
! 	mutex_lock(&snd_stm_conv_mutex);
! 
! 	/* Add route ALSA control if needed */
! 
! 	if (snd_stm_conv_more_than_one_entry(&source->groups) &&
! 			snd_stm_conv_ctl_route_add(source) != 0)
! 		snd_stm_printe("Failed to add route ALSA control!\n");
  
! 	/* Add mute ALSA controls for already registered converters */
  
! 	list_for_each_entry(group, &source->groups, list) {
! 		struct snd_stm_conv_converter *converter;
  
! 		snd_stm_magic_assert(group);
  
! 		list_for_each_entry(converter, &group->converters, list) {
! 			snd_stm_magic_assert(converter);
  
! 			if (converter->ops->set_muted &&
! 					snd_stm_conv_ctl_mute_add(converter)
! 					< 0)
! 				snd_stm_printe("Failed to add mute "
! 						"ALSA control!\n");
  		}
  	}
  
! 	mutex_unlock(&snd_stm_conv_mutex);
! 
! 	return source;
! }
! 
! int snd_stm_conv_unregister_source(struct snd_stm_conv_source *source)
! {
! 	snd_stm_printd(1, "snd_stm_conv_unregister_source(source=%p)\n",
! 			source);
! 
! 	snd_stm_assert(source, return -EINVAL);
! 	snd_stm_magic_assert(source, return -EINVAL);
! 
! 	mutex_lock(&snd_stm_conv_mutex);
! 
! 	list_del(&source->list);
! 	source->channels_num = 0;
! 
! 	/* If there is no more registered converters... */
! 	if (list_empty(&source->groups)) {
! 		snd_stm_magic_clear(source);
! 		kfree(source);
! 	}
! 
! 	mutex_unlock(&snd_stm_conv_mutex);
! 
! 	return 0;
  }
  
  
  
! static inline struct snd_stm_conv_group *snd_stm_conv_get_group(
! 		struct snd_stm_conv_source *source, const char *name)
! {
! 	struct snd_stm_conv_group *group;
! 
! 	snd_stm_printd(1, "snd_stm_conv_get_group(source=%p, name='%s')\n",
! 			source, name);
! 
! 	snd_stm_assert(source, return NULL);
! 	snd_stm_magic_assert(source, return NULL);
! 	snd_stm_assert(name, return NULL);
! 
! 	/* Random memory fuse */
! 	snd_stm_assert(strlen(name) < 1024, return NULL);
! 
! 	mutex_lock(&snd_stm_conv_mutex);
! 
! 	list_for_each_entry(group, &source->groups, list)
! 		if (strcmp(name, group->name) == 0)
! 			goto done; /* Already known group */
! 
! 	/* First time see... */
! 
! 	group = kzalloc(sizeof(*group) + strlen(name), GFP_KERNEL);
! 	if (!group) {
! 		snd_stm_printe("Can't allocate memory for group!\n");
! 		goto done;
! 	}
! 	snd_stm_magic_set(group);
! 
! 	INIT_LIST_HEAD(&group->converters);
! 
! 	strcpy(group->name, name);
! 
! 	group->source = source;
! 	group->muted_by_source = 1;
! 
! 	if (!source->group_selected)
! 		source->group_selected = group;
! 
! 	list_add_tail(&group->list, &source->groups);
! 
! 	/* If this is a second group attached to this source,
! 	 * and the source has been already registered, we need
! 	 * to add a route ALSA control... */
! 	if (source->card && snd_stm_conv_more_than_one_entry(&source->groups))
! 		snd_stm_conv_ctl_route_add(source);
! 
! done:
! 	mutex_unlock(&snd_stm_conv_mutex);
! 
! 	return group;
! }
  
! static int snd_stm_conv_remove_group(struct snd_stm_conv_group *group)
  {
! 	struct snd_stm_conv_source *source;
! 
! 	snd_stm_printd(1, "snd_stm_conv_remove_group(group=%p)\n", group);
! 
! 	snd_stm_assert(group, return -EINVAL);
! 	snd_stm_magic_assert(group, return -EINVAL);
! 
! 	source = group->source;
! 
! 	snd_stm_assert(source, return -EINVAL);
! 	snd_stm_magic_assert(source, return -EINVAL);
! 
! 	list_del(&group->list);
! 
! 	if (group == source->group_active)
! 		snd_stm_printe("WARNING! Removing active converters group! "
! 				"I hope you know what are you doing...\n");
! 
! 	/* Removing actually selected group? */
! 	if (group == source->group_selected) {
! 		if (list_empty(&source->groups)) {
! 			/* This was the last group... */
! 			source->group_selected = NULL;
! 		} else {
! 			/* If there is only one group left, the route control
! 			 * is not needed anymore */
! 			if (!snd_stm_conv_more_than_one_entry(&source->groups)
! 					&& source->ctl_route)
! 				snd_ctl_remove(source->card, source->ctl_route);
! 
! 			/* The first group on list is considered default... */
! 			source->group_selected = list_first_entry(
! 					&source->groups,
! 					struct snd_stm_conv_group, list);
! 		}
! 	}
  
! 	snd_stm_magic_clear(group);
! 	kfree(group);
  
! 	/* Release the source resources, if not used anymore */
! 	if (list_empty(&source->groups) && source->channels_num == 0) {
! 		snd_stm_magic_clear(source);
! 		kfree(source);
! 	}
! 
! 	return 0;
  }
  
! struct snd_stm_conv_converter *snd_stm_conv_register_converter(
! 		const char *group_name, struct snd_stm_conv_ops *ops,
! 		void *priv,
! 		struct bus_type *source_bus, const char *source_bus_id,
! 		int source_channel_from, int source_channel_to, int *index)
  {
! 	static int number;
! 	struct snd_stm_conv_converter *converter;
! 	struct snd_stm_conv_group *group;
! 	struct snd_stm_conv_source *source;
! 
! 	snd_stm_printd(1, "snd_stm_conv_register_converter(group='%s', ops=%p,"
! 			" priv=%p, source_bus=%p, source_bus_id='%s', "
! 			"source_channel_from=%d, source_channel_to=%d)\n",
! 			group_name, ops, priv, source_bus, source_bus_id,
! 			source_channel_from, source_channel_to);
! 
! 	snd_stm_assert(group_name, return NULL);
! 	snd_stm_assert(ops, return NULL);
! 	snd_stm_assert(source_bus, return NULL);
! 	snd_stm_assert(source_bus_id, return NULL);
! 	snd_stm_assert(source_channel_from >= 0, return NULL);
! 	snd_stm_assert(source_channel_to >= source_channel_from, return NULL);
! 
! 	/* Create converter description */
! 
! 	converter = kzalloc(sizeof(*converter), GFP_KERNEL);
! 	if (!converter) {
! 		snd_stm_printe("Can't allocate memory for converter!\n");
! 		goto error_kzalloc;
! 	}
! 	snd_stm_magic_set(converter);
! 
! 	converter->ops = ops;
! 	converter->priv = priv;
! 	converter->source_channel_from = source_channel_from;
! 	converter->source_channel_to = source_channel_to;
! 
! 	converter->muted_by_source = 1;
! 
! 	spin_lock_init(&converter->status_lock);
! 
! 	/* And link it with the source */
  
! 	source = snd_stm_conv_get_source(source_bus, source_bus_id);
! 	if (!source) {
! 		snd_stm_printe("Can't get source structure!\n");
! 		goto error_get_source;
! 	}
! 
! 	group = snd_stm_conv_get_group(source, group_name);
! 	if (!group) {
! 		snd_stm_printe("Can't get group structure!\n");
! 		goto error_get_group;
! 	}
! 
! 	if (source->group_active == group)
! 		snd_stm_printe("WARNING! Adding a converter to an active "
! 				"group!\n");
! 
! 	mutex_lock(&snd_stm_conv_mutex);
  
! 	converter->group = group;
! 	list_add_tail(&converter->list, &group->converters);
! 
! 	mutex_unlock(&snd_stm_conv_mutex);
! 
! 	/* Add mute ALSA control if muting is supported and source is known */
! 
! 	if (source->card && ops->set_muted &&
! 			snd_stm_conv_ctl_mute_add(converter) < 0) {
! 		snd_stm_printe("Failed to add mute ALSA control!\n");
! 		goto error_add_ctl_mute;
! 	}
! 
! 	number++;
! 	if (index)
! 		*index = number;
! 
! 	return converter;
! 
! error_add_ctl_mute:
! error_get_group:
! error_get_source:
! 	list_del(&converter->list);
! 	snd_stm_magic_clear(converter);
! 	kfree(converter);
! error_kzalloc:
! 	return NULL;
  }
- EXPORT_SYMBOL(snd_stm_conv_register_converter);
  
! int snd_stm_conv_unregister_converter(struct snd_stm_conv_converter *converter)
  {
! 	struct snd_stm_conv_group *group;
! 
! 	snd_stm_printd(1, "snd_stm_conv_unregister_converter(converter=%p)\n",
! 			converter);
! 
! 	snd_stm_assert(converter, return -EINVAL);
! 	snd_stm_magic_assert(converter, return -EINVAL);
! 
! 	group = converter->group;
! 
! 	snd_stm_assert(group, return -EINVAL);
! 	snd_stm_magic_assert(group, return -EINVAL);
! 
! 	mutex_lock(&snd_stm_conv_mutex);
! 
! 	list_del(&converter->list);
! 
! 	if (converter->ctl_mute)
! 		snd_ctl_remove(group->source->card, converter->ctl_mute);
  
! 	snd_stm_magic_clear(converter);
! 	kfree(converter);
  
! 	if (list_empty(&group->converters))
! 		snd_stm_conv_remove_group(group);
  
! 	mutex_unlock(&snd_stm_conv_mutex);
  
! 	return 0;
  }
- EXPORT_SYMBOL(snd_stm_conv_unregister_converter);
- 
- int snd_stm_conv_get_card_device(struct snd_stm_conv_converter *converter)
- {
- 	snd_stm_printd(1, "snd_stm_conv_get_card_device(converter=%p)\n",
- 			converter);
- 
- 	snd_stm_assert(converter, return -EINVAL);
- 	snd_stm_magic_assert(converter, return -EINVAL);
- 
- 	return converter->group->source->card_device;
- }
- EXPORT_SYMBOL(snd_stm_conv_get_card_device);
- 
  
! struct snd_stm_conv_group *snd_stm_conv_request_group(
! 		struct snd_stm_conv_source *source)
  {
! 	snd_stm_printd(1, "snd_stm_conv_request_group(source=%p)\n", source);
! 
! 	snd_stm_assert(source, return NULL);
! 	snd_stm_magic_assert(source, return NULL);
! 
! 	snd_stm_assert(!source->group_active, return NULL);
  
! 	mutex_lock(&snd_stm_conv_mutex);
  
! 	source->group_active = source->group_selected;
  
! 	mutex_unlock(&snd_stm_conv_mutex);
  
! 	return source->group_active;
  }
  
! int snd_stm_conv_release_group(struct snd_stm_conv_group *group)
  {
! 	snd_stm_printd(1, "snd_stm_conv_release_group(group=%p)\n", group);
! 
! 	snd_stm_assert(group, return -EINVAL);
! 	snd_stm_magic_assert(group, return -EINVAL);
! 
! 	snd_stm_assert(group->source, return -EINVAL);
! 	snd_stm_magic_assert(group->source, return -EINVAL);
! 
! 	snd_stm_assert(group == group->source->group_active, return -EINVAL);
! 
! 	mutex_lock(&snd_stm_conv_mutex);
! 
! 	group->source->group_active = NULL;
  
! 	mutex_unlock(&snd_stm_conv_mutex);
  
! 	return 0;
  }
  
! 
! 
! /*
!  * Converters information view
!  */
! 
! static struct snd_info_entry *snd_stm_conv_proc_entry;
! 
! static void snd_stm_conv_info(struct snd_info_entry *entry,
! 		struct snd_info_buffer *buffer)
  {
! 	struct snd_stm_conv_source *source;
  
! 	snd_iprintf(buffer, "--- converters ---\n");
  
! 	list_for_each_entry(source, &snd_stm_conv_sources, list) {
! 		struct snd_stm_conv_group *group;
! 
! 		snd_iprintf(buffer, "- source %p:\n", source);
! 		snd_iprintf(buffer, "  bus=%p, bus_id='%s'\n",
! 				source->bus, source->bus_id);
! 		snd_iprintf(buffer, "  channels_num=%d\n",
! 				source->channels_num);
! 		snd_iprintf(buffer, "  card=%p, card_device=%d\n",
! 				source->card, source->card_device);
! 
! 		list_for_each_entry(group, &source->groups, list) {
! 			struct snd_stm_conv_converter *converter;
! 
! 			snd_iprintf(buffer, "  - group %p:\n", group);
! 			snd_iprintf(buffer, "    name='%s'\n", group->name);
! 
! 			list_for_each_entry(converter, &group->converters,
! 					list) {
! 				snd_iprintf(buffer, "    - converter %p:\n",
! 						converter);
! 				snd_iprintf(buffer, "      source_channel_from"
! 						"=%d, source_channel_to=%d\n",
! 						converter->source_channel_from,
! 						converter->source_channel_to);
! 				snd_iprintf(buffer, "      enabled=%d\n",
! 						converter->enabled);
! 				snd_iprintf(buffer, "      muted_by_source=%d,"
! 						" muted_by_user=%d\n",
! 						converter->muted_by_source,
! 						converter->muted_by_user);
! 			}
! 		}
! 	}
! 	snd_iprintf(buffer, "\n");
  }
  
  
--- 23,285 ----
  
  #include <linux/init.h>
  #include <linux/list.h>
  
! #undef TRACE /* See common.h debug features */
! #define MAGIC 2 /* See common.h debug features */
  #include "common.h"
  
  
  
  /*
!  * Converters infrastructure interface implementation
   */
  
! #define CONVS_MAX 5 /* TODO: dynamic structure (really necessary???) */
  
! struct snd_stm_conv_links_list {
  	struct list_head list;
  
! 	struct device *device;
  
! 	int convs_num;
! 	struct snd_stm_conv *convs[CONVS_MAX];
  
! 	int conv_attached;
  
  	snd_stm_magic_field;
  };
  
! LIST_HEAD(snd_stm_conv_links); /* "Device->Converter" links list */
! DEFINE_SPINLOCK(snd_stm_conv_links_lock); /* Synchronises the links list */
  
! static inline struct snd_stm_conv_links_list *snd_stm_conv_find_link(
! 		struct device *source) {
! 	struct snd_stm_conv_links_list *entry;
! 
! 	list_for_each_entry(entry, &snd_stm_conv_links, list)
! 		if (source == entry->device)
! 			return entry;
  
! 	return NULL;
  }
  
! int snd_stm_conv_attach(struct snd_stm_conv *conv, struct device *source)
  {
! 	struct snd_stm_conv_links_list *link = snd_stm_conv_find_link(source);
  
! 	snd_stm_printt("snd_stm_conv_attach(conv=%p, source=%p)\n",
! 			conv, source);
  
! 	/* Not synchronised intentionally (doesn't have to be...) */
  
! 	if (link) { /* Known device */
! 		snd_stm_magic_assert(link, return -EINVAL);
! 		snd_assert(link->convs_num < CONVS_MAX,
! 				return -ENOMEM);
! 		link->convs[link->convs_num++] = conv;
! 	} else { /* New device */
! 		link = kzalloc(sizeof(*link), GFP_KERNEL);
! 		if (link == NULL)
! 			return -ENOMEM;
! 		snd_stm_magic_set(link);
! 
! 		link->device = source;
! 		link->convs_num = 1;
! 		link->convs[0] = conv;
  
! 		list_add_tail(&link->list, &snd_stm_conv_links);
  	}
  
  	return 0;
  }
  
! struct snd_stm_conv *snd_stm_conv_get_attached(struct device *source)
  {
! 	struct snd_stm_conv_links_list *link;
! 	struct snd_stm_conv *conv = NULL;
  
! 	snd_stm_printt("snd_stm_conv_attach(source=%p)\n", source);
  
! 	spin_lock(&snd_stm_conv_links_lock);
  
! 	link = snd_stm_conv_find_link(source);
! 	conv = link ? link->convs[link->conv_attached] : NULL;
  
! 	spin_unlock(&snd_stm_conv_links_lock);
  
! 	return conv;
  }
  
! static int snd_stm_conv_route_info(struct snd_kcontrol *kcontrol,
  		struct snd_ctl_elem_info *uinfo)
  {
! 	struct snd_stm_conv_links_list *link = snd_kcontrol_chip(kcontrol);
! 	struct snd_stm_conv *conv;
  
! 	snd_stm_magic_assert(link, return -EINVAL);
  
! 	/* Not synchronised intentionally (doesn't have to be...) */
  
  	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
  	uinfo->count = 1;
+ 	uinfo->value.enumerated.items = link->convs_num;
  
! 	if (uinfo->value.enumerated.item >= link->convs_num)
! 		uinfo->value.enumerated.item = link->convs_num - 1;
  
! 	conv = link->convs[uinfo->value.enumerated.item];
! 	snprintf(uinfo->value.enumerated.name, 64, "%s", conv->name);
  
  	return 0;
  }
  
! static int snd_stm_conv_route_get(struct snd_kcontrol *kcontrol,
  		struct snd_ctl_elem_value *ucontrol)
  {
! 	struct snd_stm_conv_links_list *link = snd_kcontrol_chip(kcontrol);
  
! 	snd_stm_printt("snd_stm_conv_route_get(kcontrol=0x%p, "
! 			"ucontrol=0x%p)\n", kcontrol, ucontrol);
  
! 	snd_stm_magic_assert(link, return -EINVAL);
  
! 	spin_lock(&snd_stm_conv_links_lock);
  
! 	ucontrol->value.enumerated.item[0] = link->conv_attached;
  
! 	spin_unlock(&snd_stm_conv_links_lock);
  
  	return 0;
  }
  
! static int snd_stm_conv_route_put(struct snd_kcontrol *kcontrol,
  		struct snd_ctl_elem_value *ucontrol)
  {
! 	int changed;
! 	struct snd_stm_conv_links_list *link = snd_kcontrol_chip(kcontrol);
  
! 	snd_stm_printt("snd_stm_conv_route_put(kcontrol=0x%p, "
! 			"ucontrol=0x%p)\n", kcontrol, ucontrol);
  
! 	snd_stm_magic_assert(link, return -EINVAL);
  
! 	spin_lock(&snd_stm_conv_links_lock);
  
! 	changed = (ucontrol->value.enumerated.item[0] != link->conv_attached);
! 	link->conv_attached = ucontrol->value.enumerated.item[0];
  
! 	spin_unlock(&snd_stm_conv_links_lock);
  
! 	return changed;
  }
  
! static struct snd_kcontrol_new snd_stm_conv_route_ctl = {
! 	.iface = SNDRV_CTL_ELEM_IFACE_PCM,
! 	.name = "PCM Playback Route",
! 	.info = snd_stm_conv_route_info,
! 	.get = snd_stm_conv_route_get,
! 	.put = snd_stm_conv_route_put,
! };
  
! int snd_stm_conv_add_route_ctl(struct device *source,
  		struct snd_card *card, int card_device)
  {
! 	int result = 0;
! 	struct snd_stm_conv_links_list *link = snd_stm_conv_find_link(source);
  
! 	snd_stm_printt("snd_stm_conv_add_route_ctl(source=%p, card=%p, "
! 			"cards_device=%d)\n", source, card, card_device);
  
! 	/* Not synchronised intentionally (doesn't have to be...) */
  
! 	if (link != NULL) {
! 		snd_stm_magic_assert(link, return -EINVAL);
  
! 		if (link->convs_num > 1) {
! 			snd_stm_conv_route_ctl.device = card_device;
! 			result = snd_ctl_add(card,
! 					snd_ctl_new1(&snd_stm_conv_route_ctl,
! 					link));
  
! 			/* TODO: index per card */
! 			snd_stm_conv_route_ctl.index++;
  		}
+ 	} else {
+ 		snd_stm_printt("Source device '%s' not found...\n",
+ 				source->bus_id);
  	}
  
! 	return result;
  }
  
  
  
! /*
!  * Converter control interface implementation
!  */
  
! unsigned int snd_stm_conv_get_format(struct snd_stm_conv *conv)
  {
! 	snd_stm_printt("snd_stm_conv_get_format(conv=%p)\n", conv);
  
! 	snd_assert(conv->get_format != NULL, return -EINVAL);
  
! 	return conv->get_format(conv);
  }
  
! int snd_stm_conv_get_oversampling(struct snd_stm_conv *conv)
  {
! 	snd_stm_printt("snd_stm_conv_get_oversampling(conv=%p)\n", conv);
  
! 	snd_assert(conv->get_oversampling != NULL, return -EINVAL);
  
! 	return conv->get_oversampling(conv);
  }
  
! int snd_stm_conv_enable(struct snd_stm_conv *conv)
  {
! 	int result = 0;
  
! 	snd_stm_printt("snd_stm_conv_enable(conv=%p)\n", conv);
  
! 	snd_assert(conv->enable != NULL, return -EINVAL);
  
! 	if (conv->master)
! 		result = snd_stm_conv_enable(conv->master);
  
! 	return result ? result : conv->enable(conv);
  }
  
! int snd_stm_conv_disable(struct snd_stm_conv *conv)
  {
! 	int result = 0;
  
! 	snd_stm_printt("snd_stm_conv_disable(conv=%p)\n", conv);
  
! 	snd_assert(conv->disable != NULL, return -EINVAL);
  
! 	if (conv->master)
! 		result = snd_stm_conv_disable(conv->master);
  
! 	return result ? result : conv->disable(conv);
  }
  
! int snd_stm_conv_mute(struct snd_stm_conv *conv)
  {
! 	snd_stm_printt("snd_stm_conv_mute(conv=%p)\n", conv);
  
! 	snd_assert(conv->mute != NULL, return -EINVAL);
  
! 	return conv->mute(conv);
  }
  
! int snd_stm_conv_unmute(struct snd_stm_conv *conv)
  {
! 	snd_stm_printt("snd_stm_conv_unmute(conv=%p)\n", conv);
  
! 	snd_assert(conv->unmute != NULL, return -EINVAL);
  
! 	return conv->unmute(conv);
  }
  
  
***************
*** 1073,1123 ****
   * Initialization
   */
  
- 
  int __init snd_stm_conv_init(void)
  {
- 	/* Register converters information file in ALSA's procfs */
- 
- 	snd_stm_info_register(&snd_stm_conv_proc_entry, "converters",
- 			snd_stm_conv_info, NULL);
- 
  	return 0;
  }
  
! void snd_stm_conv_exit(void)
  {
! 	snd_stm_info_unregister(snd_stm_conv_proc_entry);
  
! 	if (!list_empty(&snd_stm_conv_sources)) {
! 		struct snd_stm_conv_source *source, *source_next;
! 
! 		snd_stm_printe("WARNING! There are some converters "
! 				"infrastructure components left - "
! 				"check your configuration!\n");
! 
! 		list_for_each_entry_safe(source, source_next,
! 				&snd_stm_conv_sources, list) {
! 			struct snd_stm_conv_group *group, *group_next;
! 
! 			list_for_each_entry_safe(group, group_next,
! 					&source->groups, list) {
! 				struct snd_stm_conv_converter *converter,
! 						*converter_next;
! 
! 				list_for_each_entry_safe(converter,
! 						converter_next,
! 						&group->converters, list) {
! 					list_del(&converter->list);
! 					snd_stm_magic_clear(converter);
! 					kfree(converter);
! 				}
! 				list_del(&group->list);
! 				snd_stm_magic_clear(group);
! 				kfree(group);
! 			}
! 			list_del(&source->list);
! 			snd_stm_magic_clear(source);
! 			kfree(source);
! 		}
! 	}
  }
--- 288,305 ----
   * Initialization
   */
  
  int __init snd_stm_conv_init(void)
  {
  	return 0;
  }
  
! void snd_stm_conv_cleanup(void)
  {
! 	struct snd_stm_conv_links_list *entry, *next;
  
! 	list_for_each_entry_safe(entry, next, &snd_stm_conv_links, list) {
! 		snd_stm_magic_clear(entry);
! 		list_del(&entry->list);
! 		kfree(entry);
! 	};
  }
diff -rcN linux-sh4-2.6.23.17_stm23_0119-orig/sound//stm/conv_dummy.c linux-sh4/sound//stm/conv_dummy.c
*** linux-sh4-2.6.23.17_stm23_0119-orig/sound//stm/conv_dummy.c	2009-06-06 20:17:15.000000000 +0200
--- linux-sh4/sound//stm/conv_dummy.c	2009-07-18 22:57:40.000000000 +0200
***************
*** 1,9 ****
  /*
!  *   STMicroelectronics System-on-Chips' dummy DAC driver
   *
   *   Copyright (c) 2005-2007 STMicroelectronics Limited
   *
!  *   Author: Pawel Moll <pawel.moll@st.com>
   *
   *   This program is free software; you can redistribute it and/or modify
   *   it under the terms of the GNU General Public License as published by
--- 1,9 ----
  /*
!  *   STMicroelectronics System-on-Chips' internal audio DAC driver
   *
   *   Copyright (c) 2005-2007 STMicroelectronics Limited
   *
!  *   Author: Pawel MOLL <pawel.moll@st.com>
   *
   *   This program is free software; you can redistribute it and/or modify
   *   it under the terms of the GNU General Public License as published by
***************
*** 26,81 ****
  #include <linux/platform_device.h>
  #include <sound/stm.h>
  
- #define COMPONENT conv_dummy
  #include "common.h"
  
  
- /*
-  * Dummy converter instance structure
-  */
- 
- struct snd_stm_conv_dummy {
- 	struct snd_stm_conv_converter *converter;
- 	struct snd_stm_conv_dummy_info *info;
- 
- 	snd_stm_magic_field;
- };
- 
- 
  
  /*
   * Converter interface implementation
   */
  
! static unsigned int snd_stm_conv_dummy_get_format(void *priv)
  {
! 	struct snd_stm_conv_dummy *conv_dummy = priv;
  
! 	snd_stm_printd(1, "snd_stm_conv_dummy_get_format(priv=%p)\n", priv);
  
! 	snd_stm_assert(conv_dummy, return -EINVAL);
! 	snd_stm_magic_assert(conv_dummy, return -EINVAL);
  
! 	return conv_dummy->info->format;
  }
  
! static int snd_stm_conv_dummy_get_oversampling(void *priv)
  {
! 	struct snd_stm_conv_dummy *conv_dummy = priv;
  
! 	snd_stm_printd(1, "snd_stm_conv_dummy_get_oversampling(priv=%p)\n",
! 			priv);
  
! 	snd_stm_assert(conv_dummy, return -EINVAL);
! 	snd_stm_magic_assert(conv_dummy, return -EINVAL);
  
! 	return conv_dummy->info->oversampling;
  }
  
! static struct snd_stm_conv_ops snd_stm_conv_dummy_ops = {
! 	.get_format = snd_stm_conv_dummy_get_format,
! 	.get_oversampling = snd_stm_conv_dummy_get_oversampling,
! };
  
  
  
--- 26,78 ----
  #include <linux/platform_device.h>
  #include <sound/stm.h>
  
  #include "common.h"
  
  
  
  /*
   * Converter interface implementation
   */
  
! static unsigned int snd_stm_conv_dummy_get_format(struct snd_stm_conv
! 		*conv)
  {
! 	return (SND_STM_FORMAT__RIGHT_JUSTIFIED |
! 			SND_STM_FORMAT__OUTPUT_SUBFRAME_16_BITS);
! }
  
! static int snd_stm_conv_dummy_get_oversampling(struct snd_stm_conv *conv)
! {
! 	return 64;
! }
  
! static int snd_stm_conv_dummy_enable(struct snd_stm_conv *conv)
! {
! 	snd_printk("Waking up dummy DAC '%s'.\n", conv->name);
  
! 	return 0;
  }
  
! static int snd_stm_conv_dummy_disable(struct snd_stm_conv *conv)
  {
! 	snd_printk("Setting dummy DAC '%s' into reset mode.\n", conv->name);
  
! 	return 0;
! }
  
! static int snd_stm_conv_dummy_mute(struct snd_stm_conv *conv)
! {
! 	snd_printk("Muting dummy DAC '%s'.\n", conv->name);
  
! 	return 0;
  }
  
! static int snd_stm_conv_dummy_unmute(struct snd_stm_conv *conv)
! {
! 	snd_printk("Unmuting dummy DAC '%s'.\n", conv->name);
! 
! 	return 0;
! }
  
  
  
***************
*** 83,145 ****
   * Platform driver routines
   */
  
! static int snd_stm_conv_dummy_probe(struct platform_device *pdev)
  {
! 	struct snd_stm_conv_dummy *conv_dummy;
  
! 	snd_stm_printd(0, "--- Probing device '%s'...\n", pdev->dev.bus_id);
  
! 	snd_stm_assert(pdev->dev.platform_data != NULL, return -EINVAL);
! 
! 	conv_dummy = kzalloc(sizeof(*conv_dummy), GFP_KERNEL);
! 	if (!conv_dummy) {
  		snd_stm_printe("Can't allocate memory "
  				"for a device description!\n");
  		return -ENOMEM;
  	}
- 	snd_stm_magic_set(conv_dummy);
- 	conv_dummy->info = pdev->dev.platform_data;
  
! 	snd_stm_printd(0, "This dummy DAC is attached to PCM player '%s'.\n",
! 			conv_dummy->info->source_bus_id);
! 	conv_dummy->converter = snd_stm_conv_register_converter(
! 			conv_dummy->info->group,
! 			&snd_stm_conv_dummy_ops, conv_dummy,
! 			&platform_bus_type, conv_dummy->info->source_bus_id,
! 			conv_dummy->info->channel_from,
! 			conv_dummy->info->channel_to, NULL);
! 	if (!conv_dummy->converter) {
  		snd_stm_printe("Can't attach to PCM player!\n");
  		return -EINVAL;
  	}
  
  	/* Done now */
  
! 	platform_set_drvdata(pdev, conv_dummy);
  
! 	snd_stm_printd(0, "--- Probed successfully!\n");
  
  	return 0;
  }
  
  static int snd_stm_conv_dummy_remove(struct platform_device *pdev)
  {
! 	struct snd_stm_conv_dummy *conv_dummy = platform_get_drvdata(pdev);
! 
! 	snd_stm_assert(conv_dummy, return -EINVAL);
! 	snd_stm_magic_assert(conv_dummy, return -EINVAL);
! 
! 	snd_stm_conv_unregister_converter(conv_dummy->converter);
! 
! 	snd_stm_magic_clear(conv_dummy);
! 	kfree(conv_dummy);
  
  	return 0;
  }
  
  static struct platform_driver snd_stm_conv_dummy_driver = {
  	.driver = {
! 		.name = "snd_conv_dummy",
  	},
  	.probe = snd_stm_conv_dummy_probe,
  	.remove = snd_stm_conv_dummy_remove,
--- 80,143 ----
   * Platform driver routines
   */
  
! static int __init snd_stm_conv_dummy_probe(struct platform_device *pdev)
  {
! 	int result;
! 	struct snd_stm_conv *conv;
! 	const char *source_bus_id = pdev->dev.platform_data;
! 	struct device *player_device;
! 	static int index;
  
! 	snd_printd("--- Probing device '%s'...\n", pdev->dev.bus_id);
  
! 	conv = kzalloc(sizeof(*conv) + 25, GFP_KERNEL);
! 	if (!conv) {
  		snd_stm_printe("Can't allocate memory "
  				"for a device description!\n");
  		return -ENOMEM;
  	}
  
! 	conv->name = (char *)conv + sizeof(*conv);
! 	sprintf((char *)conv->name, "Dummy converter %x", index++);
! 
! 	conv->get_format =
! 		snd_stm_conv_dummy_get_format;
! 	conv->get_oversampling =
! 		snd_stm_conv_dummy_get_oversampling;
! 	conv->enable = snd_stm_conv_dummy_enable;
! 	conv->disable = snd_stm_conv_dummy_disable;
! 	conv->mute = snd_stm_conv_dummy_mute;
! 	conv->unmute = snd_stm_conv_dummy_unmute;
! 
! 	snd_printd("This dummy DAC is attached to PCM player '%s'.\n",
! 			source_bus_id);
! 	player_device = snd_stm_find_device(NULL, source_bus_id);
! 	snd_assert(player_device != NULL, return -EINVAL);
! 	result = snd_stm_conv_attach(conv, player_device);
! 	if (result < 0) {
  		snd_stm_printe("Can't attach to PCM player!\n");
  		return -EINVAL;
  	}
  
  	/* Done now */
  
! 	platform_set_drvdata(pdev, conv);
  
! 	snd_printd("--- Probed successfully!\n");
  
  	return 0;
  }
  
  static int snd_stm_conv_dummy_remove(struct platform_device *pdev)
  {
! 	kfree(platform_get_drvdata(pdev));
  
  	return 0;
  }
  
  static struct platform_driver snd_stm_conv_dummy_driver = {
  	.driver = {
! 		.name = "conv_dummy",
  	},
  	.probe = snd_stm_conv_dummy_probe,
  	.remove = snd_stm_conv_dummy_remove,
***************
*** 151,169 ****
   * Initialization
   */
  
! static int __init snd_stm_conv_dummy_init(void)
  {
  	return platform_driver_register(&snd_stm_conv_dummy_driver);
  }
  
! static void __exit snd_stm_conv_dummy_exit(void)
  {
  	platform_driver_unregister(&snd_stm_conv_dummy_driver);
  }
- 
- MODULE_AUTHOR("Pawel Moll <pawel.moll@st.com>");
- MODULE_DESCRIPTION("STMicroelectronics dummy audio converter driver");
- MODULE_LICENSE("GPL");
- 
- module_init(snd_stm_conv_dummy_init);
- module_exit(snd_stm_conv_dummy_exit);
--- 149,160 ----
   * Initialization
   */
  
! int __init snd_stm_conv_dummy_init(void)
  {
  	return platform_driver_register(&snd_stm_conv_dummy_driver);
  }
  
! void snd_stm_conv_dummy_cleanup(void)
  {
  	platform_driver_unregister(&snd_stm_conv_dummy_driver);
  }
diff -rcN linux-sh4-2.6.23.17_stm23_0119-orig/sound//stm/conv_i2sspdif.c linux-sh4/sound//stm/conv_i2sspdif.c
*** linux-sh4-2.6.23.17_stm23_0119-orig/sound//stm/conv_i2sspdif.c	2009-06-06 20:17:15.000000000 +0200
--- linux-sh4/sound//stm/conv_i2sspdif.c	2009-07-18 22:39:41.000000000 +0200
***************
*** 3,9 ****
   *
   *   Copyright (c) 2005-2007 STMicroelectronics Limited
   *
!  *   Author: Pawel Moll <pawel.moll@st.com>
   *
   *   This program is free software; you can redistribute it and/or modify
   *   it under the terms of the GNU General Public License as published by
--- 3,9 ----
   *
   *   Copyright (c) 2005-2007 STMicroelectronics Limited
   *
!  *   Author: Pawel MOLL <pawel.moll@st.com>
   *
   *   This program is free software; you can redistribute it and/or modify
   *   it under the terms of the GNU General Public License as published by
***************
*** 26,39 ****
  #include <linux/platform_device.h>
  #include <linux/list.h>
  #include <linux/spinlock.h>
  #include <sound/driver.h>
  #include <sound/core.h>
  #include <sound/info.h>
  #include <sound/stm.h>
  
! #define COMPONENT conv_i2sspdif
  #include "common.h"
- #include "reg_aud_spdifpc.h"
  
  
  
--- 26,41 ----
  #include <linux/platform_device.h>
  #include <linux/list.h>
  #include <linux/spinlock.h>
+ #include <linux/stm/soc.h>
+ #include <linux/stm/registers.h>
  #include <sound/driver.h>
  #include <sound/core.h>
  #include <sound/info.h>
  #include <sound/stm.h>
  
! #undef TRACE /* See common.h debug features */
! #define MAGIC 3 /* See common.h debug features */
  #include "common.h"
  
  
  
***************
*** 49,61 ****
   * Converter instance structure
   */
  
! struct snd_stm_conv_i2sspdif {
  	/* System informations */
! 	struct snd_stm_conv_converter *converter;
! 	struct snd_stm_conv_i2sspdif_info *info;
  	struct device *device;
- 	int index; /* ALSA controls index */
- 	int ver; /* IP version, used by register access macros */
  
  	/* Resources */
  	struct resource *mem_region;
--- 51,63 ----
   * Converter instance structure
   */
  
! struct snd_stm_conv_i2s_spdif {
! 	/* Generic converter interface */
! 	struct snd_stm_conv conv;
! 
  	/* System informations */
! 	struct snd_stm_conv_i2s_spdif_info *info;
  	struct device *device;
  
  	/* Resources */
  	struct resource *mem_region;
***************
*** 67,72 ****
--- 69,75 ----
  
  	/* Runtime data */
  	int enabled;
+ 	struct snd_stm_conv *attached_conv;
  
  	struct snd_info_entry *proc_entry;
  
***************
*** 80,117 ****
   */
  
  /* Such a empty (zeroed) structure is pretty useful later... ;-) */
! static struct snd_aes_iec958 snd_stm_conv_i2sspdif_iec958_zeroed;
  
  
  
  #define CHA_STA_TRIES 50000
  
! static int snd_stm_conv_i2sspdif_iec958_set(struct snd_stm_conv_i2sspdif
! 		*conv_i2sspdif, struct snd_aes_iec958 *iec958)
  {
  	int i, j, ok;
  	unsigned long status[6];
  
! 	snd_stm_printd(1, "snd_stm_conv_i2sspdif_iec958_set(conv_i2sspdif=%p"
! 			", iec958=%p)\n", conv_i2sspdif, iec958);
  
! 	snd_stm_assert(conv_i2sspdif, return -EINVAL);
! 	snd_stm_magic_assert(conv_i2sspdif, return -EINVAL);
  
  	/* I2S to SPDIF converter should be used only for playing
  	 * PCM (non compressed) data, so validity bit should be always
  	 * zero... (it means "valid linear PCM data") */
! 	set__AUD_SPDIFPC_VAL__VALIDITY_BITS(conv_i2sspdif, 0);
  
  	/* Well... User data bit... Frankly speaking there is no way
  	 * of correctly setting them with a mechanism provided by
  	 * converter hardware, so it is better not to do this at all... */
! 	set__AUD_SPDIFPC_DATA__USER_DATA_BITS(conv_i2sspdif, 0);
! 
! 	snd_stm_assert(memcmp(snd_stm_conv_i2sspdif_iec958_zeroed.subcode,
  			iec958->subcode, sizeof(iec958->subcode)) == 0);
  
! 	if (conv_i2sspdif->ver < ver__AUD_SPDIFPC__65_3_0) {
  		/* Converter hardware by default puts every single bit of
  		 * status to separate SPDIF subframe (instead of putting
  		 * the same bit to both left and right subframes).
--- 83,120 ----
   */
  
  /* Such a empty (zeroed) structure is pretty useful later... ;-) */
! static struct snd_aes_iec958 snd_stm_conv_i2s_spdif_iec958_zeroed;
  
  
  
  #define CHA_STA_TRIES 50000
  
! static int snd_stm_conv_i2s_spdif_iec958_set(struct snd_stm_conv_i2s_spdif
! 		*conv_i2s_spdif, struct snd_aes_iec958 *iec958)
  {
  	int i, j, ok;
  	unsigned long status[6];
  
! 	snd_stm_printt("snd_stm_conv_i2s_spdif_iec958_set(conv_i2s_spdif=%p, "
! 			"iec958=%p)\n", conv_i2s_spdif, iec958);
  
! 	snd_assert(conv_i2s_spdif, return -EINVAL);
! 	snd_stm_magic_assert(conv_i2s_spdif, return -EINVAL);
  
  	/* I2S to SPDIF converter should be used only for playing
  	 * PCM (non compressed) data, so validity bit should be always
  	 * zero... (it means "valid linear PCM data") */
! 	REGFIELD_POKE(conv_i2s_spdif->base, AUD_SPDIFPC_VAL, VALIDITY_BITS, 0);
  
  	/* Well... User data bit... Frankly speaking there is no way
  	 * of correctly setting them with a mechanism provided by
  	 * converter hardware, so it is better not to do this at all... */
! 	REGFIELD_POKE(conv_i2s_spdif->base, AUD_SPDIFPC_DATA,
! 			USER_DATA_BITS, 0);
! 	snd_assert(memcmp(snd_stm_conv_i2s_spdif_iec958_zeroed.subcode,
  			iec958->subcode, sizeof(iec958->subcode)) == 0);
  
! 	if (conv_i2s_spdif->info->full_channel_status == 0) {
  		/* Converter hardware by default puts every single bit of
  		 * status to separate SPDIF subframe (instead of putting
  		 * the same bit to both left and right subframes).
***************
*** 158,170 ****
  
  	ok = 0;
  	for (i = 0; i < CHA_STA_TRIES; i++) {
! 		if (get__AUD_SPDIFPC_STA__CHL_STS_BUFF_EMPTY(conv_i2sspdif)) {
  			for (j = 0; j < 6; j++)
! 				set__AUD_SPDIFPC_CHA_STA(conv_i2sspdif, j,
! 						status[j]);
  			ok = 1;
  			for (j = 0; j < 6; j++)
! 				if (get__AUD_SPDIFPC_CHA_STA(conv_i2sspdif,
  						j) != status[j]) {
  					ok = 0;
  					break;
--- 161,176 ----
  
  	ok = 0;
  	for (i = 0; i < CHA_STA_TRIES; i++) {
! 		if (REGFIELD_PEEK(conv_i2s_spdif->base,
! 				AUD_SPDIFPC_STA, CHL_STS_BUFF_EMPTY)) {
  			for (j = 0; j < 6; j++)
! 				REGISTER_POKE_N(conv_i2s_spdif->base,
! 						AUD_SPDIFPC_CHA_STA,
! 						j, status[j]);
  			ok = 1;
  			for (j = 0; j < 6; j++)
! 				if (REGISTER_PEEK_N(conv_i2s_spdif->base,
! 						AUD_SPDIFPC_CHA_STA,
  						j) != status[j]) {
  					ok = 0;
  					break;
***************
*** 176,196 ****
  	if (!ok) {
  		snd_stm_printe("WARNING! Failed to set channel status registers"
  				" for converter %s! (tried %d times)\n",
! 				conv_i2sspdif->device->bus_id, i);
  		return -EINVAL;
  	}
  
! 	snd_stm_printd(1, "Channel status registers set successfully "
! 			"in %i tries.\n", i);
  
  	/* Set SPDIF player's VUC registers (these are used only
  	 * for mute data formatting, and it should never happen ;-) */
  
! 	set__AUD_SPDIFPC_SUV__VAL_LEFT(conv_i2sspdif, 0);
! 	set__AUD_SPDIFPC_SUV__VAL_RIGHT(conv_i2sspdif, 0);
! 
! 	set__AUD_SPDIFPC_SUV__DATA_LEFT(conv_i2sspdif, 0);
! 	set__AUD_SPDIFPC_SUV__DATA_RIGHT(conv_i2sspdif, 0);
  
  	/* And this time the problem is that SPDIF player lets
  	 * to set only first 36 bits of channel status bits...
--- 182,206 ----
  	if (!ok) {
  		snd_stm_printe("WARNING! Failed to set channel status registers"
  				" for converter %s! (tried %d times)\n",
! 				conv_i2s_spdif->device->bus_id, i);
  		return -EINVAL;
  	}
  
! 	snd_stm_printt("Channel status registers set successfully "
! 			"in %i tries.", i);
  
  	/* Set SPDIF player's VUC registers (these are used only
  	 * for mute data formatting, and it should never happen ;-) */
  
! 	REGFIELD_POKE(conv_i2s_spdif->base, AUD_SPDIFPC_SUV,
! 			VAL_LEFT, 0);
! 	REGFIELD_POKE(conv_i2s_spdif->base, AUD_SPDIFPC_SUV,
! 			VAL_RIGHT, 0);
! 
! 	REGFIELD_POKE(conv_i2s_spdif->base, AUD_SPDIFPC_SUV,
! 			DATA_LEFT, 0);
! 	REGFIELD_POKE(conv_i2s_spdif->base, AUD_SPDIFPC_SUV,
! 			DATA_RIGHT, 0);
  
  	/* And this time the problem is that SPDIF player lets
  	 * to set only first 36 bits of channel status bits...
***************
*** 198,252 ****
  	 * it puts channel status bits to both subframes :-) */
  	status[0] = iec958->status[0] | iec958->status[1] << 8 |
  		iec958->status[2] << 16 | iec958->status[3] << 24;
! 	set__AUD_SPDIFPC_CL1__CHANNEL_STATUS(conv_i2sspdif, status[0]);
! 	set__AUD_SPDIFPC_SUV__CH_STA_LEFT(conv_i2sspdif,
! 			iec958->status[4] & 0xf);
! 	set__AUD_SPDIFPC_CR1__CH_STA(conv_i2sspdif, status[0]);
! 	set__AUD_SPDIFPC_SUV__CH_STA_RIGHT(conv_i2sspdif,
! 			iec958->status[4] & 0xf);
  
  	return 0;
  }
  
! static inline int snd_stm_conv_i2sspdif_oversampling(
! 		struct snd_stm_conv_i2sspdif *conv_i2sspdif)
  {
! 	snd_stm_printd(1, "snd_stm_conv_i2sspdif_oversampling("
! 			"conv_i2sspdif=%p)\n", conv_i2sspdif);
  
! 	snd_stm_assert(conv_i2sspdif, return -EINVAL);
! 	snd_stm_magic_assert(conv_i2sspdif, return -EINVAL);
  
! 	return DEFAULT_OVERSAMPLING;
  }
  
! static inline int snd_stm_conv_i2sspdif_enable(struct snd_stm_conv_i2sspdif
! 		*conv_i2sspdif)
  {
  	int oversampling;
  	struct snd_aes_iec958 iec958;
  
! 	snd_stm_printd(1, "snd_stm_conv_i2sspdif_enable(conv_i2sspdif=%p)\n",
! 			conv_i2sspdif);
  
! 	snd_stm_assert(conv_i2sspdif, return -EINVAL);
! 	snd_stm_magic_assert(conv_i2sspdif, return -EINVAL);
! 	snd_stm_assert(!conv_i2sspdif->enabled, return -EINVAL);
! 
! 	oversampling = snd_stm_conv_i2sspdif_oversampling(conv_i2sspdif);
! 	snd_stm_assert(oversampling > 0, return -EINVAL);
! 	snd_stm_assert((oversampling % 128) == 0, return -EINVAL);
! 
! 	set__AUD_SPDIFPC_CFG(conv_i2sspdif,
! 		mask__AUD_SPDIFPC_CFG__DEVICE_EN__ENABLED(conv_i2sspdif) |
! 		mask__AUD_SPDIFPC_CFG__SW_RESET__RUNNING(conv_i2sspdif) |
! 		mask__AUD_SPDIFPC_CFG__FIFO_EN__ENABLED(conv_i2sspdif) |
! 		mask__AUD_SPDIFPC_CFG__AUDIO_WORD_SIZE__24_BITS(conv_i2sspdif)
! 		| mask__AUD_SPDIFPC_CFG__REQ_ACK_EN__ENABLED(conv_i2sspdif));
! 	set__AUD_SPDIFPC_CTRL(conv_i2sspdif,
! 		mask__AUD_SPDIFPC_CTRL__OPERATION__PCM(conv_i2sspdif) |
! 		mask__AUD_SPDIFPC_CTRL__ROUNDING__NO_ROUNDING(conv_i2sspdif));
! 	set__AUD_SPDIFPC_CTRL__DIVIDER(conv_i2sspdif, oversampling / 128);
  
  	/* Full channel status processing - an undocumented feature that
  	 * exists in some hardware... Normally channel status registers
--- 208,305 ----
  	 * it puts channel status bits to both subframes :-) */
  	status[0] = iec958->status[0] | iec958->status[1] << 8 |
  		iec958->status[2] << 16 | iec958->status[3] << 24;
! 	REGFIELD_POKE(conv_i2s_spdif->base, AUD_SPDIFPC_CL1,
! 			CHANNEL_STATUS, status[0]);
! 	REGFIELD_POKE(conv_i2s_spdif->base, AUD_SPDIFPC_SUV,
! 			CH_STA_LEFT, iec958->status[4] & 0xf);
! 	REGFIELD_POKE(conv_i2s_spdif->base, AUD_SPDIFPC_CR1,
! 			CH_STA, status[0]);
! 	REGFIELD_POKE(conv_i2s_spdif->base, AUD_SPDIFPC_SUV,
! 			CH_STA_RIGHT, iec958->status[4] & 0xf);
  
  	return 0;
  }
  
! 
! 
! 
! /*
!  * Converter interface implementation
!  */
! 
! static unsigned int snd_stm_conv_i2s_spdif_get_format(struct snd_stm_conv
! 		*conv)
! {
! 	snd_stm_printt("snd_stm_conv_i2s_spdif_get_format(conv=%p)\n", conv);
! 
! 	return (SND_STM_FORMAT__I2S | SND_STM_FORMAT__OUTPUT_SUBFRAME_32_BITS);
! }
! 
! static int snd_stm_conv_i2s_spdif_get_oversampling(struct snd_stm_conv *conv)
  {
! 	int oversampling = 0;
! 	struct snd_stm_conv_i2s_spdif *conv_i2s_spdif = container_of(conv,
! 			struct snd_stm_conv_i2s_spdif, conv);
! 
! 	snd_stm_printt("snd_stm_conv_i2s_spdif_get_oversampling(conv=%p)\n",
! 			conv);
! 
! 	snd_assert(conv_i2s_spdif, return -EINVAL);
! 	snd_stm_magic_assert(conv_i2s_spdif, return -EINVAL);
! 
! 	if (conv_i2s_spdif->attached_conv)
! 		oversampling = snd_stm_conv_get_oversampling(
! 				conv_i2s_spdif->attached_conv);
  
! 	if (oversampling == 0)
! 		oversampling = DEFAULT_OVERSAMPLING;
  
! 	return oversampling;
  }
  
! static int snd_stm_conv_i2s_spdif_enable(struct snd_stm_conv *conv)
  {
+ 	struct snd_stm_conv_i2s_spdif *conv_i2s_spdif = container_of(conv,
+ 			struct snd_stm_conv_i2s_spdif, conv);
  	int oversampling;
  	struct snd_aes_iec958 iec958;
  
! 	snd_stm_printt("snd_stm_conv_i2s_spdif_enable(conv=%p)\n", conv);
  
! 	snd_assert(conv_i2s_spdif, return -EINVAL);
! 	snd_stm_magic_assert(conv_i2s_spdif, return -EINVAL);
! 	snd_assert(!conv_i2s_spdif->enabled, return -EINVAL);
! 
! 	snd_stm_printt("Enabling I2S to SPDIF converter '%s'.\n",
! 			conv_i2s_spdif->device->bus_id);
! 
! 	conv_i2s_spdif->attached_conv =
! 			snd_stm_conv_get_attached(conv_i2s_spdif->device);
! 	if (conv_i2s_spdif->attached_conv) {
! 		int result = snd_stm_conv_enable(conv_i2s_spdif->attached_conv);
! 		if (result != 0) {
! 			snd_stm_printe("Can't enable attached converter!\n");
! 			return result;
! 		}
! 	}
! 
! 	oversampling = snd_stm_conv_i2s_spdif_get_oversampling(conv);
! 	snd_assert(oversampling > 0, return -EINVAL);
! 	snd_assert((oversampling % 128) == 0, return -EINVAL);
! 
! 	REGISTER_POKE(conv_i2s_spdif->base, AUD_SPDIFPC_CFG,
! 			REGFIELD_VALUE(AUD_SPDIFPC_CFG, DEVICE_EN, ENABLED) |
! 			REGFIELD_VALUE(AUD_SPDIFPC_CFG, SW_RESET, RUNNING) |
! 			REGFIELD_VALUE(AUD_SPDIFPC_CFG, FIFO_EN, ENABLED) |
! 			REGFIELD_VALUE(AUD_SPDIFPC_CFG, AUDIO_WORD_SIZE,
! 					24_BITS) |
! 			REGFIELD_VALUE(AUD_SPDIFPC_CFG, REQ_ACK_EN, ENABLED));
! 	REGISTER_POKE(conv_i2s_spdif->base, AUD_SPDIFPC_CTRL,
! 			REGFIELD_VALUE(AUD_SPDIFPC_CTRL, OPERATION, PCM) |
! 			REGFIELD_VALUE(AUD_SPDIFPC_CTRL, ROUNDING,
! 					NO_ROUNDING));
! 	REGFIELD_POKE(conv_i2s_spdif->base, AUD_SPDIFPC_CTRL, DIVIDER,
! 			oversampling / 128);
  
  	/* Full channel status processing - an undocumented feature that
  	 * exists in some hardware... Normally channel status registers
***************
*** 254,409 ****
  	 * of SPDIF block) - pathetic! ;-) Setting bit 6 of config register
  	 * enables a mode in which channel status bits in L/R subframes
  	 * are identical, and whole block is served... */
! 	if (conv_i2sspdif->ver >= ver__AUD_SPDIFPC__65_3_0)
! 		set__AUD_SPDIFPC_CFG__CHA_STA_BITS__FRAME(conv_i2sspdif);
! 
! 	spin_lock(&conv_i2sspdif->iec958_default_lock);
! 	iec958 = conv_i2sspdif->iec958_default;
! 	spin_unlock(&conv_i2sspdif->iec958_default_lock);
! 	if (snd_stm_conv_i2sspdif_iec958_set(conv_i2sspdif, &iec958) != 0)
  		snd_stm_printe("WARNING! Can't set channel status "
  				"registers!\n");
  
! 	conv_i2sspdif->enabled = 1;
  
  	return 0;
  }
  
! static inline int snd_stm_conv_i2sspdif_disable(struct snd_stm_conv_i2sspdif
! 		*conv_i2sspdif)
  {
! 	snd_stm_printd(1, "snd_stm_conv_i2sspdif_disable(conv_i2sspdif=%p)\n",
! 			conv_i2sspdif);
! 
! 	snd_stm_assert(conv_i2sspdif, return -EINVAL);
! 	snd_stm_magic_assert(conv_i2sspdif, return -EINVAL);
! 	snd_stm_assert(conv_i2sspdif->enabled, return -EINVAL);
  
! 	if (snd_stm_conv_i2sspdif_iec958_set(conv_i2sspdif,
! 			&snd_stm_conv_i2sspdif_iec958_zeroed) != 0)
! 		snd_stm_printe("WARNING! Failed to clear channel status "
! 				"registers!\n");
  
! 	set__AUD_SPDIFPC_CFG(conv_i2sspdif,
! 		mask__AUD_SPDIFPC_CFG__DEVICE_EN__DISABLED(conv_i2sspdif) |
! 		mask__AUD_SPDIFPC_CFG__SW_RESET__RESET(conv_i2sspdif) |
! 		mask__AUD_SPDIFPC_CFG__FIFO_EN__DISABLED(conv_i2sspdif) |
! 		mask__AUD_SPDIFPC_CFG__REQ_ACK_EN__DISABLED(conv_i2sspdif));
! 	set__AUD_SPDIFPC_CTRL(conv_i2sspdif,
! 		mask__AUD_SPDIFPC_CTRL__OPERATION__OFF(conv_i2sspdif));
  
! 	conv_i2sspdif->enabled = 0;
  
! 	return 0;
! }
  
  
  
! /*
!  * Converter interface implementation
!  */
  
! static unsigned int snd_stm_conv_i2sspdif_get_format(void *priv)
! {
! 	snd_stm_printd(1, "snd_stm_conv_i2sspdif_get_format(priv=%p)\n", priv);
  
! 	return (SND_STM_FORMAT__I2S | SND_STM_FORMAT__SUBFRAME_32_BITS);
  }
  
! static int snd_stm_conv_i2sspdif_get_oversampling(void *priv)
  {
! 	struct snd_stm_conv_i2sspdif *conv_i2sspdif = priv;
  
! 	snd_stm_printd(1, "snd_stm_conv_i2sspdif_get_oversampling(priv=%p)\n",
! 			priv);
  
! 	snd_stm_assert(conv_i2sspdif, return -EINVAL);
! 	snd_stm_magic_assert(conv_i2sspdif, return -EINVAL);
  
! 	return snd_stm_conv_i2sspdif_oversampling(conv_i2sspdif);
  }
  
! static int snd_stm_conv_i2sspdif_set_enabled(int enabled, void *priv)
  {
! 	struct snd_stm_conv_i2sspdif *conv_i2sspdif = priv;
  
! 	snd_stm_printd(1, "snd_stm_conv_i2sspdif_set_enabled(enabled=%d, "
! 			"priv=%p)\n", enabled, priv);
  
! 	snd_stm_assert(conv_i2sspdif, return -EINVAL);
! 	snd_stm_magic_assert(conv_i2sspdif, return -EINVAL);
  
! 	snd_stm_printd(1, "%sabling I2S to SPDIF converter '%s'.\n",
! 			enabled ? "En" : "Dis", conv_i2sspdif->device->bus_id);
  
! 	if (enabled)
! 		return snd_stm_conv_i2sspdif_enable(conv_i2sspdif);
! 	else
! 		return snd_stm_conv_i2sspdif_disable(conv_i2sspdif);
  }
  
- static struct snd_stm_conv_ops snd_stm_conv_i2sspdif_ops = {
- 	.get_format = snd_stm_conv_i2sspdif_get_format,
- 	.get_oversampling = snd_stm_conv_i2sspdif_get_oversampling,
- 	.set_enabled = snd_stm_conv_i2sspdif_set_enabled,
- };
- 
  
  
  /*
   * ALSA controls
   */
  
! static int snd_stm_conv_i2sspdif_ctl_default_get(struct snd_kcontrol *kcontrol,
  		struct snd_ctl_elem_value *ucontrol)
  {
! 	struct snd_stm_conv_i2sspdif *conv_i2sspdif =
  			snd_kcontrol_chip(kcontrol);
  
! 	snd_stm_printd(1, "snd_stm_conv_i2sspdif_ctl_default_get("
  			"kcontrol=0x%p, ucontrol=0x%p)\n", kcontrol, ucontrol);
  
! 	snd_stm_assert(conv_i2sspdif, return -EINVAL);
! 	snd_stm_magic_assert(conv_i2sspdif, return -EINVAL);
  
! 	spin_lock(&conv_i2sspdif->iec958_default_lock);
! 	ucontrol->value.iec958 = conv_i2sspdif->iec958_default;
! 	spin_unlock(&conv_i2sspdif->iec958_default_lock);
  
  	return 0;
  }
  
! static int snd_stm_conv_i2sspdif_ctl_default_put(struct snd_kcontrol *kcontrol,
  		struct snd_ctl_elem_value *ucontrol)
  {
! 	struct snd_stm_conv_i2sspdif *conv_i2sspdif =
  			snd_kcontrol_chip(kcontrol);
  	int changed = 0;
  
! 	snd_stm_printd(1, "snd_stm_conv_i2sspdif_ctl_default_put("
  			"kcontrol=0x%p, ucontrol=0x%p)\n", kcontrol, ucontrol);
  
! 	snd_stm_assert(conv_i2sspdif, return -EINVAL);
! 	snd_stm_magic_assert(conv_i2sspdif, return -EINVAL);
  
! 	spin_lock(&conv_i2sspdif->iec958_default_lock);
! 	if (snd_stm_iec958_cmp(&conv_i2sspdif->iec958_default,
  				&ucontrol->value.iec958) != 0) {
! 		conv_i2sspdif->iec958_default = ucontrol->value.iec958;
  		changed = 1;
  	}
! 	spin_unlock(&conv_i2sspdif->iec958_default_lock);
  
  	return changed;
  }
  
! static struct snd_kcontrol_new snd_stm_conv_i2sspdif_ctls[] = {
  	{
  		.iface = SNDRV_CTL_ELEM_IFACE_PCM,
  		.name = SNDRV_CTL_NAME_IEC958("", PLAYBACK, DEFAULT),
  		.info = snd_stm_ctl_iec958_info,
! 		.get = snd_stm_conv_i2sspdif_ctl_default_get,
! 		.put = snd_stm_conv_i2sspdif_ctl_default_put,
  	}, {
  		.access = SNDRV_CTL_ELEM_ACCESS_READ,
  		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
--- 307,462 ----
  	 * of SPDIF block) - pathetic! ;-) Setting bit 6 of config register
  	 * enables a mode in which channel status bits in L/R subframes
  	 * are identical, and whole block is served... */
! 	if (conv_i2s_spdif->info->full_channel_status)
! 		REGFIELD_SET(conv_i2s_spdif->base, AUD_SPDIFPC_CFG,
! 				CHA_STA_BITS, FRAME);
! 
! 	spin_lock(&conv_i2s_spdif->iec958_default_lock);
! 	iec958 = conv_i2s_spdif->iec958_default;
! 	spin_unlock(&conv_i2s_spdif->iec958_default_lock);
! 	if (snd_stm_conv_i2s_spdif_iec958_set(conv_i2s_spdif, &iec958) != 0)
  		snd_stm_printe("WARNING! Can't set channel status "
  				"registers!\n");
  
! 	conv_i2s_spdif->enabled = 1;
  
  	return 0;
  }
  
! static int snd_stm_conv_i2s_spdif_disable(struct snd_stm_conv *conv)
  {
! 	struct snd_stm_conv_i2s_spdif *conv_i2s_spdif = container_of(conv,
! 			struct snd_stm_conv_i2s_spdif, conv);
  
! 	snd_stm_printt("snd_stm_conv_i2s_spdif_disable(conv=%p)\n", conv);
  
! 	snd_assert(conv_i2s_spdif, return -EINVAL);
! 	snd_stm_magic_assert(conv_i2s_spdif, return -EINVAL);
! 	snd_assert(conv_i2s_spdif->enabled, return -EINVAL);
  
! 	snd_stm_printt("Disabling I2S to SPDIF converter '%s'\n",
! 			conv_i2s_spdif->device->bus_id);
  
! 	if (conv_i2s_spdif->attached_conv) {
! 		int result = snd_stm_conv_disable(
! 				conv_i2s_spdif->attached_conv);
  
+ 		if (result != 0) {
+ 			snd_stm_printe("Can't disable attached converter!\n");
+ 			return result;
+ 		}
+ 	}
  
+ 	if (snd_stm_conv_i2s_spdif_iec958_set(conv_i2s_spdif,
+ 			&snd_stm_conv_i2s_spdif_iec958_zeroed) != 0)
+ 		snd_stm_printe("WARNING! Failed to clear channel status "
+ 				"registers!\n");
  
! 	REGISTER_POKE(conv_i2s_spdif->base, AUD_SPDIFPC_CFG,
! 			REGFIELD_VALUE(AUD_SPDIFPC_CFG, DEVICE_EN, DISABLED) |
! 			REGFIELD_VALUE(AUD_SPDIFPC_CFG, SW_RESET, RESET) |
! 			REGFIELD_VALUE(AUD_SPDIFPC_CFG, FIFO_EN, DISABLED) |
! 			REGFIELD_VALUE(AUD_SPDIFPC_CFG, REQ_ACK_EN, DISABLED));
! 	REGISTER_POKE(conv_i2s_spdif->base, AUD_SPDIFPC_CTRL,
! 			REGFIELD_VALUE(AUD_SPDIFPC_CTRL, OPERATION, OFF));
  
! 	conv_i2s_spdif->enabled = 0;
  
! 	return 0;
  }
  
! static int snd_stm_conv_i2s_spdif_mute(struct snd_stm_conv *conv)
  {
! 	int result = 0;
! 	struct snd_stm_conv_i2s_spdif *conv_i2s_spdif = container_of(conv,
! 			struct snd_stm_conv_i2s_spdif, conv);
  
! 	snd_stm_printt("snd_stm_conv_i2s_spdif_mute(conv=%p)\n", conv);
  
! 	snd_assert(conv_i2s_spdif, return -EINVAL);
! 	snd_stm_magic_assert(conv_i2s_spdif, return -EINVAL);
! 	snd_assert(conv_i2s_spdif->enabled, return -EINVAL);
  
! 	if (conv_i2s_spdif->attached_conv)
! 		result = snd_stm_conv_mute(conv_i2s_spdif->attached_conv);
! 
! 	return result;
  }
  
! static int snd_stm_conv_i2s_spdif_unmute(struct snd_stm_conv *conv)
  {
! 	int result = 0;
! 	struct snd_stm_conv_i2s_spdif *conv_i2s_spdif = container_of(conv,
! 			struct snd_stm_conv_i2s_spdif, conv);
  
! 	snd_stm_printt("snd_stm_conv_i2s_spdif_unmute(conv=%p)\n", conv);
  
! 	snd_assert(conv_i2s_spdif, return -EINVAL);
! 	snd_stm_magic_assert(conv_i2s_spdif, return -EINVAL);
! 	snd_assert(conv_i2s_spdif->enabled, return -EINVAL);
  
! 	if (conv_i2s_spdif->attached_conv)
! 		result = snd_stm_conv_unmute(conv_i2s_spdif->attached_conv);
  
! 	return result;
  }
  
  
  
  /*
   * ALSA controls
   */
  
! static int snd_stm_conv_i2s_spdif_ctl_default_get(struct snd_kcontrol *kcontrol,
  		struct snd_ctl_elem_value *ucontrol)
  {
! 	struct snd_stm_conv_i2s_spdif *conv_i2s_spdif =
  			snd_kcontrol_chip(kcontrol);
  
! 	snd_stm_printt("snd_stm_conv_i2s_spdif_ctl_default_get("
  			"kcontrol=0x%p, ucontrol=0x%p)\n", kcontrol, ucontrol);
  
! 	snd_assert(conv_i2s_spdif, return -EINVAL);
! 	snd_stm_magic_assert(conv_i2s_spdif, return -EINVAL);
  
! 	spin_lock(&conv_i2s_spdif->iec958_default_lock);
! 	ucontrol->value.iec958 = conv_i2s_spdif->iec958_default;
! 	spin_unlock(&conv_i2s_spdif->iec958_default_lock);
  
  	return 0;
  }
  
! static int snd_stm_conv_i2s_spdif_ctl_default_put(struct snd_kcontrol *kcontrol,
  		struct snd_ctl_elem_value *ucontrol)
  {
! 	struct snd_stm_conv_i2s_spdif *conv_i2s_spdif =
  			snd_kcontrol_chip(kcontrol);
  	int changed = 0;
  
! 	snd_stm_printt("snd_stm_conv_i2s_spdif_ctl_default_put("
  			"kcontrol=0x%p, ucontrol=0x%p)\n", kcontrol, ucontrol);
  
! 	snd_assert(conv_i2s_spdif, return -EINVAL);
! 	snd_stm_magic_assert(conv_i2s_spdif, return -EINVAL);
  
! 	spin_lock(&conv_i2s_spdif->iec958_default_lock);
! 	if (snd_stm_iec958_cmp(&conv_i2s_spdif->iec958_default,
  				&ucontrol->value.iec958) != 0) {
! 		conv_i2s_spdif->iec958_default = ucontrol->value.iec958;
  		changed = 1;
  	}
! 	spin_unlock(&conv_i2s_spdif->iec958_default_lock);
  
  	return changed;
  }
  
! static struct snd_kcontrol_new __initdata snd_stm_conv_i2s_spdif_ctls[] = {
  	{
  		.iface = SNDRV_CTL_ELEM_IFACE_PCM,
  		.name = SNDRV_CTL_NAME_IEC958("", PLAYBACK, DEFAULT),
  		.info = snd_stm_ctl_iec958_info,
! 		.get = snd_stm_conv_i2s_spdif_ctl_default_get,
! 		.put = snd_stm_conv_i2s_spdif_ctl_default_put,
  	}, {
  		.access = SNDRV_CTL_ELEM_ACCESS_READ,
  		.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
***************
*** 428,448 ****
  #define DUMP_REGISTER(r) \
  		snd_iprintf(buffer, "AUD_SPDIFPC_%s (offset 0x%03x) =" \
  				" 0x%08x\n", __stringify(r), \
! 				offset__AUD_SPDIFPC_##r(conv_i2sspdif), \
! 				get__AUD_SPDIFPC_##r(conv_i2sspdif))
  
! static void snd_stm_conv_i2sspdif_dump_registers(struct snd_info_entry *entry,
  		struct snd_info_buffer *buffer)
  {
! 	struct snd_stm_conv_i2sspdif *conv_i2sspdif =
  		entry->private_data;
  	int i;
  
! 	snd_stm_assert(conv_i2sspdif, return);
! 	snd_stm_magic_assert(conv_i2sspdif, return);
! 
! 	snd_iprintf(buffer, "--- %s ---\n", conv_i2sspdif->device->bus_id);
! 	snd_iprintf(buffer, "base = 0x%p\n", conv_i2sspdif->base);
  
  	DUMP_REGISTER(CFG);
  	DUMP_REGISTER(STA);
--- 481,499 ----
  #define DUMP_REGISTER(r) \
  		snd_iprintf(buffer, "AUD_SPDIFPC_%s (offset 0x%03x) =" \
  				" 0x%08x\n", __stringify(r), \
! 				AUD_SPDIFPC_##r, \
! 				REGISTER_PEEK(conv_i2s_spdif->base, \
! 				AUD_SPDIFPC_##r))
  
! static void snd_stm_conv_i2s_spdif_dump_registers(struct snd_info_entry *entry,
  		struct snd_info_buffer *buffer)
  {
! 	struct snd_stm_conv_i2s_spdif *conv_i2s_spdif =
  		entry->private_data;
  	int i;
  
! 	snd_assert(conv_i2s_spdif, return);
! 	snd_stm_magic_assert(conv_i2s_spdif, return);
  
  	DUMP_REGISTER(CFG);
  	DUMP_REGISTER(STA);
***************
*** 453,461 ****
  	DUMP_REGISTER(DATA);
  	for (i = 0; i <= 5; i++)
  		snd_iprintf(buffer, "AUD_SPDIFPC_CHA_STA%d_CHANNEL_STATUS_BITS"
! 				" (offset 0x%03x) = 0x%08x\n", i,
! 				offset__AUD_SPDIFPC_CHA_STA(conv_i2sspdif, i),
! 				get__AUD_SPDIFPC_CHA_STA(conv_i2sspdif, i));
  	DUMP_REGISTER(CTRL);
  	DUMP_REGISTER(SPDIFSTA);
  	DUMP_REGISTER(PAUSE);
--- 504,513 ----
  	DUMP_REGISTER(DATA);
  	for (i = 0; i <= 5; i++)
  		snd_iprintf(buffer, "AUD_SPDIFPC_CHA_STA%d_CHANNEL_STATUS_BITS"
! 				" (offset 0x%03x) = 0x%08x\n",
! 				i, AUD_SPDIFPC_CHA_STA(i),
! 				REGISTER_PEEK_N(conv_i2s_spdif->base,
! 				AUD_SPDIFPC_CHA_STA, i));
  	DUMP_REGISTER(CTRL);
  	DUMP_REGISTER(SPDIFSTA);
  	DUMP_REGISTER(PAUSE);
***************
*** 465,565 ****
  	DUMP_REGISTER(CL1);
  	DUMP_REGISTER(CR1);
  	DUMP_REGISTER(SUV);
- 
- 	snd_iprintf(buffer, "\n");
  }
  
! static int snd_stm_conv_i2sspdif_register(
! 		struct snd_device *snd_device)
  {
! 	struct snd_stm_conv_i2sspdif *conv_i2sspdif = snd_device->device_data;
! 	int i;
! 
! 	snd_stm_printd(1, "snd_stm_conv_i2sspdif_register(snd_device=0x%p)\n",
! 			snd_device);
  
! 	snd_stm_assert(conv_i2sspdif, return -EINVAL);
! 	snd_stm_magic_assert(conv_i2sspdif, return -EINVAL);
! 	snd_stm_assert(!conv_i2sspdif->enabled, return -EINVAL);
! 
! 	snd_stm_printd(0, "--- Registering I2S to SPDIF converter '%s'...\n",
! 			conv_i2sspdif->device->bus_id);
  
  	/* Initialize converter's input & SPDIF player as disabled */
  
! 	set__AUD_SPDIFPC_CFG(conv_i2sspdif,
! 		mask__AUD_SPDIFPC_CFG__DEVICE_EN__DISABLED(conv_i2sspdif) |
! 		mask__AUD_SPDIFPC_CFG__SW_RESET__RESET(conv_i2sspdif) |
! 		mask__AUD_SPDIFPC_CFG__FIFO_EN__DISABLED(conv_i2sspdif) |
! 		mask__AUD_SPDIFPC_CFG__REQ_ACK_EN__DISABLED(conv_i2sspdif));
! 
! 	set__AUD_SPDIFPC_CTRL(conv_i2sspdif,
! 		mask__AUD_SPDIFPC_CTRL__OPERATION__OFF(conv_i2sspdif));
  
  	/* Additional procfs info */
  
! 	snd_stm_info_register(&conv_i2sspdif->proc_entry,
! 			conv_i2sspdif->device->bus_id,
! 			snd_stm_conv_i2sspdif_dump_registers,
! 			conv_i2sspdif);
  
  	/* Create ALSA controls */
  
! 	for (i = 0; i < ARRAY_SIZE(snd_stm_conv_i2sspdif_ctls); i++) {
! 		int result;
! 
! 		snd_stm_conv_i2sspdif_ctls[i].device =
! 				snd_stm_conv_get_card_device(
! 				conv_i2sspdif->converter);
! 		snd_stm_conv_i2sspdif_ctls[i].index = conv_i2sspdif->index;
! 		result = snd_ctl_add(snd_stm_card_get(),
! 				snd_ctl_new1(&snd_stm_conv_i2sspdif_ctls[i],
! 				conv_i2sspdif));
! 		if (result < 0) {
! 			snd_stm_printe("Failed to add I2S-SPDIF converter "
! 					"ALSA control!\n");
! 			return result;
! 		}
  	}
  
- 	snd_stm_printd(0, "--- Registered successfully!\n");
- 
  	return 0;
  }
  
! static int snd_stm_conv_i2sspdif_disconnect(
! 		struct snd_device *snd_device)
  {
! 	struct snd_stm_conv_i2sspdif *conv_i2sspdif = snd_device->device_data;
! 
! 	snd_stm_printd(1, "snd_stm_conv_i2sspdif_disconnect(snd_device=0x%p)\n",
! 			snd_device);
  
! 	snd_stm_assert(conv_i2sspdif, return -EINVAL);
! 	snd_stm_magic_assert(conv_i2sspdif, return -EINVAL);
! 	snd_stm_assert(!conv_i2sspdif->enabled, return -EINVAL);
  
  	/* Remove procfs entry */
  
! 	snd_stm_info_unregister(conv_i2sspdif->proc_entry);
  
  	/* Power done mode, just to be sure :-) */
  
! 	set__AUD_SPDIFPC_CFG(conv_i2sspdif,
! 		mask__AUD_SPDIFPC_CFG__DEVICE_EN__DISABLED(conv_i2sspdif) |
! 		mask__AUD_SPDIFPC_CFG__SW_RESET__RESET(conv_i2sspdif) |
! 		mask__AUD_SPDIFPC_CFG__FIFO_EN__DISABLED(conv_i2sspdif) |
! 		mask__AUD_SPDIFPC_CFG__REQ_ACK_EN__DISABLED(conv_i2sspdif));
! 
! 	set__AUD_SPDIFPC_CTRL(conv_i2sspdif,
! 		mask__AUD_SPDIFPC_CTRL__OPERATION__OFF(conv_i2sspdif));
  
  	return 0;
  }
  
! static struct snd_device_ops snd_stm_conv_i2sspdif_snd_device_ops = {
! 	.dev_register = snd_stm_conv_i2sspdif_register,
! 	.dev_disconnect = snd_stm_conv_i2sspdif_disconnect,
  };
  
  
--- 517,590 ----
  	DUMP_REGISTER(CL1);
  	DUMP_REGISTER(CR1);
  	DUMP_REGISTER(SUV);
  }
  
! static int snd_stm_conv_i2s_spdif_register(struct snd_device *snd_device)
  {
! 	int result;
! 	struct snd_stm_conv_i2s_spdif *conv_i2s_spdif = snd_device->device_data;
  
! 	snd_assert(conv_i2s_spdif, return -EINVAL);
! 	snd_stm_magic_assert(conv_i2s_spdif, return -EINVAL);
! 	snd_assert(!conv_i2s_spdif->enabled, return -EINVAL);
  
  	/* Initialize converter's input & SPDIF player as disabled */
  
! 	REGISTER_POKE(conv_i2s_spdif->base, AUD_SPDIFPC_CFG,
! 			REGFIELD_VALUE(AUD_SPDIFPC_CFG, DEVICE_EN, DISABLED) |
! 			REGFIELD_VALUE(AUD_SPDIFPC_CFG, SW_RESET, RESET) |
! 			REGFIELD_VALUE(AUD_SPDIFPC_CFG, FIFO_EN, DISABLED) |
! 			REGFIELD_VALUE(AUD_SPDIFPC_CFG, REQ_ACK_EN, DISABLED));
! 	REGISTER_POKE(conv_i2s_spdif->base, AUD_SPDIFPC_CTRL,
! 			REGFIELD_VALUE(AUD_SPDIFPC_CTRL, OPERATION, OFF));
  
  	/* Additional procfs info */
  
! 	snd_stm_info_register(&conv_i2s_spdif->proc_entry,
! 			conv_i2s_spdif->device->bus_id,
! 			snd_stm_conv_i2s_spdif_dump_registers,
! 			conv_i2s_spdif);
  
  	/* Create ALSA controls */
  
! 	result = snd_stm_conv_add_route_ctl(conv_i2s_spdif->device,
! 			snd_device->card, conv_i2s_spdif->info->card_device);
! 	if (result < 0) {
! 		snd_stm_printe("Failed to add converter route control!\n");
! 		return result;
  	}
  
  	return 0;
  }
  
! static int snd_stm_conv_i2s_spdif_disconnect(struct snd_device *snd_device)
  {
! 	struct snd_stm_conv_i2s_spdif *conv_i2s_spdif = snd_device->device_data;
  
! 	snd_assert(conv_i2s_spdif, return -EINVAL);
! 	snd_stm_magic_assert(conv_i2s_spdif, return -EINVAL);
! 	snd_assert(!conv_i2s_spdif->enabled, return -EINVAL);
  
  	/* Remove procfs entry */
  
! 	snd_stm_info_unregister(conv_i2s_spdif->proc_entry);
  
  	/* Power done mode, just to be sure :-) */
  
! 	REGISTER_POKE(conv_i2s_spdif->base, AUD_SPDIFPC_CFG,
! 			REGFIELD_VALUE(AUD_SPDIFPC_CFG, DEVICE_EN, DISABLED) |
! 			REGFIELD_VALUE(AUD_SPDIFPC_CFG, SW_RESET, RESET) |
! 			REGFIELD_VALUE(AUD_SPDIFPC_CFG, FIFO_EN, DISABLED) |
! 			REGFIELD_VALUE(AUD_SPDIFPC_CFG, REQ_ACK_EN, DISABLED));
! 	REGISTER_POKE(conv_i2s_spdif->base, AUD_SPDIFPC_CTRL,
! 			REGFIELD_VALUE(AUD_SPDIFPC_CTRL, OPERATION, OFF));
  
  	return 0;
  }
  
! static struct snd_device_ops snd_stm_conv_i2s_spdif_snd_device_ops = {
! 	.dev_register = snd_stm_conv_i2s_spdif_register,
! 	.dev_disconnect = snd_stm_conv_i2s_spdif_disconnect,
  };
  
  
***************
*** 568,602 ****
   * Platform driver routines
   */
  
! static int snd_stm_conv_i2sspdif_probe(struct platform_device *pdev)
  {
  	int result = 0;
! 	struct snd_stm_conv_i2sspdif_info *conv_i2sspdif_info =
  			pdev->dev.platform_data;
! 	struct snd_stm_conv_i2sspdif *conv_i2sspdif;
  
! 	snd_stm_printd(0, "--- Probing device '%s'...\n", pdev->dev.bus_id);
  
! 	snd_stm_assert(conv_i2sspdif_info != NULL, return -EINVAL);
  
! 	conv_i2sspdif = kzalloc(sizeof(*conv_i2sspdif), GFP_KERNEL);
! 	if (!conv_i2sspdif) {
  		snd_stm_printe("Can't allocate memory "
  				"for a device description!\n");
  		result = -ENOMEM;
  		goto error_alloc;
  	}
! 	snd_stm_magic_set(conv_i2sspdif);
! 	conv_i2sspdif->ver = conv_i2sspdif_info->ver;
! 	snd_stm_assert(conv_i2sspdif->ver > 0, return -EINVAL);
! 	conv_i2sspdif->info = conv_i2sspdif_info;
! 	conv_i2sspdif->device = &pdev->dev;
! 	spin_lock_init(&conv_i2sspdif->iec958_default_lock);
  
  	/* Get resources */
  
! 	result = snd_stm_memory_request(pdev, &conv_i2sspdif->mem_region,
! 			&conv_i2sspdif->base);
  	if (result < 0) {
  		snd_stm_printe("Memory region request failed!\n");
  		goto error_memory_request;
--- 593,639 ----
   * Platform driver routines
   */
  
! static int __init snd_stm_conv_i2s_spdif_probe(struct platform_device *pdev)
  {
  	int result = 0;
! 	struct snd_stm_conv_i2s_spdif_info *conv_i2s_spdif_info =
  			pdev->dev.platform_data;
! 	struct snd_stm_conv_i2s_spdif *conv_i2s_spdif;
! 	struct snd_card *card;
! 	struct device *player_device;
! 	int i;
  
! 	snd_printd("--- Probing device '%s'...\n", pdev->dev.bus_id);
  
! 	snd_assert(conv_i2s_spdif_info != NULL, return -EINVAL);
  
! 	conv_i2s_spdif = kzalloc(sizeof(*conv_i2s_spdif), GFP_KERNEL);
! 	if (!conv_i2s_spdif) {
  		snd_stm_printe("Can't allocate memory "
  				"for a device description!\n");
  		result = -ENOMEM;
  		goto error_alloc;
  	}
! 	snd_stm_magic_set(conv_i2s_spdif);
! 	conv_i2s_spdif->info = conv_i2s_spdif_info;
! 	conv_i2s_spdif->device = &pdev->dev;
! 	spin_lock_init(&conv_i2s_spdif->iec958_default_lock);
! 
! 	/* Converter interface initialization */
! 
! 	conv_i2s_spdif->conv.name = conv_i2s_spdif_info->name;
! 	conv_i2s_spdif->conv.get_format = snd_stm_conv_i2s_spdif_get_format;
! 	conv_i2s_spdif->conv.get_oversampling =
! 			snd_stm_conv_i2s_spdif_get_oversampling;
! 	conv_i2s_spdif->conv.enable = snd_stm_conv_i2s_spdif_enable;
! 	conv_i2s_spdif->conv.disable = snd_stm_conv_i2s_spdif_disable;
! 	conv_i2s_spdif->conv.mute = snd_stm_conv_i2s_spdif_mute;
! 	conv_i2s_spdif->conv.unmute = snd_stm_conv_i2s_spdif_unmute;
  
  	/* Get resources */
  
! 	result = snd_stm_memory_request(pdev, &conv_i2s_spdif->mem_region,
! 			&conv_i2s_spdif->base);
  	if (result < 0) {
  		snd_stm_printe("Memory region request failed!\n");
  		goto error_memory_request;
***************
*** 604,678 ****
  
  	/* Get connections */
  
! 	snd_stm_assert(conv_i2sspdif_info->source_bus_id != NULL,
  			return -EINVAL);
! 	snd_stm_printd(0, "This I2S-SPDIF converter is attached to PCM player"
! 			" '%s'.\n",
! 			conv_i2sspdif_info->source_bus_id);
! 	conv_i2sspdif->converter = snd_stm_conv_register_converter(
! 			"HDMI Output",
! 			&snd_stm_conv_i2sspdif_ops, conv_i2sspdif,
! 			&platform_bus_type, conv_i2sspdif_info->source_bus_id,
! 			conv_i2sspdif_info->channel_from,
! 			conv_i2sspdif_info->channel_to,
! 			&conv_i2sspdif->index);
! 	if (!conv_i2sspdif->converter) {
  		snd_stm_printe("Can't attach to PCM player!\n");
- 		result = -EINVAL;
  		goto error_attach;
  	}
  
  	/* Create ALSA lowlevel device*/
  
! 	result = snd_device_new(snd_stm_card_get(), SNDRV_DEV_LOWLEVEL,
! 			conv_i2sspdif, &snd_stm_conv_i2sspdif_snd_device_ops);
  	if (result < 0) {
  		snd_stm_printe("ALSA low level device creation failed!\n");
  		goto error_device;
  	}
  
  	/* Done now */
  
! 	platform_set_drvdata(pdev, conv_i2sspdif);
  
! 	snd_stm_printd(0, "--- Probed successfully!\n");
  
  	return result;
  
  error_device:
  error_attach:
! 	snd_stm_memory_release(conv_i2sspdif->mem_region,
! 			conv_i2sspdif->base);
  error_memory_request:
! 	snd_stm_magic_clear(conv_i2sspdif);
! 	kfree(conv_i2sspdif);
  error_alloc:
  	return result;
  }
  
! static int snd_stm_conv_i2sspdif_remove(struct platform_device *pdev)
  {
! 	struct snd_stm_conv_i2sspdif *conv_i2sspdif =
! 			platform_get_drvdata(pdev);
  
! 	snd_stm_assert(conv_i2sspdif, return -EINVAL);
! 	snd_stm_magic_assert(conv_i2sspdif, return -EINVAL);
  
! 	snd_stm_conv_unregister_converter(conv_i2sspdif->converter);
! 	snd_stm_memory_release(conv_i2sspdif->mem_region, conv_i2sspdif->base);
  
! 	snd_stm_magic_clear(conv_i2sspdif);
! 	kfree(conv_i2sspdif);
  
  	return 0;
  }
  
! static struct platform_driver snd_stm_conv_i2sspdif_driver = {
  	.driver = {
! 		.name = "snd_conv_i2sspdif",
  	},
! 	.probe = snd_stm_conv_i2sspdif_probe,
! 	.remove = snd_stm_conv_i2sspdif_remove,
  };
  
  
--- 641,735 ----
  
  	/* Get connections */
  
! 	snd_assert(conv_i2s_spdif_info->card_id, return -EINVAL);
! 	card = snd_stm_cards_get(conv_i2s_spdif_info->card_id);
! 	snd_assert(card, return -EINVAL);
! 	snd_printd("This I2S-SPDIF converter will be a member of a card "
! 			"'%s'.\n", card->id);
! 
! 	snd_assert(conv_i2s_spdif_info->source_bus_id != NULL,
  			return -EINVAL);
! 	snd_printd("This I2S-SPDIF converter is attached to PCM player '%s'.\n",
! 			conv_i2s_spdif_info->source_bus_id);
! 	player_device = snd_stm_find_device(NULL,
! 			conv_i2s_spdif_info->source_bus_id);
! 	snd_assert(player_device != NULL, return -EINVAL);
! 	result = snd_stm_conv_attach(&conv_i2s_spdif->conv, player_device);
! 	if (result < 0) {
  		snd_stm_printe("Can't attach to PCM player!\n");
  		goto error_attach;
  	}
  
  	/* Create ALSA lowlevel device*/
  
! 	result = snd_device_new(card, SNDRV_DEV_LOWLEVEL, conv_i2s_spdif,
! 			&snd_stm_conv_i2s_spdif_snd_device_ops);
  	if (result < 0) {
  		snd_stm_printe("ALSA low level device creation failed!\n");
  		goto error_device;
  	}
  
+ 	/* Create ALSA controls */
+ 
+ 	result = 0;
+ 	for (i = 0; i < ARRAY_SIZE(snd_stm_conv_i2s_spdif_ctls); i++) {
+ 		snd_stm_conv_i2s_spdif_ctls[i].device =
+ 				conv_i2s_spdif->info->card_device;
+ 		result |= snd_ctl_add(card,
+ 				snd_ctl_new1(&snd_stm_conv_i2s_spdif_ctls[i],
+ 				conv_i2s_spdif));
+ 		/* TODO: index per card */
+ 		snd_stm_conv_i2s_spdif_ctls[i].index++;
+ 	}
+ 	if (result < 0) {
+ 		snd_stm_printe("Failed to add all ALSA controls!\n");
+ 		goto error_controls;
+ 	}
+ 
  	/* Done now */
  
! 	platform_set_drvdata(pdev, &conv_i2s_spdif->conv);
  
! 	snd_printd("--- Probed successfully!\n");
  
  	return result;
  
+ error_controls:
  error_device:
  error_attach:
! 	snd_stm_memory_release(conv_i2s_spdif->mem_region,
! 			conv_i2s_spdif->base);
  error_memory_request:
! 	snd_stm_magic_clear(conv_i2s_spdif);
! 	kfree(conv_i2s_spdif);
  error_alloc:
  	return result;
  }
  
! static int snd_stm_conv_i2s_spdif_remove(struct platform_device *pdev)
  {
! 	struct snd_stm_conv_i2s_spdif *conv_i2s_spdif =
! 			container_of(platform_get_drvdata(pdev),
! 			struct snd_stm_conv_i2s_spdif, conv);
  
! 	snd_assert(conv_i2s_spdif, return -EINVAL);
! 	snd_stm_magic_assert(conv_i2s_spdif, return -EINVAL);
  
! 	snd_stm_memory_release(conv_i2s_spdif->mem_region,
! 			conv_i2s_spdif->base);
  
! 	snd_stm_magic_clear(conv_i2s_spdif);
! 	kfree(conv_i2s_spdif);
  
  	return 0;
  }
  
! static struct platform_driver snd_stm_conv_i2s_spdif_driver = {
  	.driver = {
! 		.name = "conv_i2s-spdif",
  	},
! 	.probe = snd_stm_conv_i2s_spdif_probe,
! 	.remove = snd_stm_conv_i2s_spdif_remove,
  };
  
  
***************
*** 681,692 ****
   * Initialization
   */
  
! int __init snd_stm_conv_i2sspdif_init(void)
  {
! 	return platform_driver_register(&snd_stm_conv_i2sspdif_driver);
  }
  
! void snd_stm_conv_i2sspdif_exit(void)
  {
! 	platform_driver_unregister(&snd_stm_conv_i2sspdif_driver);
  }
--- 738,749 ----
   * Initialization
   */
  
! int __init snd_stm_conv_i2s_spdif_init(void)
  {
! 	return platform_driver_register(&snd_stm_conv_i2s_spdif_driver);
  }
  
! void snd_stm_conv_i2s_spdif_cleanup(void)
  {
! 	platform_driver_unregister(&snd_stm_conv_i2s_spdif_driver);
  }
diff -rcN linux-sh4-2.6.23.17_stm23_0119-orig/sound//stm/conv_int_dac.c linux-sh4/sound//stm/conv_int_dac.c
*** linux-sh4-2.6.23.17_stm23_0119-orig/sound//stm/conv_int_dac.c	2009-06-06 20:17:15.000000000 +0200
--- linux-sh4/sound//stm/conv_int_dac.c	2009-07-18 22:41:19.000000000 +0200
***************
*** 3,9 ****
   *
   *   Copyright (c) 2005-2007 STMicroelectronics Limited
   *
!  *   Author: Pawel Moll <pawel.moll@st.com>
   *
   *   This program is free software; you can redistribute it and/or modify
   *   it under the terms of the GNU General Public License as published by
--- 3,9 ----
   *
   *   Copyright (c) 2005-2007 STMicroelectronics Limited
   *
!  *   Author: Pawel MOLL <pawel.moll@st.com>
   *
   *   This program is free software; you can redistribute it and/or modify
   *   it under the terms of the GNU General Public License as published by
***************
*** 26,39 ****
  #include <linux/platform_device.h>
  #include <linux/list.h>
  #include <linux/spinlock.h>
  #include <sound/driver.h>
  #include <sound/core.h>
  #include <sound/info.h>
  #include <sound/stm.h>
  
! #define COMPONENT conv_int_dac
  #include "common.h"
- #include "reg_audcfg_adac.h"
  
  
  
--- 26,41 ----
  #include <linux/platform_device.h>
  #include <linux/list.h>
  #include <linux/spinlock.h>
+ #include <linux/stm/soc.h>
+ #include <linux/stm/registers.h>
  #include <sound/driver.h>
  #include <sound/core.h>
  #include <sound/info.h>
  #include <sound/stm.h>
  
! #undef TRACE   /* See common.h debug features */
! #define MAGIC 3 /* See common.h debug features */
  #include "common.h"
  
  
  
***************
*** 41,47 ****
   * Hardware-related definitions
   */
  
! #define FORMAT (SND_STM_FORMAT__I2S | SND_STM_FORMAT__SUBFRAME_32_BITS)
  #define OVERSAMPLING 256
  
  
--- 43,49 ----
   * Hardware-related definitions
   */
  
! #define FORMAT (SND_STM_FORMAT__I2S | SND_STM_FORMAT__OUTPUT_SUBFRAME_32_BITS)
  #define OVERSAMPLING 256
  
  
***************
*** 50,65 ****
   * Internal DAC instance structure
   */
  
! struct snd_stm_conv_int_dac {
  	/* System informations */
- 	struct snd_stm_conv_converter *converter;
  	const char *bus_id;
- 	int ver; /* IP version, used by register access macros */
  
  	/* Resources */
  	struct resource *mem_region;
  	void *base;
  
  	struct snd_info_entry *proc_entry;
  
  	snd_stm_magic_field;
--- 52,74 ----
   * Internal DAC instance structure
   */
  
! struct snd_stm_conv_internal_dac {
! 	/* Generic converter interface */
! 	struct snd_stm_conv conv;
! 
  	/* System informations */
  	const char *bus_id;
  
  	/* Resources */
  	struct resource *mem_region;
  	void *base;
  
+ 	/* Runtime data */
+ 	int enabled;
+ 	int muted_by_source;
+ 	int muted_by_user;
+ 	spinlock_t status_lock; /* Protects enabled & muted_by_* */
+ 
  	struct snd_info_entry *proc_entry;
  
  	snd_stm_magic_field;
***************
*** 71,141 ****
   * Converter interface implementation
   */
  
! static unsigned int snd_stm_conv_int_dac_get_format(void *priv)
  {
! 	snd_stm_printd(1, "snd_stm_conv_int_dac_get_format(priv=%p)\n", priv);
  
  	return FORMAT;
  }
  
! static int snd_stm_conv_int_dac_get_oversampling(void *priv)
  {
! 	snd_stm_printd(1, "snd_stm_conv_int_dac_get_oversampling(priv=%p)\n",
! 			priv);
  
  	return OVERSAMPLING;
  }
  
! static int snd_stm_conv_int_dac_set_enabled(int enabled, void *priv)
  {
! 	struct snd_stm_conv_int_dac *conv_int_dac = priv;
  
! 	snd_stm_printd(1, "snd_stm_conv_int_dac_set_enabled(enabled=%d, "
! 			"priv=%p)\n", enabled, priv);
  
! 	snd_stm_assert(conv_int_dac, return -EINVAL);
! 	snd_stm_magic_assert(conv_int_dac, return -EINVAL);
  
! 	snd_stm_printd(1, "%sabling DAC %s's digital part.\n",
! 			enabled ? "En" : "Dis", conv_int_dac->bus_id);
  
! 	if (enabled) {
! 		set__AUDCFG_ADAC_CTRL__NSB__NORMAL(conv_int_dac);
! 		set__AUDCFG_ADAC_CTRL__NRST__NORMAL(conv_int_dac);
! 	} else {
! 		set__AUDCFG_ADAC_CTRL__NRST__RESET(conv_int_dac);
! 		set__AUDCFG_ADAC_CTRL__NSB__POWER_DOWN(conv_int_dac);
! 	}
  
  	return 0;
  }
  
! static int snd_stm_conv_int_dac_set_muted(int muted, void *priv)
  {
! 	struct snd_stm_conv_int_dac *conv_int_dac = priv;
  
! 	snd_stm_printd(1, "snd_stm_conv_int_dac_set_muted(muted=%d, priv=%p)\n",
! 		       muted, priv);
  
! 	snd_stm_assert(conv_int_dac, return -EINVAL);
! 	snd_stm_magic_assert(conv_int_dac, return -EINVAL);
  
! 	snd_stm_printd(1, "%suting DAC %s.\n", muted ? "M" : "Unm",
! 			conv_int_dac->bus_id);
  
! 	if (muted)
! 		set__AUDCFG_ADAC_CTRL__SOFTMUTE__MUTE(conv_int_dac);
! 	else
! 		set__AUDCFG_ADAC_CTRL__SOFTMUTE__NORMAL(conv_int_dac);
  
  	return 0;
  }
  
! static struct snd_stm_conv_ops snd_stm_conv_int_dac_ops = {
! 	.get_format = snd_stm_conv_int_dac_get_format,
! 	.get_oversampling = snd_stm_conv_int_dac_get_oversampling,
! 	.set_enabled = snd_stm_conv_int_dac_set_enabled,
! 	.set_muted = snd_stm_conv_int_dac_set_muted,
  };
  
  
--- 80,276 ----
   * Converter interface implementation
   */
  
! static unsigned int snd_stm_conv_internal_dac_get_format(struct snd_stm_conv
! 		*conv)
  {
! 	snd_stm_printt("snd_stm_conv_internal_dac_get_format(conv=%p)\n", conv);
  
  	return FORMAT;
  }
  
! static int snd_stm_conv_internal_dac_get_oversampling(struct snd_stm_conv *conv)
  {
! 	snd_stm_printt("snd_stm_conv_internal_dac_get_oversampling(conv=%p)\n",
! 			conv);
  
  	return OVERSAMPLING;
  }
  
! static int snd_stm_conv_internal_dac_enable(struct snd_stm_conv *conv)
  {
! 	struct snd_stm_conv_internal_dac *conv_internal_dac = container_of(conv,
! 			struct snd_stm_conv_internal_dac, conv);
  
! 	snd_stm_printt("snd_stm_conv_internal_dac_enable(conv=%p)\n", conv);
  
! 	snd_assert(conv_internal_dac, return -EINVAL);
! 	snd_stm_magic_assert(conv_internal_dac, return -EINVAL);
! 	snd_assert(!conv_internal_dac->enabled, return -EINVAL);
  
! 	snd_stm_printt("Enabling DAC %s's digital part. (still muted)\n",
! 			conv_internal_dac->bus_id);
  
! 	spin_lock(&conv_internal_dac->status_lock);
! 
! 	REGFIELD_SET(conv_internal_dac->base, AUDCFG_ADAC_CTRL, NSB, NORMAL);
! 	REGFIELD_SET(conv_internal_dac->base, AUDCFG_ADAC_CTRL, NRST, NORMAL);
! 
! 	conv_internal_dac->enabled = 1;
! 
! 	spin_unlock(&conv_internal_dac->status_lock);
! 
! 	return 0;
! }
! 
! static int snd_stm_conv_internal_dac_disable(struct snd_stm_conv *conv)
! {
! 	struct snd_stm_conv_internal_dac *conv_internal_dac = container_of(conv,
! 			struct snd_stm_conv_internal_dac, conv);
! 
! 	snd_stm_printt("snd_stm_conv_internal_dac_disable(conv=%p)\n", conv);
! 
! 	snd_assert(conv_internal_dac, return -EINVAL);
! 	snd_stm_magic_assert(conv_internal_dac, return -EINVAL);
! 	snd_assert(conv_internal_dac->enabled, return -EINVAL);
! 
! 	snd_stm_printt("Disabling DAC %s's digital part.\n",
! 			conv_internal_dac->bus_id);
! 
! 	spin_lock(&conv_internal_dac->status_lock);
! 
! 	REGFIELD_SET(conv_internal_dac->base, AUDCFG_ADAC_CTRL, NRST, RESET);
! 	REGFIELD_SET(conv_internal_dac->base, AUDCFG_ADAC_CTRL,
! 			NSB, POWER_DOWN);
! 
! 	conv_internal_dac->enabled = 0;
! 
! 	spin_unlock(&conv_internal_dac->status_lock);
! 
! 	return 0;
! }
! 
! static int snd_stm_conv_internal_dac_mute(struct snd_stm_conv *conv)
! {
! 	struct snd_stm_conv_internal_dac *conv_internal_dac = container_of(conv,
! 			struct snd_stm_conv_internal_dac, conv);
! 
! 	snd_stm_printt("snd_stm_conv_internal_dac_mute(conv=%p)\n", conv);
! 
! 	snd_assert(conv_internal_dac, return -EINVAL);
! 	snd_stm_magic_assert(conv_internal_dac, return -EINVAL);
! 	snd_assert(conv_internal_dac->enabled, return -EINVAL);
! 
! 	snd_stm_printt("Muting DAC %s.\n", conv_internal_dac->bus_id);
! 
! 	spin_lock(&conv_internal_dac->status_lock);
! 
! 	conv_internal_dac->muted_by_source = 1;
! 	if (!conv_internal_dac->muted_by_user)
! 		REGFIELD_SET(conv_internal_dac->base, AUDCFG_ADAC_CTRL,
! 				SOFTMUTE, MUTE);
! 
! 	spin_unlock(&conv_internal_dac->status_lock);
! 
! 	return 0;
! }
! 
! static int snd_stm_conv_internal_dac_unmute(struct snd_stm_conv *conv)
! {
! 	struct snd_stm_conv_internal_dac *conv_internal_dac = container_of(conv,
! 			struct snd_stm_conv_internal_dac, conv);
! 
! 	snd_stm_printt("snd_stm_conv_internal_dac_unmute(conv=%p)\n", conv);
! 
! 	snd_assert(conv_internal_dac, return -EINVAL);
! 	snd_stm_magic_assert(conv_internal_dac, return -EINVAL);
! 	snd_assert(conv_internal_dac->enabled, return -EINVAL);
! 
! 	snd_stm_printt("Unmuting DAC %s.\n", conv_internal_dac->bus_id);
! 
! 	spin_lock(&conv_internal_dac->status_lock);
! 
! 	conv_internal_dac->muted_by_source = 0;
! 	if (!conv_internal_dac->muted_by_user)
! 		REGFIELD_SET(conv_internal_dac->base, AUDCFG_ADAC_CTRL,
! 				SOFTMUTE, NORMAL);
! 
! 	spin_unlock(&conv_internal_dac->status_lock);
  
  	return 0;
  }
  
! 
! 
! /*
!  * ALSA controls
!  */
! 
! static int snd_stm_conv_internal_dac_ctl_mute_get(struct snd_kcontrol *kcontrol,
! 		struct snd_ctl_elem_value *ucontrol)
  {
! 	struct snd_stm_conv_internal_dac *conv_internal_dac =
! 			snd_kcontrol_chip(kcontrol);
  
! 	snd_stm_printt("snd_stm_conv_internal_dac_ctl_mute_get(kcontrol=0x%p,"
! 			" ucontrol=0x%p)\n", kcontrol, ucontrol);
  
! 	snd_assert(conv_internal_dac, return -EINVAL);
! 	snd_stm_magic_assert(conv_internal_dac, return -EINVAL);
  
! 	spin_lock(&conv_internal_dac->status_lock);
  
! 	ucontrol->value.integer.value[0] = !conv_internal_dac->muted_by_user;
! 
! 	spin_unlock(&conv_internal_dac->status_lock);
  
  	return 0;
  }
  
! static int snd_stm_conv_internal_dac_ctl_mute_put(struct snd_kcontrol *kcontrol,
! 		struct snd_ctl_elem_value *ucontrol)
! {
! 	struct snd_stm_conv_internal_dac *conv_internal_dac =
! 			snd_kcontrol_chip(kcontrol);
! 	int changed = 0;
! 
! 	snd_stm_printt("snd_stm_conv_internal_dac_ctl_mute_put(kcontrol=0x%p,"
! 			" ucontrol=0x%p)\n", kcontrol, ucontrol);
! 
! 	snd_assert(conv_internal_dac, return -EINVAL);
! 	snd_stm_magic_assert(conv_internal_dac, return -EINVAL);
! 
! 	spin_lock(&conv_internal_dac->status_lock);
! 
! 	if (ucontrol->value.integer.value[0] !=
! 			!conv_internal_dac->muted_by_user) {
! 		changed = 1;
! 
! 		conv_internal_dac->muted_by_user =
! 				!ucontrol->value.integer.value[0];
! 
! 		if (conv_internal_dac->enabled &&
! 				conv_internal_dac->muted_by_user &&
! 				!conv_internal_dac->muted_by_source)
! 			REGFIELD_SET(conv_internal_dac->base, AUDCFG_ADAC_CTRL,
! 					SOFTMUTE, MUTE);
! 		else if (conv_internal_dac->enabled &&
! 				!conv_internal_dac->muted_by_user &&
! 				!conv_internal_dac->muted_by_source)
! 			REGFIELD_SET(conv_internal_dac->base, AUDCFG_ADAC_CTRL,
! 					SOFTMUTE, NORMAL);
! 	}
! 
! 	spin_unlock(&conv_internal_dac->status_lock);
! 
! 	return changed;
! }
! 
! static struct snd_kcontrol_new __initdata snd_stm_conv_dac_internal_ctl_mute = {
! 	.iface = SNDRV_CTL_ELEM_IFACE_MIXER,
! 	.name = "Master Playback Switch",
! 	.info = snd_stm_ctl_boolean_info,
! 	.get = snd_stm_conv_internal_dac_ctl_mute_get,
! 	.put = snd_stm_conv_internal_dac_ctl_mute_put,
  };
  
  
***************
*** 144,223 ****
   * ALSA lowlevel device implementation
   */
  
! static void snd_stm_conv_int_dac_read_info(struct snd_info_entry *entry,
  		struct snd_info_buffer *buffer)
  {
! 	struct snd_stm_conv_int_dac *conv_int_dac =
  		entry->private_data;
  
! 	snd_stm_assert(conv_int_dac, return);
! 	snd_stm_magic_assert(conv_int_dac, return);
! 
! 	snd_iprintf(buffer, "--- %s ---\n", conv_int_dac->bus_id);
! 	snd_iprintf(buffer, "base = 0x%p\n", conv_int_dac->base);
  
  	snd_iprintf(buffer, "AUDCFG_ADAC_CTRL (offset 0x00) = 0x%08x\n",
! 			get__AUDCFG_ADAC_CTRL(conv_int_dac));
! 
! 	snd_iprintf(buffer, "\n");
  }
  
! static int snd_stm_conv_int_dac_register(struct snd_device *snd_device)
  {
! 	struct snd_stm_conv_int_dac *conv_int_dac =
  			snd_device->device_data;
  
! 	snd_stm_assert(conv_int_dac, return -EINVAL);
! 	snd_stm_magic_assert(conv_int_dac, return -EINVAL);
  
  	/* Initialize DAC with digital part down, analog up and muted */
  
! 	set__AUDCFG_ADAC_CTRL(conv_int_dac,
! 			mask__AUDCFG_ADAC_CTRL__NRST__RESET(conv_int_dac) |
! 			mask__AUDCFG_ADAC_CTRL__MODE__DEFAULT(conv_int_dac) |
! 			mask__AUDCFG_ADAC_CTRL__NSB__POWER_DOWN(conv_int_dac) |
! 			mask__AUDCFG_ADAC_CTRL__SOFTMUTE__MUTE(conv_int_dac) |
! 			mask__AUDCFG_ADAC_CTRL__PDNANA__NORMAL(conv_int_dac) |
! 			mask__AUDCFG_ADAC_CTRL__PDNBG__NORMAL(conv_int_dac));
  
  	/* Additional procfs info */
  
! 	snd_stm_info_register(&conv_int_dac->proc_entry,
! 			conv_int_dac->bus_id,
! 			snd_stm_conv_int_dac_read_info,
! 			conv_int_dac);
  
  	return 0;
  }
  
! static int __exit snd_stm_conv_int_dac_disconnect(struct snd_device *snd_device)
  {
! 	struct snd_stm_conv_int_dac *conv_int_dac =
  			snd_device->device_data;
  
! 	snd_stm_assert(conv_int_dac, return -EINVAL);
! 	snd_stm_magic_assert(conv_int_dac, return -EINVAL);
  
  	/* Remove procfs entry */
  
! 	snd_stm_info_unregister(conv_int_dac->proc_entry);
  
  	/* Global power done & mute mode */
  
! 	set__AUDCFG_ADAC_CTRL(conv_int_dac,
! 		mask__AUDCFG_ADAC_CTRL__NRST__RESET(conv_int_dac) |
! 		mask__AUDCFG_ADAC_CTRL__MODE__DEFAULT(conv_int_dac) |
! 		mask__AUDCFG_ADAC_CTRL__NSB__POWER_DOWN(conv_int_dac) |
! 		mask__AUDCFG_ADAC_CTRL__SOFTMUTE__MUTE(conv_int_dac) |
! 		mask__AUDCFG_ADAC_CTRL__PDNANA__POWER_DOWN(conv_int_dac) |
! 		mask__AUDCFG_ADAC_CTRL__PDNBG__POWER_DOWN(conv_int_dac));
  
  	return 0;
  }
  
! static struct snd_device_ops snd_stm_conv_int_dac_snd_device_ops = {
! 	.dev_register = snd_stm_conv_int_dac_register,
! 	.dev_disconnect = snd_stm_conv_int_dac_disconnect,
  };
  
  
--- 279,357 ----
   * ALSA lowlevel device implementation
   */
  
! static void snd_stm_conv_internal_dac_dump_registers(
! 		struct snd_info_entry *entry,
  		struct snd_info_buffer *buffer)
  {
! 	struct snd_stm_conv_internal_dac *conv_internal_dac =
  		entry->private_data;
  
! 	snd_assert(conv_internal_dac, return);
! 	snd_stm_magic_assert(conv_internal_dac, return);
  
  	snd_iprintf(buffer, "AUDCFG_ADAC_CTRL (offset 0x00) = 0x%08x\n",
! 			REGISTER_PEEK(conv_internal_dac->base,
! 			AUDCFG_ADAC_CTRL));
  }
  
! static int snd_stm_conv_internal_dac_register(struct snd_device *snd_device)
  {
! 	struct snd_stm_conv_internal_dac *conv_internal_dac =
  			snd_device->device_data;
  
! 	snd_assert(conv_internal_dac, return -EINVAL);
! 	snd_stm_magic_assert(conv_internal_dac, return -EINVAL);
! 	snd_assert(!conv_internal_dac->enabled, return -EINVAL);
  
  	/* Initialize DAC with digital part down, analog up and muted */
  
! 	REGISTER_POKE(conv_internal_dac->base, AUDCFG_ADAC_CTRL,
! 			REGFIELD_VALUE(AUDCFG_ADAC_CTRL, NRST, RESET) |
! 			REGFIELD_VALUE(AUDCFG_ADAC_CTRL, MODE, DEFAULT) |
! 			REGFIELD_VALUE(AUDCFG_ADAC_CTRL, NSB, POWER_DOWN) |
! 			REGFIELD_VALUE(AUDCFG_ADAC_CTRL, SOFTMUTE, MUTE) |
! 			REGFIELD_VALUE(AUDCFG_ADAC_CTRL, PDNANA, NORMAL) |
! 			REGFIELD_VALUE(AUDCFG_ADAC_CTRL, PDNBG, NORMAL));
  
  	/* Additional procfs info */
  
! 	snd_stm_info_register(&conv_internal_dac->proc_entry,
! 			conv_internal_dac->bus_id,
! 			snd_stm_conv_internal_dac_dump_registers,
! 			conv_internal_dac);
  
  	return 0;
  }
  
! static int snd_stm_conv_internal_dac_disconnect(struct snd_device *snd_device)
  {
! 	struct snd_stm_conv_internal_dac *conv_internal_dac =
  			snd_device->device_data;
  
! 	snd_assert(conv_internal_dac, return -EINVAL);
! 	snd_stm_magic_assert(conv_internal_dac, return -EINVAL);
! 	snd_assert(!conv_internal_dac->enabled, return -EINVAL);
  
  	/* Remove procfs entry */
  
! 	snd_stm_info_unregister(conv_internal_dac->proc_entry);
  
  	/* Global power done & mute mode */
  
! 	REGISTER_POKE(conv_internal_dac->base, AUDCFG_ADAC_CTRL,
! 			REGFIELD_VALUE(AUDCFG_ADAC_CTRL, NRST, RESET) |
! 			REGFIELD_VALUE(AUDCFG_ADAC_CTRL, MODE, DEFAULT) |
! 			REGFIELD_VALUE(AUDCFG_ADAC_CTRL, NSB, POWER_DOWN) |
! 			REGFIELD_VALUE(AUDCFG_ADAC_CTRL, SOFTMUTE, MUTE) |
! 			REGFIELD_VALUE(AUDCFG_ADAC_CTRL, PDNANA, POWER_DOWN) |
! 			REGFIELD_VALUE(AUDCFG_ADAC_CTRL, PDNBG, POWER_DOWN));
  
  	return 0;
  }
  
! static struct snd_device_ops snd_stm_conv_internal_dac_snd_device_ops = {
! 	.dev_register = snd_stm_conv_internal_dac_register,
! 	.dev_disconnect = snd_stm_conv_internal_dac_disconnect,
  };
  
  
***************
*** 226,260 ****
   * Platform driver routines
   */
  
! static int snd_stm_conv_int_dac_probe(struct platform_device *pdev)
  {
  	int result = 0;
! 	struct snd_stm_conv_int_dac_info *conv_int_dac_info =
  			pdev->dev.platform_data;
! 	struct snd_stm_conv_int_dac *conv_int_dac;
! 	struct snd_card *card = snd_stm_card_get();
  
! 	snd_stm_printd(0, "--- Probing device '%s'...\n", pdev->dev.bus_id);
  
! 	snd_stm_assert(card != NULL, return -EINVAL);
! 	snd_stm_assert(conv_int_dac_info != NULL, return -EINVAL);
  
! 	conv_int_dac = kzalloc(sizeof(*conv_int_dac), GFP_KERNEL);
! 	if (!conv_int_dac) {
  		snd_stm_printe("Can't allocate memory "
  				"for a device description!\n");
  		result = -ENOMEM;
  		goto error_alloc;
  	}
! 	snd_stm_magic_set(conv_int_dac);
! 	conv_int_dac->ver = conv_int_dac_info->ver;
! 	snd_stm_assert(conv_int_dac->ver > 0, return -EINVAL);
! 	conv_int_dac->bus_id = pdev->dev.bus_id;
  
  	/* Get resources */
  
! 	result = snd_stm_memory_request(pdev, &conv_int_dac->mem_region,
! 			&conv_int_dac->base);
  	if (result < 0) {
  		snd_stm_printe("Memory region request failed!\n");
  		goto error_memory_request;
--- 360,405 ----
   * Platform driver routines
   */
  
! static int __init snd_stm_conv_internal_dac_probe(struct platform_device *pdev)
  {
  	int result = 0;
! 	struct snd_stm_conv_internal_dac_info *conv_internal_dac_info =
  			pdev->dev.platform_data;
! 	struct snd_stm_conv_internal_dac *conv_internal_dac;
! 	struct snd_card *card;
! 	struct device *player_device;
  
! 	snd_printd("--- Probing device '%s'...\n", pdev->dev.bus_id);
  
! 	snd_assert(conv_internal_dac_info != NULL, return -EINVAL);
  
! 	conv_internal_dac = kzalloc(sizeof(*conv_internal_dac), GFP_KERNEL);
! 	if (!conv_internal_dac) {
  		snd_stm_printe("Can't allocate memory "
  				"for a device description!\n");
  		result = -ENOMEM;
  		goto error_alloc;
  	}
! 	snd_stm_magic_set(conv_internal_dac);
! 	conv_internal_dac->bus_id = pdev->dev.bus_id;
! 	spin_lock_init(&conv_internal_dac->status_lock);
! 
! 	/* Converter interface initialization */
! 
! 	conv_internal_dac->conv.name = conv_internal_dac_info->name;
! 	conv_internal_dac->conv.get_format =
! 			snd_stm_conv_internal_dac_get_format;
! 	conv_internal_dac->conv.get_oversampling =
! 			snd_stm_conv_internal_dac_get_oversampling;
! 	conv_internal_dac->conv.enable = snd_stm_conv_internal_dac_enable;
! 	conv_internal_dac->conv.disable = snd_stm_conv_internal_dac_disable;
! 	conv_internal_dac->conv.mute = snd_stm_conv_internal_dac_mute;
! 	conv_internal_dac->conv.unmute = snd_stm_conv_internal_dac_unmute;
  
  	/* Get resources */
  
! 	result = snd_stm_memory_request(pdev, &conv_internal_dac->mem_region,
! 			&conv_internal_dac->base);
  	if (result < 0) {
  		snd_stm_printe("Memory region request failed!\n");
  		goto error_memory_request;
***************
*** 262,333 ****
  
  	/* Get connections */
  
! 	snd_stm_assert(conv_int_dac_info->source_bus_id != NULL,
  			return -EINVAL);
! 	snd_stm_printd(0, "This DAC is attached to PCM player '%s'.\n",
! 			conv_int_dac_info->source_bus_id);
! 	conv_int_dac->converter = snd_stm_conv_register_converter(
! 			"Analog Output",
! 			&snd_stm_conv_int_dac_ops, conv_int_dac,
! 			&platform_bus_type, conv_int_dac_info->source_bus_id,
! 			conv_int_dac_info->channel_from,
! 			conv_int_dac_info->channel_to, NULL);
! 	if (!conv_int_dac->converter) {
  		snd_stm_printe("Can't attach to PCM player!\n");
  		goto error_attach;
  	}
  
  	/* Create ALSA lowlevel device*/
  
! 	result = snd_device_new(card, SNDRV_DEV_LOWLEVEL, conv_int_dac,
! 			&snd_stm_conv_int_dac_snd_device_ops);
  	if (result < 0) {
  		snd_stm_printe("ALSA low level device creation failed!\n");
  		goto error_device;
  	}
  
  	/* Done now */
  
! 	platform_set_drvdata(pdev, conv_int_dac);
  
! 	snd_stm_printd(0, "--- Probed successfully!\n");
  
  	return 0;
  
  error_device:
  error_attach:
! 	snd_stm_memory_release(conv_int_dac->mem_region,
! 			conv_int_dac->base);
  error_memory_request:
! 	snd_stm_magic_clear(conv_int_dac);
! 	kfree(conv_int_dac);
  error_alloc:
  	return result;
  }
  
! static int snd_stm_conv_int_dac_remove(struct platform_device *pdev)
  {
! 	struct snd_stm_conv_int_dac *conv_int_dac = platform_get_drvdata(pdev);
  
! 	snd_stm_assert(conv_int_dac, return -EINVAL);
! 	snd_stm_magic_assert(conv_int_dac, return -EINVAL);
  
! 	snd_stm_conv_unregister_converter(conv_int_dac->converter);
! 	snd_stm_memory_release(conv_int_dac->mem_region,
! 			conv_int_dac->base);
  
! 	snd_stm_magic_clear(conv_int_dac);
! 	kfree(conv_int_dac);
  
  	return 0;
  }
  
! static struct platform_driver snd_stm_conv_int_dac_driver = {
  	.driver = {
! 		.name = "snd_conv_int_dac",
  	},
! 	.probe = snd_stm_conv_int_dac_probe,
! 	.remove = snd_stm_conv_int_dac_remove,
  };
  
  
--- 407,495 ----
  
  	/* Get connections */
  
! 	snd_assert(conv_internal_dac_info->card_id, return -EINVAL);
! 	card = snd_stm_cards_get(conv_internal_dac_info->card_id);
! 	snd_assert(card, return -EINVAL);
! 	snd_printd("This DAC will be a member of a card '%s'.\n", card->id);
! 
! 	snd_assert(conv_internal_dac_info->source_bus_id != NULL,
  			return -EINVAL);
! 	snd_printd("This DAC is attached to PCM player '%s'.\n",
! 			conv_internal_dac_info->source_bus_id);
! 	player_device = snd_stm_find_device(NULL,
! 			conv_internal_dac_info->source_bus_id);
! 	snd_assert(player_device != NULL, return -EINVAL);
! 	result = snd_stm_conv_attach(&conv_internal_dac->conv, player_device);
! 	if (result < 0) {
  		snd_stm_printe("Can't attach to PCM player!\n");
  		goto error_attach;
  	}
  
  	/* Create ALSA lowlevel device*/
  
! 	result = snd_device_new(card, SNDRV_DEV_LOWLEVEL, conv_internal_dac,
! 			&snd_stm_conv_internal_dac_snd_device_ops);
  	if (result < 0) {
  		snd_stm_printe("ALSA low level device creation failed!\n");
  		goto error_device;
  	}
  
+ 	/* Create ALSA control */
+ 
+ 	snd_stm_conv_dac_internal_ctl_mute.device =
+ 			conv_internal_dac_info->card_device;
+ 	result = snd_ctl_add(card,
+ 			snd_ctl_new1(&snd_stm_conv_dac_internal_ctl_mute,
+ 			conv_internal_dac));
+ 	if (result < 0) {
+ 		snd_stm_printe("Failed to add all ALSA control!\n");
+ 		goto error_control;
+ 	}
+ 
  	/* Done now */
  
! 	platform_set_drvdata(pdev, &conv_internal_dac->conv);
  
! 	snd_printd("--- Probed successfully!\n");
  
  	return 0;
  
+ error_control:
  error_device:
  error_attach:
! 	snd_stm_memory_release(conv_internal_dac->mem_region,
! 			conv_internal_dac->base);
  error_memory_request:
! 	snd_stm_magic_clear(conv_internal_dac);
! 	kfree(conv_internal_dac);
  error_alloc:
  	return result;
  }
  
! static int snd_stm_conv_internal_dac_remove(struct platform_device *pdev)
  {
! 	struct snd_stm_conv_internal_dac *conv_internal_dac =
! 			container_of(platform_get_drvdata(pdev),
! 			struct snd_stm_conv_internal_dac, conv);
  
! 	snd_assert(conv_internal_dac, return -EINVAL);
! 	snd_stm_magic_assert(conv_internal_dac, return -EINVAL);
  
! 	snd_stm_memory_release(conv_internal_dac->mem_region,
! 			conv_internal_dac->base);
  
! 	snd_stm_magic_clear(conv_internal_dac);
! 	kfree(conv_internal_dac);
  
  	return 0;
  }
  
! static struct platform_driver snd_stm_conv_internal_dac_driver = {
  	.driver = {
! 		.name = "conv_internal_dac",
  	},
! 	.probe = snd_stm_conv_internal_dac_probe,
! 	.remove = snd_stm_conv_internal_dac_remove,
  };
  
  
***************
*** 336,347 ****
   * Initialization
   */
  
! int __init snd_stm_conv_int_dac_init(void)
  {
! 	return platform_driver_register(&snd_stm_conv_int_dac_driver);
  }
  
! void snd_stm_conv_int_dac_exit(void)
  {
! 	platform_driver_unregister(&snd_stm_conv_int_dac_driver);
  }
--- 498,509 ----
   * Initialization
   */
  
! int __init snd_stm_conv_internal_dac_init(void)
  {
! 	return platform_driver_register(&snd_stm_conv_internal_dac_driver);
  }
  
! void snd_stm_conv_internal_dac_cleanup(void)
  {
! 	platform_driver_unregister(&snd_stm_conv_internal_dac_driver);
  }
diff -urN linux-sh4-2.6.23.17_stm23_0119-orig/sound//stm/fsynth.c linux-sh4/sound//stm/fsynth.c
--- linux-sh4-2.6.23.17_stm23_0119-orig/sound//stm/fsynth.c	2009-06-06 20:17:15.000000000 +0200
+++ linux-sh4/sound//stm/fsynth.c	2009-07-18 22:12:06.000000000 +0200
@@ -4,8 +4,8 @@
  *
  *   Copyright (c) 2005-2007 STMicroelectronics Limited
  *
- *   Authors: Pawel Moll <pawel.moll@st.com>
- *            Daniel Thompson <daniel.thompson@st.com>
+ *   Authors: Pawel MOLL <pawel.moll@st.com>
+ *            Daniel THOMPSON <daniel.thompson@st.com>
  *
  *   This program is free software; you can redistribute it and/or modify
  *   it under the terms of the GNU General Public License as published by
@@ -26,14 +26,16 @@
 #include <linux/init.h>
 #include <linux/io.h>
 #include <linux/platform_device.h>
+#include <linux/stm/soc.h>
+#include <linux/stm/registers.h>
 #include <asm/div64.h>
 #include <sound/driver.h>
 #include <sound/core.h>
 #include <sound/info.h>
 
-#define COMPONENT fsynth
+#undef TRACE /* See common.h debug features */
+#define MAGIC 5 /* See common.h debug features */
 #include "common.h"
-#include "reg_audcfg_fsyn.h"
 
 
 
@@ -41,14 +43,17 @@
  * Hardware constants
  */
 
+#if defined(CONFIG_CPU_SUBTYPE_STB7100)
+#	define CHANNELS 3
+#endif
+#if defined(CONFIG_CPU_SUBTYPE_STX7200) || defined(CONFIG_CPU_SUBTYPE_STX7111)
+#	define CHANNELS 4
+#endif
+
 /* PLL inside the synthesizer multiplies input frequency
  * (which is 30MHz in our case) by 8... */
 #define PLL_FREQ 8 * 30 * 1000 * 1000
 
-/* Number of synthesizer channels */
-#define CHANNELS_MAX 4
-
-
 
 /*
  * Audio frequency synthesizer structures
@@ -59,21 +64,17 @@
 
 	int frequency;  /* Nominal */
 	int adjustment; /* Actual (achieved) */
-
-	snd_stm_magic_field;
 };
 
 struct snd_stm_fsynth {
-	/* System informations */
-	struct snd_stm_fsynth_info *info;
 	const char *bus_id;
 
-	/* Resources */
 	struct resource *mem_region;
+
 	void *base;
 
-	/* Runtime data */
-	struct snd_stm_fsynth_channel channels[CHANNELS_MAX];
+	int channels_from, channels_to;
+	struct snd_stm_fsynth_channel channels[CHANNELS];
 
 	struct snd_info_entry *proc_entry;
 
@@ -241,7 +242,7 @@
 	*mdp = md;
 	*pep = pe;
 
-	snd_stm_printd(1, "SDIV == %u, MD == %d, PE == %u\n", sdiv, md, pe);
+	snd_stm_printt("SDIV == %u, MD == %d, PE == %u\n", sdiv, md, pe);
 
 	/* return 0 if all variables meet their contraints */
 	return (sdiv <= 7 && -16 <= md && md <= -1 && pe <= 32767) ? 0 : -1;
@@ -283,14 +284,21 @@
 	int frequency_adjusted, frequency_achieved, adjustment_achieved;
 	int delta;
 
-	snd_stm_printd(1, "snd_stm_fsynth_configure(fsynth=%p, channel=%d, "
+	snd_stm_printt("snd_stm_fsynth_configure(fsynth=%p, channel=%d, "
 			"frequency=%d, adjustment=%d)\n", fsynth, channel,
 			frequency, adjustment);
 
-	snd_stm_assert(fsynth, return -EINVAL);
+	snd_assert(fsynth, return -EINVAL);
 	snd_stm_magic_assert(fsynth, return -EINVAL);
-	snd_stm_assert(channel >= fsynth->info->channels_from, return -EINVAL);
-	snd_stm_assert(channel <= fsynth->info->channels_to, return -EINVAL);
+	snd_assert(channel >= fsynth->channels_from, return -EINVAL);
+	snd_assert(channel <= fsynth->channels_to, return -EINVAL);
+
+	/* All specs say, that maximum frequency generated by the fsynth
+	 * is 12.288MHz... */
+	if (frequency > 12288000)
+		snd_stm_printe("WARNING! %s should not generate frequency %d!"
+				" (12.288MHz is maximum)\n",
+				fsynth->bus_id, frequency);
 
 	/*             a
 	 * F = f + --------- * f = f + d
@@ -318,7 +326,7 @@
 			500000, 1000000);
 	frequency_adjusted = frequency + delta;
 
-	snd_stm_printd(1, "Setting %s channel %d to frequency %d.\n",
+	snd_stm_printt("Setting %s channel %d to frequency %d.\n",
 			fsynth->bus_id, channel,
 			frequency_adjusted);
 
@@ -330,16 +338,20 @@
 		return -EINVAL;
 	}
 
-	snd_stm_printd(1, "SDIV == 0x%x, MD == 0x%x, PE == 0x%x\n", sdiv,
-			(unsigned int)md & mask__AUDCFG_FSYN_MD__MD(fsynth),
-			pe);
-	set__AUDCFG_FSYN_PROGEN__PROG_EN__PE0_MD0_IGNORED(fsynth, channel);
-	set__AUDCFG_FSYN_SDIV__SDIV(fsynth, channel, sdiv);
-	set__AUDCFG_FSYN_MD__MD(fsynth, channel, (unsigned int)md &
-			mask__AUDCFG_FSYN_MD__MD(fsynth));
-	set__AUDCFG_FSYN_PE__PE(fsynth, channel, pe);
-	set__AUDCFG_FSYN_PROGEN__PROG_EN__PE0_MD0_USED(fsynth, channel);
-	set__AUDCFG_FSYN_PROGEN__PROG_EN__PE0_MD0_IGNORED(fsynth, channel);
+	snd_stm_printt("SDIV == 0x%x, MD == 0x%x, PE == 0x%x\n", sdiv,
+			(unsigned int)md & AUDCFG_FSYN_MD__MD__MASK, pe);
+	REGFIELD_SET_N(fsynth->base, AUDCFG_FSYN_PROGEN, channel,
+			PROG_EN, PE0_MD0_IGNORED);
+	REGFIELD_POKE_N(fsynth->base, AUDCFG_FSYN_SDIV, channel,
+			SDIV, sdiv);
+	REGFIELD_POKE_N(fsynth->base, AUDCFG_FSYN_MD, channel,
+			MD, (unsigned int)md & AUDCFG_FSYN_MD__MD__MASK);
+	REGFIELD_POKE_N(fsynth->base, AUDCFG_FSYN_PE, channel,
+			PE, pe);
+	REGFIELD_SET_N(fsynth->base, AUDCFG_FSYN_PROGEN, channel,
+			PROG_EN, PE0_MD0_USED);
+	REGFIELD_SET_N(fsynth->base, AUDCFG_FSYN_PROGEN, channel,
+			PROG_EN, PE0_MD0_IGNORED);
 
 	/*             a                    a
 	 * F = f + --------- * f   =>   --------- * f = F - f   ==>
@@ -373,7 +385,7 @@
 	adjustment_achieved *= (int)div64_64((uint64_t)delta * 1000000 +
 			frequency / 2, frequency);
 
-	snd_stm_printd(1, "Nominal frequency is %d, actual frequency is %d, "
+	snd_stm_printt("Nominal frequency is %d, actual frequency is %d, "
 			"(%d ppm difference).\n", frequency,
 			frequency_achieved, adjustment_achieved);
 
@@ -407,12 +419,11 @@
 	struct snd_stm_fsynth_channel *fsynth_channel =
 		snd_kcontrol_chip(kcontrol);
 
-	snd_stm_printd(1, "snd_stm_fsynth_adjustment_get(kcontrol=0x%p, "
+	snd_stm_printt("snd_stm_fsynth_adjustment_get(kcontrol=0x%p, "
 			"ucontrol=0x%p)\n", kcontrol, ucontrol);
 
-	snd_stm_assert(fsynth_channel, return -EINVAL);
-	snd_stm_magic_assert(fsynth_channel, return -EINVAL);
-	snd_stm_assert(fsynth_channel->fsynth, return -EINVAL);
+	snd_assert(fsynth_channel, return -EINVAL);
+	snd_assert(fsynth_channel->fsynth, return -EINVAL);
 	snd_stm_magic_assert(fsynth_channel->fsynth, return -EINVAL);
 
 	ucontrol->value.integer.value[0] = fsynth_channel->adjustment;
@@ -423,32 +434,31 @@
 static int snd_stm_fsynth_adjustment_put(struct snd_kcontrol *kcontrol,
 		struct snd_ctl_elem_value *ucontrol)
 {
+	int result;
 	struct snd_stm_fsynth_channel *fsynth_channel =
 		snd_kcontrol_chip(kcontrol);
 	struct snd_stm_fsynth *fsynth;
 	int channel;
 	int old_adjustement;
 
-	snd_stm_printd(1, "snd_stm_fsynth_clock_adjustment_put(kcontrol=0x%p,"
-			" ucontrol=0x%p)\n", kcontrol, ucontrol);
+	snd_stm_printt("snd_stm_fsynth_clock_adjustment_put(kcontrol=0x%p, "
+			"ucontrol=0x%p)\n", kcontrol, ucontrol);
 
-	snd_stm_assert(fsynth_channel, return -EINVAL);
-	snd_stm_magic_assert(fsynth_channel, return -EINVAL);
+	snd_assert(fsynth_channel, return -EINVAL);
 
 	fsynth = fsynth_channel->fsynth;
 
-	snd_stm_assert(fsynth, return -EINVAL);
+	snd_assert(fsynth, return -EINVAL);
 	snd_stm_magic_assert(fsynth, return -EINVAL);
 
 	channel = fsynth_channel - fsynth_channel->fsynth->channels;
 	old_adjustement = fsynth_channel->adjustment;
 
-	/* If the synthesizer hasn't been configured yet... */
-	if (fsynth_channel->frequency == 0)
-		fsynth_channel->adjustment = ucontrol->value.integer.value[0];
-	else if (snd_stm_fsynth_channel_configure(fsynth, channel,
+	result = snd_stm_fsynth_channel_configure(fsynth, channel,
 			fsynth_channel->frequency,
-			ucontrol->value.integer.value[0]) < 0)
+			ucontrol->value.integer.value[0]);
+
+	if (result < 0)
 		return -EINVAL;
 
 	return old_adjustement != fsynth_channel->adjustment;
@@ -467,71 +477,42 @@
 /*
  * Audio frequency synthesizer public interface implementation
  */
-static int snd_stm_fsynth_bus_id_match(struct device *device, void *bus_id)
-{
-	return strcmp(device->bus_id, bus_id) == 0;
-}
-
-struct snd_stm_fsynth_channel *snd_stm_fsynth_get_channel(const char *bus_id,
-		int output)
-{
-	struct device *device;
 
-	snd_stm_printd(1, "snd_stm_fsynth_get_channel(bus_id='%s', output=%d)"
-			"\n", bus_id, output);
-
-	device = bus_find_device(&platform_bus_type, NULL, (void *)bus_id,
-			snd_stm_fsynth_bus_id_match);
-	if (device) {
-		struct snd_stm_fsynth *fsynth = dev_get_drvdata(device);
-
-		snd_stm_magic_assert(fsynth, return NULL);
-		snd_stm_assert(output >= fsynth->info->channels_from,
-				return NULL);
-		snd_stm_assert(output <= fsynth->info->channels_to,
-				return NULL);
-
-		return &fsynth->channels[output];
-	}
-
-	snd_stm_printe("Can't find '%s' frequency synthesizer "
-			"device!\n", bus_id);
-
-	return NULL;
-}
-
-int snd_stm_fsynth_set_frequency(struct snd_stm_fsynth_channel *fsynth_channel,
+int snd_stm_fsynth_set_frequency(struct device *device, int channel,
 		int frequency)
 {
-	snd_stm_printd(1, "snd_stm_fsynth_set_frequency(fsynth_channel=%p, "
-			"frequency=%d)\n", fsynth_channel, frequency);
+	struct snd_stm_fsynth *fsynth = dev_get_drvdata(device);
 
-	snd_stm_assert(fsynth_channel, return -EINVAL);
-	snd_stm_magic_assert(fsynth_channel, return -EINVAL);
-	snd_stm_assert(fsynth_channel->fsynth, return -EINVAL);
-	snd_stm_magic_assert(fsynth_channel->fsynth, return -EINVAL);
+	snd_stm_printt("snd_stm_fsynth_set_frequency(device=%p, channel=%d, "
+			"frequency=%d)\n", device, channel, frequency);
 
-	return snd_stm_fsynth_channel_configure(fsynth_channel->fsynth,
-			fsynth_channel - fsynth_channel->fsynth->channels,
-			frequency, fsynth_channel->adjustment);
+	snd_assert(fsynth, return -EINVAL);
+	snd_stm_magic_assert(fsynth, return -EINVAL);
+	snd_assert(channel >= fsynth->channels_from, return -EINVAL);
+	snd_assert(channel <= fsynth->channels_to, return -EINVAL);
+
+	return snd_stm_fsynth_channel_configure(fsynth, channel, frequency, 0);
 }
 
-int snd_stm_fsynth_add_adjustement_ctl(
-		struct snd_stm_fsynth_channel *fsynth_channel,
-		struct snd_card *card, int card_device)
+int snd_stm_fsynth_add_adjustement_ctl(struct device *device,
+		int channel, struct snd_card *card, int card_device)
 {
 	int result;
+	struct snd_stm_fsynth *fsynth = dev_get_drvdata(device);
 
-	snd_stm_printd(1, "snd_stm_fsynth_add_control(fsynth_channel=%p, "
-			"card=%p, card_device=%d)\n", fsynth_channel,
+	snd_stm_printt("snd_stm_fsynth_add_control(device=%p, channel=%d, "
+			"card=%p, card_device=%d)\n", device, channel,
 			card, card_device);
 
-	snd_stm_assert(fsynth_channel, return -EINVAL);
-	snd_stm_magic_assert(fsynth_channel, return -EINVAL);
+	snd_assert(fsynth, return -EINVAL);
+	snd_stm_magic_assert(fsynth, return -EINVAL);
+	snd_assert(channel >= fsynth->channels_from, return -EINVAL);
+	snd_assert(channel <= fsynth->channels_to, return -EINVAL);
 
 	snd_stm_fsynth_adjustment_ctl.device = card_device;
 	result = snd_ctl_add(card, snd_ctl_new1(&snd_stm_fsynth_adjustment_ctl,
-			fsynth_channel));
+			&fsynth->channels[channel]));
+	/* TODO: index per card */
 	snd_stm_fsynth_adjustment_ctl.index++;
 
 	return result;
@@ -546,8 +527,9 @@
 #define DUMP_REGISTER(r, n) \
 		snd_iprintf(buffer, "AUDCFG_FSYN%d_%s (offset 0x%02x) " \
 				"= 0x%08x\n", n, __stringify(r), \
-				offset__AUDCFG_FSYN_##r(fsynth, n), \
-				get__AUDCFG_FSYN_##r(fsynth, n))
+				AUDCFG_FSYN_##r(n), \
+				REGISTER_PEEK_N(fsynth->base, \
+				AUDCFG_FSYN_##r, n))
 
 static void snd_stm_fsynth_dump_registers(struct snd_info_entry *entry,
 		struct snd_info_buffer *buffer)
@@ -555,23 +537,18 @@
 	struct snd_stm_fsynth *fsynth = entry->private_data;
 	int i;
 
-	snd_stm_assert(fsynth, return);
+	snd_assert(fsynth, return);
 	snd_stm_magic_assert(fsynth, return);
 
-	snd_iprintf(buffer, "--- %s ---\n", fsynth->bus_id);
-	snd_iprintf(buffer, "base = 0x%p\n", fsynth->base);
-
 	snd_iprintf(buffer, "AUDCFG_FSYN_CFG (offset 0x00) = 0x%08x\n",
-			get__AUDCFG_FSYN_CFG(fsynth));
+			REGISTER_PEEK(fsynth->base, AUDCFG_FSYN_CFG));
 
-	for (i = 0; i < CHANNELS_MAX; i++) {
+	for (i = 0; i < CHANNELS; i++) {
 		DUMP_REGISTER(MD, i);
 		DUMP_REGISTER(PE, i);
 		DUMP_REGISTER(SDIV, i);
 		DUMP_REGISTER(PROGEN, i);
 	}
-
-	snd_iprintf(buffer, "\n");
 }
 
 static int snd_stm_fsynth_register(struct snd_device *snd_device)
@@ -580,46 +557,39 @@
 	unsigned long value = 0;
 	int i;
 
-	snd_stm_assert(fsynth, return -EINVAL);
+	snd_assert(fsynth, return -EINVAL);
 	snd_stm_magic_assert(fsynth, return -EINVAL);
 
-	snd_stm_printd(0, "--- Registering frequency synthesizer '%s'...\n",
-			fsynth->bus_id);
-
 	/* Initialize & reset synthesizer */
 
-	value |= mask__AUDCFG_FSYN_CFG__RSTP__RESET(fsynth);
-	for (i = fsynth->info->channels_from; i <= fsynth->info->channels_to;
-			i++) {
-		snd_stm_printd(0, "Enabling synthesizer '%s' channel %d\n",
+	value |= REGFIELD_VALUE(AUDCFG_FSYN_CFG, RSTP, RESET);
+	for (i = fsynth->channels_from; i <= fsynth->channels_to; i++) {
+		snd_printd("Enabling synthesizer '%s' channel %d\n",
 				fsynth->bus_id, i);
-		value |= fsynth->info->value_pcm_clk_sel <<
-				shift__AUDCFG_FSYN_CFG__PCM_CLK_SEL(fsynth, i);
-		if (!fsynth->info->no_fs_en)
-			value |= mask__AUDCFG_FSYN_CFG__FS_EN__ENABLED(fsynth,
-					i);
-		value |= mask__AUDCFG_FSYN_CFG__NSB__ACTIVE(fsynth, i);
-	}
-	value |= mask__AUDCFG_FSYN_CFG__NPDA__NORMAL(fsynth);
-	value |= mask__AUDCFG_FSYN_CFG__NDIV__27_30_MHZ(fsynth);
-	value |= mask__AUDCFG_FSYN_CFG__BW_SEL__GOOD_REFERENCE(fsynth);
-	value |= fsynth->info->value_ref_clk_in <<
-			shift__AUDCFG_FSYN_CFG__REF_CLK_IN(fsynth);
+		value |= REGFIELD_VALUE(AUDCFG_FSYN_CFG, PCM_CLK_SEL,
+				FSYNTH(i));
+#if defined(CONFIG_CPU_SUBTYPE_STB7100) || defined(CONFIG_CPU_SUBTYPE_STX7111)
+		value |= REGFIELD_VALUE(AUDCFG_FSYN_CFG, FS_EN, ENABLED(i));
+#endif
+		value |= REGFIELD_VALUE(AUDCFG_FSYN_CFG, NSB, ACTIVE(i));
+	}
+	value |= REGFIELD_VALUE(AUDCFG_FSYN_CFG, NPDA, NORMAL);
+	value |= REGFIELD_VALUE(AUDCFG_FSYN_CFG, NDIV, 27_30_MHZ);
+	value |= REGFIELD_VALUE(AUDCFG_FSYN_CFG, BW_SEL, GOOD_REFERENCE);
+	value |= REGFIELD_VALUE(AUDCFG_FSYN_CFG, REF_CLK_IN, 30_MHZ_CLOCK);
 
-	set__AUDCFG_FSYN_CFG(fsynth, value);
+	REGISTER_POKE(fsynth->base, AUDCFG_FSYN_CFG, value);
 	barrier();
 
 	/* Unreset ;-) it now */
 
-	set__AUDCFG_FSYN_CFG__RSTP__RUNNING(fsynth);
+	REGFIELD_SET(fsynth->base, AUDCFG_FSYN_CFG, RSTP, RUNNING);
 
 	/* Additional procfs info */
 
 	snd_stm_info_register(&fsynth->proc_entry, fsynth->bus_id,
 			snd_stm_fsynth_dump_registers, fsynth);
 
-	snd_stm_printd(0, "--- Registered successfully!\n");
-
 	return 0;
 }
 
@@ -629,7 +599,7 @@
 	unsigned long value = 0;
 	int i;
 
-	snd_stm_assert(fsynth, return -EINVAL);
+	snd_assert(fsynth, return -EINVAL);
 	snd_stm_magic_assert(fsynth, return -EINVAL);
 
 	/* Remove procfs entry */
@@ -638,17 +608,16 @@
 
 	/* Disable synthesizer */
 
-	value |= mask__AUDCFG_FSYN_CFG__RSTP__RESET(fsynth);
-	for (i = fsynth->info->channels_from; i <= fsynth->info->channels_to;
-			i++) {
-		if (!fsynth->info->no_fs_en)
-			value |= mask__AUDCFG_FSYN_CFG__FS_EN__DISABLED(fsynth,
-					i);
-		value |= mask__AUDCFG_FSYN_CFG__NSB__STANDBY(fsynth, i);
+	value |= REGFIELD_VALUE(AUDCFG_FSYN_CFG, RSTP, RUNNING);
+	for (i = fsynth->channels_from; i <= fsynth->channels_to; i++) {
+#if defined(CONFIG_CPU_SUBTYPE_STB7100) || defined(CONFIG_CPU_SUBTYPE_STX7111)
+		value |= REGFIELD_VALUE(AUDCFG_FSYN_CFG, FS_EN, DISABLED(i));
+#endif
+		value |= REGFIELD_VALUE(AUDCFG_FSYN_CFG, NSB, STANDBY(i));
 	}
-	value |= mask__AUDCFG_FSYN_CFG__NPDA__POWER_DOWN(fsynth);
+	value |= REGFIELD_VALUE(AUDCFG_FSYN_CFG, NPDA, POWER_DOWN);
 
-	set__AUDCFG_FSYN_CFG(fsynth, value);
+	REGISTER_POKE(fsynth->base, AUDCFG_FSYN_CFG, value);
 
 	return 0;
 }
@@ -664,13 +633,17 @@
  * Platform driver routines
  */
 
-static int snd_stm_fsynth_probe(struct platform_device *pdev)
+static int __init snd_stm_fsynth_probe(struct platform_device *pdev)
 {
 	int result = 0;
+	struct snd_stm_fsynth_info *fsynth_info = pdev->dev.platform_data;
 	struct snd_stm_fsynth *fsynth;
+	struct snd_card *card;
 	int i;
 
-	snd_stm_printd(0, "--- Probing device '%s'...\n", pdev->dev.bus_id);
+	snd_printd("--- Probing device '%s'...\n", pdev->dev.bus_id);
+
+	snd_assert(fsynth_info != NULL, return -EINVAL);
 
 	fsynth = kzalloc(sizeof(*fsynth), GFP_KERNEL);
 	if (!fsynth) {
@@ -680,13 +653,9 @@
 		goto error_alloc;
 	}
 	snd_stm_magic_set(fsynth);
-	fsynth->info = pdev->dev.platform_data;
-	snd_stm_assert(fsynth->info != NULL, return -EINVAL);
 	fsynth->bus_id = pdev->dev.bus_id;
-	for (i = 0; i < CHANNELS_MAX; i++) {
+	for (i = 0; i < CHANNELS; i++)
 		fsynth->channels[i].fsynth = fsynth;
-		snd_stm_magic_set(&fsynth->channels[i]);
-	}
 
 	result = snd_stm_memory_request(pdev, &fsynth->mem_region,
 			&fsynth->base);
@@ -695,18 +664,27 @@
 		goto error_memory_request;
 	}
 
-	snd_stm_assert(fsynth->info->channels_from < fsynth->info->channels_to,
-			return -EINVAL);
-	snd_stm_assert(fsynth->info->channels_from >= 0, return -EINVAL);
-	snd_stm_assert(fsynth->info->channels_to < CHANNELS_MAX,
+	if (fsynth_info->card_id)
+		card = snd_stm_cards_get(fsynth_info->card_id);
+	else
+		card = snd_stm_cards_default();
+	snd_assert(card, return -EINVAL);
+	snd_printd("This frequency synthesizer will be a member "
+			"of a card '%s'\n", card->id);
+
+	fsynth->channels_from = fsynth_info->channels_from;
+	fsynth->channels_to = fsynth_info->channels_to;
+	snd_assert(fsynth->channels_from < fsynth->channels_to,
 			return -EINVAL);
+	snd_assert(fsynth->channels_from >= 0, return -EINVAL);
+	snd_assert(fsynth->channels_to < CHANNELS, return -EINVAL);
 
-	snd_stm_printd(0, "Used synthesizer channels: %d to %d\n",
-			fsynth->info->channels_from, fsynth->info->channels_to);
+	snd_printd("Used synthesizer channels: %d to %d\n",
+			fsynth->channels_from, fsynth->channels_to);
 
 	/* ALSA component */
 
-	result = snd_device_new(snd_stm_card_get(), SNDRV_DEV_LOWLEVEL, fsynth,
+	result = snd_device_new(card, SNDRV_DEV_LOWLEVEL, fsynth,
 			&snd_stm_fsynth_snd_device_ops);
 	if (result < 0) {
 		snd_stm_printe("ALSA low level device creation failed!\n");
@@ -717,7 +695,7 @@
 
 	platform_set_drvdata(pdev, fsynth);
 
-	snd_stm_printd(0, "--- Probed successfully!\n");
+	snd_printd("--- Probed successfully!\n");
 
 	return result;
 
@@ -733,15 +711,12 @@
 static int snd_stm_fsynth_remove(struct platform_device *pdev)
 {
 	struct snd_stm_fsynth *fsynth = platform_get_drvdata(pdev);
-	int i;
 
-	snd_stm_assert(fsynth, return -EINVAL);
+	snd_assert(fsynth, return -EINVAL);
 	snd_stm_magic_assert(fsynth, return -EINVAL);
 
 	snd_stm_memory_release(fsynth->mem_region, fsynth->base);
 
-	for (i = 0; i < CHANNELS_MAX; i++)
-		snd_stm_magic_clear(&fsynth->channels[i]);
 	snd_stm_magic_clear(fsynth);
 	kfree(fsynth);
 
@@ -750,7 +725,7 @@
 
 static struct platform_driver snd_stm_fsynth_driver = {
 	.driver = {
-		.name = "snd_fsynth",
+		.name = "fsynth",
 	},
 	.probe = snd_stm_fsynth_probe,
 	.remove = snd_stm_fsynth_remove,
@@ -767,7 +742,7 @@
 	return platform_driver_register(&snd_stm_fsynth_driver);
 }
 
-void snd_stm_fsynth_exit(void)
+void snd_stm_fsynth_cleanup(void)
 {
 	platform_driver_unregister(&snd_stm_fsynth_driver);
 }
diff -rcN linux-sh4-2.6.23.17_stm23_0119-orig/sound//stm/init.c linux-sh4/sound//stm/init.c
*** linux-sh4-2.6.23.17_stm23_0119-orig/sound//stm/init.c	2009-06-06 20:17:15.000000000 +0200
--- linux-sh4/sound//stm/init.c	2009-07-18 22:07:19.000000000 +0200
***************
*** 1,9 ****
  /*
!  *   STMicrolectronics System-on-Chips' audio subsystem core driver
   *
   *   Copyright (c) 2005-2007 STMicroelectronics Limited
   *
!  *   Author: Pawel Moll <pawel.moll@st.com>
   *
   *   This program is free software; you can redistribute it and/or modify
   *   it under the terms of the GNU General Public License as published by
--- 1,9 ----
  /*
!  *   STMicrolectronics System-on-Chips' audio subsystem driver
   *
   *   Copyright (c) 2005-2007 STMicroelectronics Limited
   *
!  *   Author: Pawel MOLL <pawel.moll@st.com>
   *
   *   This program is free software; you can redistribute it and/or modify
   *   it under the terms of the GNU General Public License as published by
***************
*** 26,129 ****
  #include <sound/driver.h>
  #include <sound/core.h>
  
! #define COMPONENT init
  #include "common.h"
  
! /* General debug level */
! #if defined(CONFIG_SND_STM_DEBUG_LEVEL)
! static int debug = CONFIG_SND_STM_DEBUG_LEVEL;
! module_param(debug, int, S_IRUGO | S_IWUSR);
! int *snd_stm_debug_level = &debug;
! EXPORT_SYMBOL(snd_stm_debug_level);
! #endif
  
! static int __init snd_stm_init(void)
  {
  	int result;
  
! 	snd_stm_printd(0, "snd_stm_init()\n");
  
! 	result = snd_stm_info_create();
  	if (result != 0) {
! 		snd_stm_printe("Procfs info creation failed!\n");
  		goto error_info;
  	}
  	result = snd_stm_fsynth_init();
  	if (result != 0) {
! 		snd_stm_printe("Frequency synthesizer driver initialization"
! 				" failed!\n");
  		goto error_fsynth;
  	}
  	result = snd_stm_conv_init();
  	if (result != 0) {
! 		snd_stm_printe("Converters infrastructure initialization"
! 				" failed!\n");
  		goto error_conv;
  	}
! 	result = snd_stm_conv_int_dac_init();
  	if (result != 0) {
! 		snd_stm_printe("Internal DACs driver initialization failed!\n");
! 		goto error_conv_int_dac;
  	}
! 	result = snd_stm_conv_i2sspdif_init();
  	if (result != 0) {
! 		snd_stm_printe("I2S to SPDIF converter driver initialization"
! 				" failed!\n");
! 		goto error_conv_i2sspdif;
  	}
  	result = snd_stm_pcm_player_init();
  	if (result != 0) {
! 		snd_stm_printe("PCM player driver initialization failed!\n");
  		goto error_pcm_player;
  	}
  	result = snd_stm_pcm_reader_init();
  	if (result != 0) {
! 		snd_stm_printe("PCM reader driver initialization failed!\n");
  		goto error_pcm_reader;
  	}
  	result = snd_stm_spdif_player_init();
  	if (result != 0) {
! 		snd_stm_printe("SPDIF player driver initialization failed!\n");
  		goto error_spdif_player;
  	}
  
  	return result;
  
  error_spdif_player:
! 	snd_stm_pcm_reader_exit();
  error_pcm_reader:
! 	snd_stm_pcm_player_exit();
  error_pcm_player:
! 	snd_stm_conv_i2sspdif_exit();
! error_conv_i2sspdif:
! 	snd_stm_conv_int_dac_exit();
! error_conv_int_dac:
! 	snd_stm_conv_exit();
  error_conv:
! 	snd_stm_fsynth_exit();
  error_fsynth:
! 	snd_stm_info_dispose();
  error_info:
  	return result;
  }
  
! static void __exit snd_stm_exit(void)
  {
! 	snd_stm_printd(0, "snd_stm_exit()\n");
  
! 	snd_stm_spdif_player_exit();
! 	snd_stm_pcm_reader_exit();
! 	snd_stm_pcm_player_exit();
! 	snd_stm_conv_i2sspdif_exit();
! 	snd_stm_conv_int_dac_exit();
! 	snd_stm_conv_exit();
! 	snd_stm_fsynth_exit();
! 	snd_stm_info_dispose();
! }
  
! MODULE_AUTHOR("Pawel Moll <pawel.moll@st.com>");
! MODULE_DESCRIPTION("STMicroelectronics System-on-Chips' audio core driver");
! MODULE_LICENSE("GPL");
  
! module_init(snd_stm_init)
! module_exit(snd_stm_exit)
--- 26,182 ----
  #include <sound/driver.h>
  #include <sound/core.h>
  
! #undef TRACE
  #include "common.h"
  
! MODULE_AUTHOR("Pawel MOLL <pawel.moll@st.com>");
! MODULE_DESCRIPTION("STMicroelectronics System-on-Chips' audio subsystem");
! MODULE_LICENSE("GPL");
  
! static int __init alsa_card_stm_init(void)
  {
  	int result;
  
! 	snd_printd("=== STM ALSA driver is initializing...\n");
  
! #if defined(CONFIG_CPU_SUBTYPE_STB7100)
! 	result = snd_stm_stx7100_init();
! #endif
! #if defined(CONFIG_CPU_SUBTYPE_STX7111)
! 	result = snd_stm_stx7111_init();
! #endif
! #if defined(CONFIG_CPU_SUBTYPE_STX7200)
! 	result = snd_stm_stx7200_init();
! #endif
  	if (result != 0) {
! 		snd_stm_printe("Can't initialize SOC platform!\n");
! 		goto error_soc;
! 	}
! 
! 	result = snd_stm_info_init();
! 	if (result != 0) {
! 		snd_stm_printe("Can't initialize procfs info entries!\n");
  		goto error_info;
  	}
+ 	result = snd_stm_audio_outputs_init();
+ 	if (result != 0) {
+ 		snd_stm_printe("Can't initialize audio outputs!\n");
+ 		goto error_audio_outputs;
+ 	}
  	result = snd_stm_fsynth_init();
  	if (result != 0) {
! 		snd_stm_printe("Can't initialize frequency synthesizer!\n");
  		goto error_fsynth;
  	}
  	result = snd_stm_conv_init();
  	if (result != 0) {
! 		snd_stm_printe("Can't initialize converters infrastructure!\n");
  		goto error_conv;
  	}
! 	result = snd_stm_conv_dummy_init();
  	if (result != 0) {
! 		snd_stm_printe("Can't initialize dummy converter!\n");
! 		goto error_conv_dummy;
  	}
! 	result = snd_stm_conv_internal_dac_init();
  	if (result != 0) {
! 		snd_stm_printe("Can't initialize internal DACs!\n");
! 		goto error_conv_internal_dac;
! 	}
! 	result = snd_stm_conv_i2s_spdif_init();
! 	if (result != 0) {
! 		snd_stm_printe("Can't initialize I2S to SPDIF converter!\n");
! 		goto error_conv_i2s_spdif;
! 	}
! 	result = snd_stm_synchro_init();
! 	if (result != 0) {
! 		snd_stm_printe("Can't initialize synchronisation routines!\n");
! 		goto error_synchro;
  	}
  	result = snd_stm_pcm_player_init();
  	if (result != 0) {
! 		snd_stm_printe("Can't initialize PCM player!\n");
  		goto error_pcm_player;
  	}
  	result = snd_stm_pcm_reader_init();
  	if (result != 0) {
! 		snd_stm_printe("Can't initialize PCM reader!\n");
  		goto error_pcm_reader;
  	}
  	result = snd_stm_spdif_player_init();
  	if (result != 0) {
! 		snd_stm_printe("Can't initialize SPDIF player!\n");
  		goto error_spdif_player;
  	}
  
+ 	/* Cards should be created by SoC-specific initialization
+ 	 * function (snd_stm_stxXXXX_init) */
+ 	result = snd_stm_cards_register();
+ 	if (result != 0) {
+ 		snd_stm_printe("Can't register ALSA cards!\n");
+ 		goto error_cards;
+ 	}
+ 
+ 	snd_printd("=== Success!\n");
+ 
  	return result;
  
+ error_cards:
+ 	snd_stm_spdif_player_cleanup();
  error_spdif_player:
! 	snd_stm_pcm_reader_cleanup();
  error_pcm_reader:
! 	snd_stm_pcm_player_cleanup();
  error_pcm_player:
! 	snd_stm_synchro_cleanup();
! error_synchro:
! 	snd_stm_conv_i2s_spdif_cleanup();
! error_conv_i2s_spdif:
! 	snd_stm_conv_internal_dac_cleanup();
! error_conv_internal_dac:
! 	snd_stm_conv_dummy_cleanup();
! error_conv_dummy:
! 	snd_stm_conv_cleanup();
  error_conv:
! 	snd_stm_fsynth_cleanup();
  error_fsynth:
! 	snd_stm_audio_outputs_cleanup();
! error_audio_outputs:
! 	snd_stm_info_cleanup();
  error_info:
+ 	snd_stm_cards_free();
+ error_soc:
  	return result;
  }
  
! static void __exit alsa_card_stm_exit(void)
  {
! 	snd_printd("=== STM ALSA driver cleanup.\n");
  
! 	snd_stm_cards_free();
  
! 	snd_stm_spdif_player_cleanup();
! 	snd_stm_pcm_reader_cleanup();
! 	snd_stm_pcm_player_cleanup();
! 	snd_stm_synchro_cleanup();
! 	snd_stm_conv_i2s_spdif_cleanup();
! 	snd_stm_conv_internal_dac_cleanup();
! 	snd_stm_conv_dummy_cleanup();
! 	snd_stm_conv_cleanup();
! 	snd_stm_fsynth_cleanup();
! 	snd_stm_audio_outputs_cleanup();
! 	snd_stm_info_cleanup();
! 
! #if defined(CONFIG_CPU_SUBTYPE_STB7100)
! 	snd_stm_stx7100_cleanup();
! #endif
! #if defined(CONFIG_CPU_SUBTYPE_STX7111)
! 	snd_stm_stx7111_cleanup();
! #endif
! #if defined(CONFIG_CPU_SUBTYPE_STX7200)
! 	snd_stm_stx7200_cleanup();
! #endif
! }
  
! module_init(alsa_card_stm_init)
! module_exit(alsa_card_stm_exit)
diff -rcN linux-sh4-2.6.23.17_stm23_0119-orig/sound//stm/Makefile linux-sh4/sound//stm/Makefile
*** linux-sh4-2.6.23.17_stm23_0119-orig/sound//stm/Makefile	2009-06-06 20:17:15.000000000 +0200
--- linux-sh4/sound//stm/Makefile	2009-07-18 23:01:58.000000000 +0200
***************
*** 1,7 ****
  obj-$(CONFIG_SND_STM) += snd-stm.o
  snd-stm-y := init.o common.o fsynth.o
! snd-stm-y += conv.o conv_i2sspdif.o conv_int_dac.o
! snd-stm-y += pcm_player.o pcm_reader.o spdif_player.o
  
  obj-$(CONFIG_SND_STM_STX710X) += snd-stm-stx710x.o
  snd-stm-stx710x-y := stx710x.o
--- 1,7 ----
  obj-$(CONFIG_SND_STM) += snd-stm.o
  snd-stm-y := init.o common.o fsynth.o
! snd-stm-y += audio_outputs.o conv.o conv_dummy.o conv_i2sspdif.o conv_int_dac.o
! snd-stm-y += synchro.o pcm_player.o pcm_reader.o spdif_player.o
  
  obj-$(CONFIG_SND_STM_STX710X) += snd-stm-stx710x.o
  snd-stm-stx710x-y := stx710x.o
diff -urN linux-sh4-2.6.23.17_stm23_0119-orig/sound//stm/pcm_player.c linux-sh4/sound//stm/pcm_player.c
--- linux-sh4-2.6.23.17_stm23_0119-orig/sound//stm/pcm_player.c	2009-06-06 20:17:15.000000000 +0200
+++ linux-sh4/sound//stm/pcm_player.c	2009-07-18 22:44:39.000000000 +0200
@@ -3,7 +3,7 @@
  *
  *   Copyright (c) 2005-2007 STMicroelectronics Limited
  *
- *   Author: Pawel Moll <pawel.moll@st.com>
+ *   Author: Pawel MOLL <pawel.moll@st.com>
  *           Mark Glaisher
  *
  *   This program is free software; you can redistribute it and/or modify
@@ -26,9 +26,11 @@
 #include <linux/io.h>
 #include <linux/platform_device.h>
 #include <linux/interrupt.h>
-#include <linux/delay.h>
+#include <linux/bpa2.h>
 #include <asm/cacheflush.h>
+#include <linux/stm/soc.h>
 #include <linux/stm/stm-dma.h>
+#include <linux/stm/registers.h>
 #include <sound/driver.h>
 #include <sound/core.h>
 #include <sound/pcm.h>
@@ -36,9 +38,9 @@
 #include <sound/info.h>
 #include <sound/pcm_params.h>
 
-#define COMPONENT pcm_player
+#undef TRACE /* See common.h debug features */
+#define MAGIC 6 /* See common.h debug features */
 #include "common.h"
-#include "reg_aud_pcmout.h"
 
 
 
@@ -47,12 +49,14 @@
  */
 
 #define DEFAULT_FORMAT (SND_STM_FORMAT__I2S | \
-		SND_STM_FORMAT__SUBFRAME_32_BITS)
+		SND_STM_FORMAT__OUTPUT_SUBFRAME_32_BITS)
 #define DEFAULT_OVERSAMPLING 256
 
 /* The sample count field (NSAMPLES in CTRL register) is 19 bits wide */
 #define MAX_SAMPLES_PER_PERIOD ((1 << 19) - 1)
 
+#define MAX_CHANNELS 10
+
 
 
 /*
@@ -64,26 +68,24 @@
 	struct snd_stm_pcm_player_info *info;
 	struct device *device;
 	struct snd_pcm *pcm;
-	int ver; /* IP version, used by register access macros */
 
 	/* Resources */
 	struct resource *mem_region;
 	void *base;
 	unsigned long fifo_phys_address;
 	unsigned int irq;
-	int fdma_channel;
+	unsigned int fdma_channel;
 
 	/* Environment settings */
-	struct snd_stm_fsynth_channel *fsynth_channel;
+	struct device *fsynth_device;
+	int fsynth_channel;
+	struct snd_stm_conv *conv;
 	struct snd_pcm_hw_constraint_list channels_constraint;
-	struct snd_stm_conv_source *conv_source;
 
 	/* Runtime data */
-	struct snd_stm_conv_group *conv_group;
-	struct snd_stm_buffer *buffer;
+	void *buffer;
 	struct snd_info_entry *proc_entry;
 	struct snd_pcm_substream *substream;
-	int fdma_max_transfer_size;
 	struct stm_dma_params fdma_params;
 	struct stm_dma_req *fdma_request;
 
@@ -102,42 +104,39 @@
 	struct snd_stm_pcm_player *pcm_player = dev_id;
 	unsigned int status;
 
-	snd_stm_printd(2, "snd_stm_pcm_player_irq_handler(irq=%d, "
-			"dev_id=0x%p)\n", irq, dev_id);
+	snd_stm_printt("snd_stm_pcm_player_irq_handler(irq=%d, dev_id=0x%p)\n",
+			irq, dev_id);
 
-	snd_stm_assert(pcm_player, return -EINVAL);
+	snd_assert(pcm_player, return -EINVAL);
 	snd_stm_magic_assert(pcm_player, return -EINVAL);
 
 	/* Get interrupt status & clear them immediately */
 	preempt_disable();
-	status = get__AUD_PCMOUT_ITS(pcm_player);
-	set__AUD_PCMOUT_ITS_CLR(pcm_player, status);
+	status = REGISTER_PEEK(pcm_player->base, AUD_PCMOUT_ITS);
+	REGISTER_POKE(pcm_player->base, AUD_PCMOUT_ITS_CLR, status);
 	preempt_enable();
 
 	/* Underflow? */
-	if (unlikely(status & mask__AUD_PCMOUT_ITS__UNF__PENDING(pcm_player))) {
+	if (unlikely(status & REGFIELD_VALUE(AUD_PCMOUT_ITS, UNF, PENDING))) {
 		snd_stm_printe("Underflow detected in PCM player '%s'!\n",
 				pcm_player->device->bus_id);
-
-		snd_pcm_stop(pcm_player->substream, SNDRV_PCM_STATE_XRUN);
-
 		result = IRQ_HANDLED;
-	} else if (likely(status &
-			mask__AUD_PCMOUT_ITS__NSAMPLE__PENDING(pcm_player))) {
-		/* Period successfully played */
+	}
+
+	/* Period successfully played */
+	if (likely(status & REGFIELD_VALUE(AUD_PCMOUT_ITS, NSAMPLE, PENDING)))
 		do {
-			snd_stm_assert(pcm_player->substream, break);
+			snd_assert(pcm_player->substream, break);
 
-			snd_stm_printd(2, "Period elapsed ('%s')\n",
+			snd_stm_printt("Period elapsed ('%s')\n",
 					pcm_player->device->bus_id);
 			snd_pcm_period_elapsed(pcm_player->substream);
 
 			result = IRQ_HANDLED;
 		} while (0);
-	}
 
 	/* Some alien interrupt??? */
-	snd_stm_assert(result == IRQ_HANDLED);
+	snd_assert(result == IRQ_HANDLED);
 
 	return result;
 }
@@ -151,7 +150,14 @@
 	.formats	= (SNDRV_PCM_FMTBIT_S32_LE |
 				SNDRV_PCM_FMTBIT_S16_LE),
 
-	.rates		= SNDRV_PCM_RATE_CONTINUOUS,
+	.rates		= (SNDRV_PCM_RATE_32000 |
+				SNDRV_PCM_RATE_44100 |
+				SNDRV_PCM_RATE_48000 |
+				SNDRV_PCM_RATE_64000 |
+				SNDRV_PCM_RATE_88200 |
+				SNDRV_PCM_RATE_96000 |
+				SNDRV_PCM_RATE_176400 |
+				SNDRV_PCM_RATE_192000),
 	.rate_min	= 32000,
 	.rate_max	= 192000,
 
@@ -182,25 +188,23 @@
 			snd_pcm_substream_chip(substream);
 	struct snd_pcm_runtime *runtime = substream->runtime;
 
-	snd_stm_printd(1, "snd_stm_pcm_player_open(substream=0x%p)\n",
-			substream);
+	snd_stm_printt("snd_stm_pcm_player_open(substream=0x%p)\n", substream);
 
-	snd_stm_assert(pcm_player, return -EINVAL);
+	snd_assert(pcm_player, return -EINVAL);
 	snd_stm_magic_assert(pcm_player, return -EINVAL);
-	snd_stm_assert(runtime, return -EINVAL);
+	snd_assert(runtime, return -EINVAL);
 
 	snd_pcm_set_sync(substream);  /* TODO: ??? */
 
-	/* Get attached converters handle */
+	/* Get attached converter handle */
 
-	pcm_player->conv_group =
-			snd_stm_conv_request_group(pcm_player->conv_source);
-	if (pcm_player->conv_group)
-		snd_stm_printd(1, "'%s' is attached to '%s' converter(s)...\n",
-				pcm_player->device->bus_id,
-				snd_stm_conv_get_name(pcm_player->conv_group));
+	pcm_player->conv = snd_stm_conv_get_attached(pcm_player->device);
+	if (pcm_player->conv)
+		snd_stm_printt("Converter '%s' attached to '%s'...\n",
+				pcm_player->conv->name,
+				pcm_player->device->bus_id);
 	else
-		snd_stm_printd(1, "Warning! No converter attached to '%s'!\n",
+		snd_stm_printt("Warning! No converter attached to '%s'!\n",
 				pcm_player->device->bus_id);
 
 	/* Set up constraints & pass hardware capabilities info to ALSA */
@@ -226,7 +230,7 @@
 	 * of a FDMA transfer bytes (which varies depending on channels
 	 * number and sample bytes) */
 	result = snd_stm_pcm_hw_constraint_transfer_bytes(runtime,
-			pcm_player->fdma_max_transfer_size * 4);
+			pcm_player->info->fdma_max_transfer_size * 4);
 	if (result < 0) {
 		snd_stm_printe("Can't set buffer bytes constraint!\n");
 		return result;
@@ -234,9 +238,6 @@
 
 	runtime->hw = snd_stm_pcm_player_hw;
 
-	/* Interrupt handler will need the substream pointer... */
-	pcm_player->substream = substream;
-
 	return 0;
 }
 
@@ -245,19 +246,12 @@
 	struct snd_stm_pcm_player *pcm_player =
 			snd_pcm_substream_chip(substream);
 
-	snd_stm_printd(1, "snd_stm_pcm_player_close(substream=0x%p)\n",
+	snd_stm_printt("snd_stm_pcm_player_close(substream=0x%p)\n",
 			substream);
 
-	snd_stm_assert(pcm_player, return -EINVAL);
+	snd_assert(pcm_player, return -EINVAL);
 	snd_stm_magic_assert(pcm_player, return -EINVAL);
 
-	if (pcm_player->conv_group) {
-		snd_stm_conv_release_group(pcm_player->conv_group);
-		pcm_player->conv_group = NULL;
-	}
-
-	pcm_player->substream = NULL;
-
 	return 0;
 }
 
@@ -267,23 +261,36 @@
 			snd_pcm_substream_chip(substream);
 	struct snd_pcm_runtime *runtime = substream->runtime;
 
-	snd_stm_printd(1, "snd_stm_pcm_player_hw_free(substream=0x%p)\n",
+	snd_stm_printt("snd_stm_pcm_player_hw_free(substream=0x%p)\n",
 			substream);
 
-	snd_stm_assert(pcm_player, return -EINVAL);
+	snd_assert(pcm_player, return -EINVAL);
 	snd_stm_magic_assert(pcm_player, return -EINVAL);
-	snd_stm_assert(runtime, return -EINVAL);
+	snd_assert(runtime, return -EINVAL);
 
 	/* This callback may be called more than once... */
 
-	if (snd_stm_buffer_is_allocated(pcm_player->buffer)) {
-		/* Let the FDMA stop */
-		dma_wait_for_completion(pcm_player->fdma_channel);
+	if (pcm_player->buffer) {
+		/* Dispose buffer */
+
+		snd_stm_printt("Freeing buffer for %s: buffer=0x%p, "
+				"dma_addr=0x%08x, dma_area=0x%p, "
+				"dma_bytes=%u\n", pcm_player->device->bus_id,
+				pcm_player->buffer, runtime->dma_addr,
+				runtime->dma_area, runtime->dma_bytes);
+
+		iounmap(runtime->dma_area);
+
+		/* TODO: symmetrical to the above (BPA2 etc.) */
+		bigphysarea_free(pcm_player->buffer, runtime->dma_bytes);
+
+		pcm_player->buffer = NULL;
+		runtime->dma_area = NULL;
+		runtime->dma_addr = 0;
+		runtime->dma_bytes = 0;
 
-		/* Free buffer */
-		snd_stm_buffer_free(pcm_player->buffer);
+		/* Dispose FDMA parameters & configuration */
 
-		/* Free FDMA parameters & configuration */
 		dma_params_free(&pcm_player->fdma_params);
 		dma_req_free(pcm_player->fdma_channel,
 				pcm_player->fdma_request);
@@ -309,51 +316,61 @@
 		.initiator = pcm_player->info->fdma_initiator,
 	};
 
-	snd_stm_printd(1, "snd_stm_pcm_player_hw_params(substream=0x%p,"
+	snd_stm_printt("snd_stm_pcm_player_hw_params(substream=0x%p,"
 			" hw_params=0x%p)\n", substream, hw_params);
 
-	snd_stm_assert(pcm_player, return -EINVAL);
+	snd_assert(pcm_player, return -EINVAL);
 	snd_stm_magic_assert(pcm_player, return -EINVAL);
-	snd_stm_assert(runtime, return -EINVAL);
+	snd_assert(runtime, return -EINVAL);
 
 	/* This function may be called many times, so let's be prepared... */
-	if (snd_stm_buffer_is_allocated(pcm_player->buffer))
+	if (pcm_player->buffer)
 		snd_stm_pcm_player_hw_free(substream);
 
 	/* Allocate buffer */
 
 	buffer_bytes = params_buffer_bytes(hw_params);
-	result = snd_stm_buffer_alloc(pcm_player->buffer, substream,
-			buffer_bytes);
-	if (result != 0) {
+	pcm_player->buffer = bigphysarea_alloc(buffer_bytes);
+	/* TODO: move to BPA2, use pcm lib as fallback... */
+	if (!pcm_player->buffer) {
 		snd_stm_printe("Can't allocate %d bytes buffer for '%s'!\n",
 				buffer_bytes, pcm_player->device->bus_id);
 		result = -ENOMEM;
 		goto error_buf_alloc;
 	}
 
+	runtime->dma_addr = virt_to_phys(pcm_player->buffer);
+	runtime->dma_area = ioremap_nocache(runtime->dma_addr, buffer_bytes);
+	runtime->dma_bytes = buffer_bytes;
+
+	snd_stm_printt("Allocated buffer for %s: buffer=0x%p, "
+			"dma_addr=0x%08x, dma_area=0x%p, "
+			"dma_bytes=%u\n", pcm_player->device->bus_id,
+			pcm_player->buffer, runtime->dma_addr,
+			runtime->dma_area, runtime->dma_bytes);
+
 	/* Set FDMA transfer size (number of opcodes generated
 	 * after request line assertion) */
 
 	frame_bytes = snd_pcm_format_physical_width(params_format(hw_params)) *
 			params_channels(hw_params) / 8;
 	transfer_bytes = snd_stm_pcm_transfer_bytes(frame_bytes,
-			pcm_player->fdma_max_transfer_size * 4);
+			pcm_player->info->fdma_max_transfer_size * 4);
 	transfer_size = transfer_bytes / 4;
-	snd_stm_printd(1, "FDMA request trigger limit and transfer size set "
-			"to %d.\n", transfer_size);
+	snd_stm_printt("FDMA request trigger limit and transfer size set to "
+			"%d.\n", transfer_size);
 
-	snd_stm_assert(buffer_bytes % transfer_bytes == 0, return -EINVAL);
-	snd_stm_assert(transfer_size <= pcm_player->fdma_max_transfer_size,
+	snd_assert(buffer_bytes % transfer_bytes == 0, return -EINVAL);
+	snd_assert(transfer_size <= pcm_player->info->fdma_max_transfer_size,
 			return -EINVAL);
 	fdma_req_config.count = transfer_size;
 
-	snd_stm_assert(transfer_size == 1 || transfer_size % 2 == 0,
+	snd_assert(transfer_size == 1 || transfer_size % 2 == 0,
 			return -EINVAL);
-	snd_stm_assert(transfer_size <=
-			mask__AUD_PCMOUT_FMT__DMA_REQ_TRIG_LMT(pcm_player),
+	snd_assert(transfer_size <= AUD_PCMOUT_FMT__DMA_REQ_TRIG_LMT__MASK,
 			return -EINVAL);
-	set__AUD_PCMOUT_FMT__DMA_REQ_TRIG_LMT(pcm_player, transfer_size);
+	REGFIELD_POKE(pcm_player->base, AUD_PCMOUT_FMT,
+			DMA_REQ_TRIG_LMT, transfer_size);
 
 	/* Configure FDMA transfer */
 
@@ -390,7 +407,13 @@
 	dma_req_free(pcm_player->fdma_channel,
 			pcm_player->fdma_request);
 error_req_config:
-	snd_stm_buffer_free(pcm_player->buffer);
+	iounmap(runtime->dma_area);
+	/* TODO: symmetrical to the above (BPA2 etc.) */
+	bigphysarea_free(pcm_player->buffer, runtime->dma_bytes);
+	pcm_player->buffer = NULL;
+	runtime->dma_area = NULL;
+	runtime->dma_addr = 0;
+	runtime->dma_bytes = 0;
 error_buf_alloc:
 	return result;
 }
@@ -403,13 +426,13 @@
 	unsigned int format, lr_pol;
 	int oversampling, bits_in_output_frame;
 
-	snd_stm_printd(1, "snd_stm_pcm_player_prepare(substream=0x%p)\n",
+	snd_stm_printt("snd_stm_pcm_player_prepare(substream=0x%p)\n",
 			substream);
 
-	snd_stm_assert(pcm_player, return -EINVAL);
+	snd_assert(pcm_player, return -EINVAL);
 	snd_stm_magic_assert(pcm_player, return -EINVAL);
-	snd_stm_assert(runtime, return -EINVAL);
-	snd_stm_assert(runtime->period_size * runtime->channels <
+	snd_assert(runtime, return -EINVAL);
+	snd_assert(runtime->period_size * runtime->channels <
 			MAX_SAMPLES_PER_PERIOD, return -EINVAL);
 
 	/* Configure SPDIF synchronisation */
@@ -418,10 +441,9 @@
 
 	/* Get format & oversampling value from connected converter */
 
-	if (pcm_player->conv_group) {
-		format = snd_stm_conv_get_format(pcm_player->conv_group);
-		oversampling = snd_stm_conv_get_oversampling(
-				pcm_player->conv_group);
+	if (pcm_player->conv) {
+		format = snd_stm_conv_get_format(pcm_player->conv);
+		oversampling = snd_stm_conv_get_oversampling(pcm_player->conv);
 		if (oversampling == 0)
 			oversampling = DEFAULT_OVERSAMPLING;
 	} else {
@@ -429,26 +451,27 @@
 		oversampling = DEFAULT_OVERSAMPLING;
 	}
 
-	snd_stm_printd(1, "Player %s: sampling frequency %d, oversampling %d\n",
+	snd_stm_printt("Player %s: sampling frequency %d, oversampling %d\n",
 			pcm_player->device->bus_id, runtime->rate,
 			oversampling);
 
-	snd_stm_assert(oversampling > 0, return -EINVAL);
+	snd_assert(oversampling > 0, return -EINVAL);
 
 	/* For 32 bits subframe oversampling must be a multiple of 128,
 	 * for 16 bits - of 64 */
-	snd_stm_assert(((format & SND_STM_FORMAT__SUBFRAME_32_BITS) &&
+	snd_assert(((format & SND_STM_FORMAT__OUTPUT_SUBFRAME_32_BITS) &&
 				(oversampling % 128 == 0)) ||
 				(oversampling % 64 == 0), return -EINVAL);
 
 	/* Set up frequency synthesizer */
 
-	snd_stm_fsynth_set_frequency(pcm_player->fsynth_channel,
+	snd_stm_fsynth_set_frequency(pcm_player->fsynth_device,
+			pcm_player->fsynth_channel,
 			runtime->rate * oversampling);
 
 	/* Set up player hardware */
 
-	snd_stm_printd(1, "Player %s format configuration:\n",
+	snd_stm_printt("Player %s format configuration:\n",
 			pcm_player->device->bus_id);
 
 	/* Number of bits per subframe (which is one channel sample)
@@ -458,22 +481,26 @@
 	 * rate for 16 bits subframe
 	 * (you know why, don't you? :-) */
 
-	switch (format & SND_STM_FORMAT__SUBFRAME_MASK) {
-	case SND_STM_FORMAT__SUBFRAME_32_BITS:
-		snd_stm_printd(1, "- 32 bits per subframe\n");
-		set__AUD_PCMOUT_FMT__NBIT__32_BITS(pcm_player);
-		if (pcm_player->ver > ver__AUD_PCMOUT__65_1_3)
-			set__AUD_PCMOUT_FMT__DATA_SIZE__32_BITS(pcm_player);
-		else
-			set__AUD_PCMOUT_FMT__DATA_SIZE__24_BITS(pcm_player);
+	switch (format & SND_STM_FORMAT__OUTPUT_SUBFRAME_MASK) {
+	case SND_STM_FORMAT__OUTPUT_SUBFRAME_32_BITS:
+		snd_stm_printt("- 32 bits per subframe\n");
+		REGFIELD_SET(pcm_player->base, AUD_PCMOUT_FMT, NBIT, 32_BITS);
+#if defined(CONFIG_CPU_SUBTYPE_STX7111)
+		REGFIELD_SET(pcm_player->base, AUD_PCMOUT_FMT,
+				DATA_SIZE, 32_BITS);
+#else
+		REGFIELD_SET(pcm_player->base, AUD_PCMOUT_FMT,
+				DATA_SIZE, 24_BITS);
+#endif
 		bits_in_output_frame = 64; /* frame = 2 * subframe */
 		break;
-	case SND_STM_FORMAT__SUBFRAME_16_BITS:
-		snd_stm_printd(1, "- 16 bits per subframe\n");
-		set__AUD_PCMOUT_FMT__NBIT__16_BITS(pcm_player);
-		set__AUD_PCMOUT_FMT__DATA_SIZE__16_BITS(pcm_player);
-		bits_in_output_frame = 32; /* frame = 2 * subframe */
-		break;
+	case SND_STM_FORMAT__OUTPUT_SUBFRAME_16_BITS:
+		snd_stm_printt("- 16 bits per subframe\n");
+		REGFIELD_SET(pcm_player->base, AUD_PCMOUT_FMT, NBIT, 16_BITS);
+			REGFIELD_SET(pcm_player->base, AUD_PCMOUT_FMT,
+					DATA_SIZE, 16_BITS);
+			bits_in_output_frame = 32; /* frame = 2 * subframe */
+			break;
 	default:
 		snd_BUG();
 		return -EINVAL;
@@ -483,34 +510,44 @@
 	 * see ie.:
 	 * http://www.cirrus.com/en/pubs/appNote/AN282REV1.pdf */
 
-	set__AUD_PCMOUT_FMT__ORDER__MSB_FIRST(pcm_player);
-
-	/* Value FALLING of SCLK_EDGE bit in AUD_PCMOUT_FMT register that
-	 * actually means "data clocking (changing) on the falling edge"
-	 * (and we usually want this...) - STx7100 and cuts < 3.0 of
-	 * STx7109 have this bit inverted comparing to what their
-	 * datasheets claim... (specs say 1) */
+	REGFIELD_SET(pcm_player->base, AUD_PCMOUT_FMT,
+			ORDER, MSB_FIRST);
 
-	set__AUD_PCMOUT_FMT__SCLK_EDGE__FALLING(pcm_player);
+	/* Value of SCLK_EDGE bit in AUD_PCMOUT_FMT register that
+	 * actually means "data clocking on the falling edge" -
+	 * STx7100 and _some_ cuts of STx7109 have this value
+	 * inverted than datasheets claim... (specs say 1) */
+
+	if (pcm_player->info->invert_sclk_edge_falling) {
+		snd_stm_printt("Inverted SCLK_EDGE!\n");
+		REGFIELD_SET(pcm_player->base, AUD_PCMOUT_FMT,
+				SCLK_EDGE, RISING);
+	} else {
+		REGFIELD_SET(pcm_player->base, AUD_PCMOUT_FMT,
+				SCLK_EDGE, FALLING);
+	}
 
 	switch (format & SND_STM_FORMAT__MASK) {
 	case SND_STM_FORMAT__I2S:
-		snd_stm_printd(1, "- I2S\n");
-		set__AUD_PCMOUT_FMT__ALIGN__LEFT(pcm_player);
-		set__AUD_PCMOUT_FMT__PADDING__1_CYCLE_DELAY(pcm_player);
-		lr_pol = value__AUD_PCMOUT_FMT__LR_POL__LEFT_LOW(pcm_player);
+		snd_stm_printt("- I2S\n");
+		REGFIELD_SET(pcm_player->base, AUD_PCMOUT_FMT, ALIGN, LEFT);
+		REGFIELD_SET(pcm_player->base, AUD_PCMOUT_FMT,
+				PADDING, 1_CYCLE_DELAY);
+		lr_pol = AUD_PCMOUT_FMT__LR_POL__VALUE__LEFT_LOW;
 		break;
 	case SND_STM_FORMAT__LEFT_JUSTIFIED:
-		snd_stm_printd(1, "- left justified\n");
-		set__AUD_PCMOUT_FMT__ALIGN__LEFT(pcm_player);
-		set__AUD_PCMOUT_FMT__PADDING__NO_DELAY(pcm_player);
-		lr_pol = value__AUD_PCMOUT_FMT__LR_POL__LEFT_HIGH(pcm_player);
+		snd_stm_printt("- left justified\n");
+		REGFIELD_SET(pcm_player->base, AUD_PCMOUT_FMT, ALIGN, LEFT);
+		REGFIELD_SET(pcm_player->base, AUD_PCMOUT_FMT,
+				PADDING, NO_DELAY);
+		lr_pol = AUD_PCMOUT_FMT__LR_POL__VALUE__LEFT_HIGH;
 		break;
 	case SND_STM_FORMAT__RIGHT_JUSTIFIED:
-		snd_stm_printd(1, "- right justified\n");
-		set__AUD_PCMOUT_FMT__ALIGN__RIGHT(pcm_player);
-		set__AUD_PCMOUT_FMT__PADDING__NO_DELAY(pcm_player);
-		lr_pol = value__AUD_PCMOUT_FMT__LR_POL__LEFT_HIGH(pcm_player);
+		snd_stm_printt("- right justified\n");
+		REGFIELD_SET(pcm_player->base, AUD_PCMOUT_FMT, ALIGN, RIGHT);
+		REGFIELD_SET(pcm_player->base, AUD_PCMOUT_FMT,
+				PADDING, NO_DELAY);
+		lr_pol = AUD_PCMOUT_FMT__LR_POL__VALUE__LEFT_HIGH;
 		break;
 	default:
 		snd_BUG();
@@ -535,7 +572,7 @@
 	 *                (32 or 64, depending on NBIT field of FMT register)
 	 */
 
-	set__AUD_PCMOUT_CTRL__CLK_DIV(pcm_player,
+	REGFIELD_POKE(pcm_player->base, AUD_PCMOUT_CTRL, CLK_DIV,
 			oversampling / (2 * bits_in_output_frame));
 
 	/* Configure data memory format & NSAMPLE interrupt */
@@ -543,7 +580,8 @@
 	switch (runtime->format) {
 	case SNDRV_PCM_FORMAT_S16_LE:
 		/* One data word contains two samples */
-		set__AUD_PCMOUT_CTRL__MEM_FMT__16_BITS_16_BITS(pcm_player);
+		REGFIELD_SET(pcm_player->base, AUD_PCMOUT_CTRL,
+				MEM_FMT, 16_BITS_16_BITS);
 
 		/* Workaround for a problem with L/R channels swap in case of
 		 * 16/16 memory model: PCM player expects left channel data in
@@ -554,25 +592,28 @@
 		 * by one sample...
 		 * (ask me for more details if above is not clear ;-)
 		 * TODO this somehow better... */
-		set__AUD_PCMOUT_FMT__LR_POL(pcm_player, !lr_pol);
+		REGFIELD_POKE(pcm_player->base, AUD_PCMOUT_FMT,
+				LR_POL, !lr_pol);
 
 		/* One word of data is two samples (two channels...) */
-		set__AUD_PCMOUT_CTRL__NSAMPLE(pcm_player,
+		REGFIELD_POKE(pcm_player->base, AUD_PCMOUT_CTRL, NSAMPLE,
 				runtime->period_size * runtime->channels / 2);
 		break;
 
 	case SNDRV_PCM_FORMAT_S32_LE:
 		/* Actually "16 bits/0 bits" means "32/28/24/20/18/16 bits
 		 * on the left than zeros (if less than 32 bites)"... ;-) */
-		set__AUD_PCMOUT_CTRL__MEM_FMT__16_BITS_0_BITS(pcm_player);
+		REGFIELD_SET(pcm_player->base, AUD_PCMOUT_CTRL,
+				MEM_FMT, 16_BITS_0_BITS);
 
 		/* In x/0 bits memory mode there is no problem with
 		 * L/R polarity */
-		set__AUD_PCMOUT_FMT__LR_POL(pcm_player, lr_pol);
+		REGFIELD_POKE(pcm_player->base, AUD_PCMOUT_FMT, LR_POL,
+				lr_pol);
 
 		/* One word of data is one sample, so period size
 		 * times channels */
-		set__AUD_PCMOUT_CTRL__NSAMPLE(pcm_player,
+		REGFIELD_POKE(pcm_player->base, AUD_PCMOUT_CTRL, NSAMPLE,
 				runtime->period_size * runtime->channels);
 		break;
 
@@ -583,11 +624,12 @@
 
 	/* Number of channels... */
 
-	snd_stm_assert(runtime->channels % 2 == 0, return -EINVAL);
-	snd_stm_assert(runtime->channels >= 2 && runtime->channels <= 10,
+	snd_assert(runtime->channels % 2 == 0, return -EINVAL);
+	snd_assert(runtime->channels >= 2 && runtime->channels <= MAX_CHANNELS,
 			return -EINVAL);
 
-	set__AUD_PCMOUT_FMT__NUM_CH(pcm_player, runtime->channels / 2);
+	REGFIELD_POKE(pcm_player->base, AUD_PCMOUT_FMT, NUM_CH,
+			runtime->channels / 2);
 
 	return 0;
 }
@@ -598,15 +640,15 @@
 	struct snd_stm_pcm_player *pcm_player =
 			snd_pcm_substream_chip(substream);
 
-	snd_stm_printd(1, "snd_stm_pcm_player_start(substream=0x%p)\n",
+	snd_stm_printt("snd_stm_pcm_player_start(substream=0x%p)\n",
 			substream);
 
-	snd_stm_assert(pcm_player, return -EINVAL);
+	snd_assert(pcm_player, return -EINVAL);
 	snd_stm_magic_assert(pcm_player, return -EINVAL);
 
 	/* Un-reset PCM player */
 
-	set__AUD_PCMOUT_RST__SRSTP__RUNNING(pcm_player);
+	REGFIELD_SET(pcm_player->base, AUD_PCMOUT_RST, SRSTP, RUNNING);
 
 	/* Launch FDMA transfer */
 
@@ -617,28 +659,22 @@
 				pcm_player->device->bus_id);
 		return -EINVAL;
 	}
-	while (dma_get_status(pcm_player->fdma_channel) !=
-			DMA_CHANNEL_STATUS_RUNNING)
-		udelay(5);
 
-	/* Enable player interrupts (and clear possible stalled ones) */
+	/* Launch PCM player */
 
-	enable_irq(pcm_player->irq);
-	set__AUD_PCMOUT_ITS_CLR__NSAMPLE__CLEAR(pcm_player);
-	set__AUD_PCMOUT_IT_EN_SET__NSAMPLE__SET(pcm_player);
-	set__AUD_PCMOUT_ITS_CLR__UNF__CLEAR(pcm_player);
-	set__AUD_PCMOUT_IT_EN_SET__UNF__SET(pcm_player);
+	pcm_player->substream = substream;
+	REGFIELD_SET(pcm_player->base, AUD_PCMOUT_CTRL, MODE, PCM);
 
-	/* Launch the player */
+	/* Enable player interrupts */
 
-	set__AUD_PCMOUT_CTRL__MODE__PCM(pcm_player);
+	REGFIELD_SET(pcm_player->base, AUD_PCMOUT_IT_EN_SET, NSAMPLE, SET);
+	REGFIELD_SET(pcm_player->base, AUD_PCMOUT_IT_EN_SET, UNF, SET);
 
 	/* Wake up & unmute DAC */
 
-	if (pcm_player->conv_group) {
-		snd_stm_conv_enable(pcm_player->conv_group,
-				0, substream->runtime->channels - 1);
-		snd_stm_conv_unmute(pcm_player->conv_group);
+	if (pcm_player->conv) {
+		snd_stm_conv_enable(pcm_player->conv);
+		snd_stm_conv_unmute(pcm_player->conv);
 	}
 
 	return 0;
@@ -649,35 +685,35 @@
 	struct snd_stm_pcm_player *pcm_player =
 			snd_pcm_substream_chip(substream);
 
-	snd_stm_printd(1, "snd_stm_pcm_player_stop(substream=0x%p)\n",
+	snd_stm_printt("snd_stm_pcm_player_stop(substream=0x%p)\n",
 			substream);
 
-	snd_stm_assert(pcm_player, return -EINVAL);
+	snd_assert(pcm_player, return -EINVAL);
 	snd_stm_magic_assert(pcm_player, return -EINVAL);
 
 	/* Mute & shutdown DAC */
 
-	if (pcm_player->conv_group) {
-		snd_stm_conv_mute(pcm_player->conv_group);
-		snd_stm_conv_disable(pcm_player->conv_group);
+	if (pcm_player->conv) {
+		snd_stm_conv_mute(pcm_player->conv);
+		snd_stm_conv_disable(pcm_player->conv);
 	}
 
 	/* Disable interrupts */
 
-	set__AUD_PCMOUT_IT_EN_CLR__NSAMPLE__CLEAR(pcm_player);
-	set__AUD_PCMOUT_IT_EN_CLR__UNF__CLEAR(pcm_player);
-	disable_irq(pcm_player->irq);
+	REGFIELD_SET(pcm_player->base, AUD_PCMOUT_IT_EN_CLR, NSAMPLE, CLEAR);
+	REGFIELD_SET(pcm_player->base, AUD_PCMOUT_IT_EN_CLR, UNF, CLEAR);
 
 	/* Stop PCM player */
 
-	set__AUD_PCMOUT_CTRL__MODE__OFF(pcm_player);
+	REGFIELD_SET(pcm_player->base, AUD_PCMOUT_CTRL, MODE, OFF);
+	pcm_player->substream = NULL;
 
 	/* Stop FDMA transfer */
 
 	dma_stop_channel(pcm_player->fdma_channel);
 
 	/* Reset PCM player */
-	set__AUD_PCMOUT_RST__SRSTP__RESET(pcm_player);
+	REGFIELD_SET(pcm_player->base, AUD_PCMOUT_RST, SRSTP, RESET);
 
 	return 0;
 }
@@ -688,17 +724,17 @@
 	struct snd_stm_pcm_player *pcm_player =
 			snd_pcm_substream_chip(substream);
 
-	snd_stm_printd(1, "snd_stm_pcm_player_pause(substream=0x%p)\n",
+	snd_stm_printt("snd_stm_pcm_player_pause(substream=0x%p)\n",
 			substream);
 
-	snd_stm_assert(pcm_player, return -EINVAL);
+	snd_assert(pcm_player, return -EINVAL);
 	snd_stm_magic_assert(pcm_player, return -EINVAL);
 
 	/* "Mute" player
 	 * Documentation describes this mode in a wrong way - data is _not_
 	 * consumed in the "mute" mode, so it is actually a "pause" mode */
 
-	set__AUD_PCMOUT_CTRL__MODE__MUTE(pcm_player);
+	REGFIELD_SET(pcm_player->base, AUD_PCMOUT_CTRL, MODE, MUTE);
 
 	return 0;
 }
@@ -709,15 +745,15 @@
 	struct snd_stm_pcm_player *pcm_player =
 		snd_pcm_substream_chip(substream);
 
-	snd_stm_printd(1, "snd_stm_pcm_player_release(substream=0x%p)\n",
+	snd_stm_printt("snd_stm_pcm_player_release(substream=0x%p)\n",
 			substream);
 
-	snd_stm_assert(pcm_player, return -EINVAL);
+	snd_assert(pcm_player, return -EINVAL);
 	snd_stm_magic_assert(pcm_player, return -EINVAL);
 
 	/* "Unmute" player */
 
-	set__AUD_PCMOUT_CTRL__MODE__PCM(pcm_player);
+	REGFIELD_SET(pcm_player->base, AUD_PCMOUT_CTRL, MODE, PCM);
 
 	return 0;
 }
@@ -725,7 +761,7 @@
 static int snd_stm_pcm_player_trigger(struct snd_pcm_substream *substream,
 		int command)
 {
-	snd_stm_printd(1, "snd_stm_pcm_player_trigger(substream=0x%p,"
+	snd_stm_printt("snd_stm_pcm_player_trigger(substream=0x%p,"
 			" command=%d)\n", substream, command);
 
 	switch (command) {
@@ -751,19 +787,19 @@
 	int residue;
 	snd_pcm_uframes_t pointer;
 
-	snd_stm_printd(2, "snd_stm_pcm_player_pointer(substream=0x%p)\n",
+	snd_stm_printt("snd_stm_pcm_player_pointer(substream=0x%p)\n",
 			substream);
 
-	snd_stm_assert(pcm_player, return -EINVAL);
+	snd_assert(pcm_player, return -EINVAL);
 	snd_stm_magic_assert(pcm_player, return -EINVAL);
-	snd_stm_assert(runtime, return -EINVAL);
+	snd_assert(runtime, return -EINVAL);
 
 	residue = get_dma_residue(pcm_player->fdma_channel);
 	pointer = bytes_to_frames(runtime, runtime->dma_bytes - residue);
 
-	snd_stm_printd(2, "FDMA residue value is %i and buffer size is %u"
+	snd_stm_printt("FDMA residue value is %i and buffer size is %u"
 			" bytes...\n", residue, runtime->dma_bytes);
-	snd_stm_printd(2, "... so HW pointer in frames is %lu (0x%lx)!\n",
+	snd_stm_printt("... so HW pointer in frames is %lu (0x%lx)!\n",
 			pointer, pointer);
 
 	return pointer;
@@ -772,7 +808,7 @@
 static struct snd_pcm_ops snd_stm_pcm_player_pcm_ops = {
 	.open =      snd_stm_pcm_player_open,
 	.close =     snd_stm_pcm_player_close,
-	.mmap =      snd_stm_buffer_mmap,
+	.mmap =      snd_stm_mmap,
 	.ioctl =     snd_pcm_lib_ioctl,
 	.hw_params = snd_stm_pcm_player_hw_params,
 	.hw_free =   snd_stm_pcm_player_hw_free,
@@ -790,20 +826,18 @@
 #define DUMP_REGISTER(r) \
 		snd_iprintf(buffer, "AUD_PCMOUT_%s (offset 0x%02x) =" \
 				" 0x%08x\n", __stringify(r), \
-				offset__AUD_PCMOUT_##r(pcm_player), \
-				get__AUD_PCMOUT_##r(pcm_player))
+				AUD_PCMOUT_##r, \
+				REGISTER_PEEK(pcm_player->base, \
+				AUD_PCMOUT_##r))
 
 static void snd_stm_pcm_player_dump_registers(struct snd_info_entry *entry,
 		struct snd_info_buffer *buffer)
 {
 	struct snd_stm_pcm_player *pcm_player = entry->private_data;
 
-	snd_stm_assert(pcm_player, return);
+	snd_assert(pcm_player, return);
 	snd_stm_magic_assert(pcm_player, return);
 
-	snd_iprintf(buffer, "--- %s ---\n", pcm_player->device->bus_id);
-	snd_iprintf(buffer, "base = 0x%p\n", pcm_player->base);
-
 	DUMP_REGISTER(RST);
 	DUMP_REGISTER(DATA);
 	DUMP_REGISTER(ITS);
@@ -814,8 +848,6 @@
 	DUMP_REGISTER(CTRL);
 	DUMP_REGISTER(STA);
 	DUMP_REGISTER(FMT);
-
-	snd_iprintf(buffer, "\n");
 }
 
 static int snd_stm_pcm_player_register(struct snd_device *snd_device)
@@ -823,37 +855,23 @@
 	int result;
 	struct snd_stm_pcm_player *pcm_player = snd_device->device_data;
 
-	snd_stm_printd(1, "snd_stm_pcm_player_register(snd_device=0x%p)\n",
+	snd_stm_printt("snd_stm_pcm_player_register(snd_device=0x%p)\n",
 			snd_device);
 
-	snd_stm_assert(pcm_player, return -EINVAL);
+	snd_assert(pcm_player, return -EINVAL);
 	snd_stm_magic_assert(pcm_player, return -EINVAL);
 
-	snd_stm_printd(0, "--- Registering player '%s'...\n",
-			pcm_player->device->bus_id);
-
 	/* Set reset mode */
 
-	set__AUD_PCMOUT_RST__SRSTP__RESET(pcm_player);
+	REGFIELD_SET(pcm_player->base, AUD_PCMOUT_RST, SRSTP, RESET);
 
 	/* TODO: well, hardcoded - shall anyone use it?
 	 * And what it actually means? */
 
-	if (pcm_player->ver > ver__AUD_PCMOUT__65_1_3)
-		set__AUD_PCMOUT_FMT__BACK_STALLING__DISABLED(pcm_player);
-	set__AUD_PCMOUT_CTRL__RND__NO_ROUNDING(pcm_player);
-
-	/* Get frequency synthesizer channel */
-
-	snd_stm_assert(pcm_player->info->fsynth_bus_id != NULL, return -EINVAL);
-	snd_stm_printd(0, "Player connected to %s's output %d.\n",
-			pcm_player->info->fsynth_bus_id,
-			pcm_player->info->fsynth_output);
-
-	pcm_player->fsynth_channel = snd_stm_fsynth_get_channel(
-			pcm_player->info->fsynth_bus_id,
-			pcm_player->info->fsynth_output);
-	snd_stm_assert(pcm_player->fsynth_channel != NULL, return -EINVAL);
+#if defined(CONFIG_CPU_SUBTYPE_STX7111)
+	REGFIELD_SET(pcm_player->base, AUD_PCMOUT_FMT, BACK_STALLING, DISABLED);
+#endif
+	REGFIELD_SET(pcm_player->base, AUD_PCMOUT_CTRL, RND, NO_ROUNDING);
 
 	/* Registers view in ALSA's procfs */
 
@@ -863,28 +881,31 @@
 
 	/* Create ALSA controls */
 
-	result = snd_stm_fsynth_add_adjustement_ctl(pcm_player->fsynth_channel,
+	result = snd_stm_conv_add_route_ctl(pcm_player->device,
 			snd_device->card, pcm_player->info->card_device);
 	if (result < 0) {
-		snd_stm_printe("Failed to add fsynth adjustment control!\n");
+		snd_stm_printe("Failed to add converter route control!\n");
 		return result;
 	}
 
-	snd_stm_printd(0, "--- Registered successfully!\n");
+	result = snd_stm_fsynth_add_adjustement_ctl(pcm_player->fsynth_device,
+			pcm_player->fsynth_channel,
+			snd_device->card, pcm_player->info->card_device);
+	if (result < 0) {
+		snd_stm_printe("Failed to add fsynth adjustment control!\n");
+		return result;
+	}
 
 	return 0;
 }
 
-static int __exit snd_stm_pcm_player_disconnect(struct snd_device *snd_device)
+static int snd_stm_pcm_player_disconnect(struct snd_device *snd_device)
 {
 	struct snd_stm_pcm_player *pcm_player = snd_device->device_data;
 
-	snd_stm_printd(1, "snd_stm_pcm_player_disconnect(snd_device=0x%p)\n",
+	snd_stm_printt("snd_stm_pcm_player_unregister(snd_device=0x%p)\n",
 			snd_device);
 
-	snd_stm_assert(pcm_player, return -EINVAL);
-	snd_stm_magic_assert(pcm_player, return -EINVAL);
-
 	snd_stm_info_unregister(pcm_player->proc_entry);
 
 	return 0;
@@ -901,18 +922,14 @@
  * Platform driver routines
  */
 
-static int snd_stm_pcm_player_probe(struct platform_device *pdev)
+static int __init snd_stm_pcm_player_probe(struct platform_device *pdev)
 {
 	int result = 0;
 	struct snd_stm_pcm_player *pcm_player;
-	struct snd_card *card = snd_stm_card_get();
+	struct snd_card *card;
 	int i;
 
-	snd_stm_printd(1, "snd_stm_pcm_player_probe(pdev=%p)\n", pdev);
-
-	snd_stm_printd(0, "Probing device '%s'...\n", pdev->dev.bus_id);
-
-	snd_stm_assert(card != NULL, return -EINVAL);
+	snd_printd("--- Probing device '%s'...\n", pdev->dev.bus_id);
 
 	pcm_player = kzalloc(sizeof(*pcm_player), GFP_KERNEL);
 	if (!pcm_player) {
@@ -923,9 +940,7 @@
 	}
 	snd_stm_magic_set(pcm_player);
 	pcm_player->info = pdev->dev.platform_data;
-	snd_stm_assert(pcm_player->info != NULL, return -EINVAL);
-	pcm_player->ver = pcm_player->info->ver;
-	snd_stm_assert(pcm_player->ver > 0, return -EINVAL);
+	snd_assert(pcm_player->info != NULL, return -EINVAL);
 	pcm_player->device = &pdev->dev;
 
 	/* Get resources */
@@ -937,8 +952,8 @@
 		goto error_memory_request;
 	}
 	pcm_player->fifo_phys_address = pcm_player->mem_region->start +
-		offset__AUD_PCMOUT_DATA(pcm_player);
-	snd_stm_printd(0, "FIFO physical address: 0x%lx.\n",
+		AUD_PCMOUT_DATA;
+	snd_printd("FIFO physical address: 0x%lx.\n",
 			pcm_player->fifo_phys_address);
 
 	result = snd_stm_irq_request(pdev, &pcm_player->irq,
@@ -954,49 +969,38 @@
 		goto error_fdma_request;
 	}
 
-	/* FDMA transfer size depends (among others ;-) on FIFO length,
-	 * which is:
-	 * - 30 cells (120 bytes) in STx7100/9 and STx7200 cut 1.0
-	 * - 70 cells (280 bytes) in STx7111 and STx7200 cut 2.0. */
-
-	if (pcm_player->ver < ver__AUD_PCMOUT__65_1_3)
-		pcm_player->fdma_max_transfer_size = 2;
-	else if (pcm_player->ver == ver__AUD_PCMOUT__65_1_3)
-		pcm_player->fdma_max_transfer_size = 20;
-	else
-		pcm_player->fdma_max_transfer_size = 30;
-
 	/* Get player capabilities */
 
-	snd_stm_printd(0, "Player's name is '%s'\n", pcm_player->info->name);
+	snd_printd("Player's name is '%s'\n", pcm_player->info->name);
 
-	snd_stm_assert(pcm_player->info->channels > 0, return -EINVAL);
-	snd_stm_assert(pcm_player->info->channels <= 10, return -EINVAL);
-	snd_stm_assert(pcm_player->info->channels % 2 == 0, return -EINVAL);
-	if (pcm_player->ver > ver__AUD_PCMOUT__90_1_1) {
-		static unsigned int channels_2_10[] = { 2, 4, 6, 8, 10 };
-
-		pcm_player->channels_constraint.list = channels_2_10;
-		pcm_player->channels_constraint.count =
-			pcm_player->info->channels / 2;
-	} else {
-		/* In STx7100 cut < 3.0 PCM player ignored NUM_CH setting in
-		 * AUD_PCMOUT_FMT register (and it was always in 10 channels
-		 * mode...) */
-		static unsigned int channels_10[] = { 10 };
-
-		pcm_player->channels_constraint.list = channels_10;
-		pcm_player->channels_constraint.count = 1;
-	}
+	card = snd_stm_cards_get(pcm_player->info->card_id);
+	snd_assert(card != NULL, return -EINVAL);
+	snd_printd("Player will be a member of a card '%s' as a PCM device "
+			"no. %d.\n", card->id, pcm_player->info->card_device);
+
+	snd_assert(pcm_player->info->channels != NULL, return -EINVAL);
+	snd_assert(pcm_player->info->channels_num > 0, return -EINVAL);
+	pcm_player->channels_constraint.list = pcm_player->info->channels;
+	pcm_player->channels_constraint.count = pcm_player->info->channels_num;
 	pcm_player->channels_constraint.mask = 0;
-	for (i = 0; i < pcm_player->channels_constraint.count; i++)
-		snd_stm_printd(0, "Player capable of playing %u-channels PCM."
-				"\n", pcm_player->channels_constraint.list[i]);
-
-	/* STx7100 has a problem with 16/16 bits FIFO organization,
-	 * so we disable the 16 bits samples capability... */
-	if (pcm_player->ver <= ver__AUD_PCMOUT__90_1_3)
-		snd_stm_pcm_player_hw.formats &= ~SNDRV_PCM_FMTBIT_S16_LE;
+	for (i = 0; i < pcm_player->info->channels_num; i++)
+		snd_printd("Player capable of playing %u-channels PCM.\n",
+				pcm_player->info->channels[i]);
+
+	/* Get fsynth device */
+
+	snd_assert(pcm_player->info->fsynth_bus_id != NULL, return -EINVAL);
+	snd_printd("Player connected to %s's output %d.\n",
+			pcm_player->info->fsynth_bus_id,
+			pcm_player->info->fsynth_output);
+	pcm_player->fsynth_device = snd_stm_find_device(NULL,
+			pcm_player->info->fsynth_bus_id);
+	snd_assert(pcm_player->fsynth_device != NULL, return -EINVAL);
+	pcm_player->fsynth_channel = pcm_player->info->fsynth_output;
+
+	/* Preallocate buffer */
+
+	/* TODO */
 
 	/* Create ALSA lowlevel device */
 
@@ -1021,40 +1025,14 @@
 	snd_pcm_set_ops(pcm_player->pcm, SNDRV_PCM_STREAM_PLAYBACK,
 			&snd_stm_pcm_player_pcm_ops);
 
-	/* Initialize buffer */
-
-	pcm_player->buffer = snd_stm_buffer_create(pcm_player->pcm,
-			pcm_player->device,
-			snd_stm_pcm_player_hw.buffer_bytes_max);
-	if (!pcm_player->buffer) {
-		snd_stm_printe("Cannot initialize buffer!\n");
-		result = -ENOMEM;
-		goto error_buffer_init;
-	}
-
-	/* Register in converters router */
-
-	pcm_player->conv_source = snd_stm_conv_register_source(
-			&platform_bus_type, pdev->dev.bus_id,
-			pcm_player->info->channels,
-			card, pcm_player->info->card_device);
-	if (!pcm_player->conv_source) {
-		snd_stm_printe("Cannot register in converters router!\n");
-		result = -ENOMEM;
-		goto error_conv_register_source;
-	}
-
 	/* Done now */
 
 	platform_set_drvdata(pdev, pcm_player);
 
+	snd_printd("--- Probed successfully!\n");
+
 	return 0;
 
-error_conv_register_source:
-	snd_stm_buffer_dispose(pcm_player->buffer);
-error_buffer_init:
-	/* snd_pcm_free() is not available - PCM device will be released
-	 * during card release */
 error_pcm:
 	snd_device_free(card, pcm_player);
 error_device:
@@ -1074,13 +1052,9 @@
 {
 	struct snd_stm_pcm_player *pcm_player = platform_get_drvdata(pdev);
 
-	snd_stm_printd(1, "snd_stm_pcm_player_remove(pdev=%p)\n", pdev);
-
-	snd_stm_assert(pcm_player, return -EINVAL);
+	snd_assert(pcm_player, return -EINVAL);
 	snd_stm_magic_assert(pcm_player, return -EINVAL);
 
-	snd_stm_conv_unregister_source(pcm_player->conv_source);
-	snd_stm_buffer_dispose(pcm_player->buffer);
 	snd_stm_fdma_release(pcm_player->fdma_channel);
 	snd_stm_irq_release(pcm_player->irq, pcm_player);
 	snd_stm_memory_release(pcm_player->mem_region, pcm_player->base);
@@ -1093,7 +1067,7 @@
 
 static struct platform_driver snd_stm_pcm_player_driver = {
 	.driver = {
-		.name = "snd_pcm_player",
+		.name = "pcm_player",
 	},
 	.probe = snd_stm_pcm_player_probe,
 	.remove = snd_stm_pcm_player_remove,
@@ -1110,7 +1084,7 @@
 	return platform_driver_register(&snd_stm_pcm_player_driver);
 }
 
-void snd_stm_pcm_player_exit(void)
+void snd_stm_pcm_player_cleanup(void)
 {
 	platform_driver_unregister(&snd_stm_pcm_player_driver);
 }
diff -urN linux-sh4-2.6.23.17_stm23_0119-orig/sound//stm/pcm_reader.c linux-sh4/sound//stm/pcm_reader.c
--- linux-sh4-2.6.23.17_stm23_0119-orig/sound//stm/pcm_reader.c	2009-06-06 20:17:15.000000000 +0200
+++ linux-sh4/sound//stm/pcm_reader.c	2009-07-18 22:47:08.000000000 +0200
@@ -3,7 +3,7 @@
  *
  *   Copyright (c) 2005-2007 STMicroelectronics Limited
  *
- *   Author: Pawel Moll <pawel.moll@st.com>
+ *   Author: Pawel MOLL <pawel.moll@st.com>
  *
  *   This program is free software; you can redistribute it and/or modify
  *   it under the terms of the GNU General Public License as published by
@@ -25,9 +25,11 @@
 #include <linux/io.h>
 #include <linux/platform_device.h>
 #include <linux/interrupt.h>
-#include <linux/delay.h>
+#include <linux/bpa2.h>
 #include <asm/cacheflush.h>
+#include <linux/stm/soc.h>
 #include <linux/stm/stm-dma.h>
+#include <linux/stm/registers.h>
 #include <sound/driver.h>
 #include <sound/core.h>
 #include <sound/pcm.h>
@@ -35,9 +37,9 @@
 #include <sound/info.h>
 #include <sound/pcm_params.h>
 
-#define COMPONENT pcm_reader
+#undef TRACE /* See common.h debug features */
+#define MAGIC 7 /* See common.h debug features */
 #include "common.h"
-#include "reg_aud_pcmin.h"
 
 
 
@@ -46,7 +48,9 @@
  */
 
 #define DEFAULT_FORMAT (SND_STM_FORMAT__I2S | \
-		SND_STM_FORMAT__SUBFRAME_32_BITS)
+		SND_STM_FORMAT__OUTPUT_SUBFRAME_32_BITS)
+
+#define MAX_CHANNELS 10
 
 
 
@@ -59,7 +63,6 @@
 	struct snd_stm_pcm_reader_info *info;
 	struct device *device;
 	struct snd_pcm *pcm;
-	int ver; /* IP version, used by register access macros */
 
 	/* Resources */
 	struct resource *mem_region;
@@ -67,20 +70,17 @@
 	unsigned long fifo_phys_address;
 	unsigned int irq;
 	int fdma_channel;
+	struct stm_dma_req *fdma_request;
 
 	/* Environment settings */
+	struct snd_stm_conv *conv;
 	struct snd_pcm_hw_constraint_list channels_constraint;
-	struct snd_stm_conv_source *conv_source;
 
 	/* Runtime data */
-	struct snd_stm_conv_group *conv_group;
-	struct snd_stm_buffer *buffer;
+	void *buffer;
 	struct snd_info_entry *proc_entry;
 	struct snd_pcm_substream *substream;
-	int fdma_max_transfer_size;
 	struct stm_dma_params *fdma_params_list;
-	struct stm_dma_req *fdma_request;
-	int running;
 
 	snd_stm_magic_field;
 };
@@ -97,30 +97,36 @@
 	struct snd_stm_pcm_reader *pcm_reader = dev_id;
 	unsigned int status;
 
-	snd_stm_printd(2, "snd_stm_pcm_reader_irq_handler(irq=%d, "
-			"dev_id=0x%p)\n", irq, dev_id);
+	snd_stm_printt("snd_stm_pcm_reader_irq_handler(irq=%d, dev_id=0x%p)\n",
+			irq, dev_id);
 
-	snd_stm_assert(pcm_reader, return -EINVAL);
+	snd_assert(pcm_reader, return -EINVAL);
 	snd_stm_magic_assert(pcm_reader, return -EINVAL);
 
 	/* Get interrupt status & clear them immediately */
 	preempt_disable();
-	status = get__AUD_PCMIN_ITS(pcm_reader);
-	set__AUD_PCMIN_ITS_CLR(pcm_reader, status);
+	status = REGISTER_PEEK(pcm_reader->base, AUD_PCMIN_ITS);
+	REGISTER_POKE(pcm_reader->base, AUD_PCMIN_ITS_CLR, status);
 	preempt_enable();
 
 	/* Overflow? */
-	if (unlikely(status & mask__AUD_PCMIN_ITS__OVF__PENDING(pcm_reader))) {
+	if (unlikely(status & REGFIELD_VALUE(AUD_PCMIN_ITS, OVF, PENDING))) {
 		snd_stm_printe("Overflow detected in PCM reader '%s'!\n",
 				pcm_reader->device->bus_id);
-
+		result = IRQ_HANDLED;
 		snd_pcm_stop(pcm_reader->substream, SNDRV_PCM_STATE_XRUN);
+	}
 
+	/* Period successfully played */
+	if (likely(status & REGFIELD_VALUE(AUD_PCMIN_ITS, VSYNC, PENDING))) {
+		snd_stm_printt("Vsync interrupt detected by '%s'!\n",
+				pcm_reader->device->bus_id);
+		/* TODO: Calculate sampling frequency */
 		result = IRQ_HANDLED;
 	}
 
 	/* Some alien interrupt??? */
-	snd_stm_assert(result == IRQ_HANDLED);
+	snd_assert(result == IRQ_HANDLED);
 
 	return result;
 }
@@ -130,19 +136,19 @@
 	struct snd_stm_pcm_reader *pcm_reader =
 			(struct snd_stm_pcm_reader *)param;
 
-	snd_stm_printd(2, "snd_stm_pcm_reader_callback_node_done(param=0x%lx"
-			")\n", param);
+	snd_stm_printt("snd_stm_pcm_reader_callback_node_done(param=0x%lx)\n",
+			param);
 
-	snd_stm_assert(pcm_reader, return);
+	snd_assert(pcm_reader, return);
 	snd_stm_magic_assert(pcm_reader, return);
 
-	if (!pcm_reader->running)
-		return;
-
-	snd_stm_printd(2, "Period elapsed ('%s')\n",
-			pcm_reader->device->bus_id);
-
-	snd_pcm_period_elapsed(pcm_reader->substream);
+	/* This function will be called after stopping FDMA as well
+	 * and in this moment ALSA is already shut down... */
+	if (pcm_reader->substream) {
+		snd_stm_printt("Period elapsed ('%s')\n",
+				pcm_reader->device->bus_id);
+		snd_pcm_period_elapsed(pcm_reader->substream);
+	}
 }
 
 static void snd_stm_pcm_reader_callback_node_error(unsigned long param)
@@ -150,19 +156,14 @@
 	struct snd_stm_pcm_reader *pcm_reader =
 			(struct snd_stm_pcm_reader *)param;
 
-	snd_stm_printd(2, "snd_stm_pcm_reader_callback_node_error(param=0x%lx"
-			")\n", param);
+	snd_stm_printt("snd_stm_pcm_reader_callback_node_error(param=0x%lx)\n",
+			param);
 
-	snd_stm_assert(pcm_reader, return);
+	snd_assert(pcm_reader, return);
 	snd_stm_magic_assert(pcm_reader, return);
 
-	if (!pcm_reader->running)
-		return;
-
 	snd_stm_printe("Error during FDMA transfer in reader '%s'!\n",
 			pcm_reader->device->bus_id);
-
-	snd_pcm_stop(pcm_reader->substream, SNDRV_PCM_STATE_XRUN);
 }
 
 static struct snd_pcm_hardware snd_stm_pcm_reader_hw = {
@@ -170,11 +171,16 @@
 				SNDRV_PCM_INFO_MMAP_VALID |
 				SNDRV_PCM_INFO_INTERLEAVED |
 				SNDRV_PCM_INFO_BLOCK_TRANSFER),
+#if 0
+	.formats	= (SNDRV_PCM_FMTBIT_S32_LE |
+				SNDRV_PCM_FMTBIT_S16_LE),
+#else
 	.formats	= (SNDRV_PCM_FMTBIT_S32_LE),
+#endif
 
 	/* Keep in mind that we are working in slave mode, so sampling
 	 * rate is determined by external components... */
-	.rates		= SNDRV_PCM_RATE_CONTINUOUS,
+	.rates		= (SNDRV_PCM_RATE_CONTINUOUS),
 	.rate_min	= 32000,
 	.rate_max	= 192000,
 
@@ -201,25 +207,23 @@
 			snd_pcm_substream_chip(substream);
 	struct snd_pcm_runtime *runtime = substream->runtime;
 
-	snd_stm_printd(1, "snd_stm_pcm_reader_open(substream=0x%p)\n",
-			substream);
+	snd_stm_printt("snd_stm_pcm_reader_open(substream=0x%p)\n", substream);
 
-	snd_stm_assert(pcm_reader, return -EINVAL);
+	snd_assert(pcm_reader, return -EINVAL);
 	snd_stm_magic_assert(pcm_reader, return -EINVAL);
-	snd_stm_assert(runtime, return -EINVAL);
+	snd_assert(runtime, return -EINVAL);
 
 	snd_pcm_set_sync(substream);  /* TODO: ??? */
 
-	/* Get attached converters handle */
+	/* Get attached converter handle */
 
-	pcm_reader->conv_group =
-			snd_stm_conv_request_group(pcm_reader->conv_source);
-	if (pcm_reader->conv_group)
-		snd_stm_printd(1, "'%s' is attached to '%s' converter(s)...\n",
-				pcm_reader->device->bus_id,
-				snd_stm_conv_get_name(pcm_reader->conv_group));
+	pcm_reader->conv = snd_stm_conv_get_attached(pcm_reader->device);
+	if (pcm_reader->conv)
+		snd_printd("Converter '%s' attached to '%s'...\n",
+				pcm_reader->conv->name,
+				pcm_reader->device->bus_id);
 	else
-		snd_stm_printd(1, "Warning! No converter attached to '%s'!\n",
+		snd_printd("Warning! No converter attached to '%s'!\n",
 				pcm_reader->device->bus_id);
 
 	/* Set up constraints & pass hardware capabilities info to ALSA */
@@ -245,7 +249,7 @@
 	 * of a FDMA transfer bytes (which varies depending on channels
 	 * number and sample bytes) */
 	result = snd_stm_pcm_hw_constraint_transfer_bytes(runtime,
-			pcm_reader->fdma_max_transfer_size * 4);
+			pcm_reader->info->fdma_max_transfer_size * 4);
 	if (result < 0) {
 		snd_stm_printe("Can't set buffer bytes constraint!\n");
 		return result;
@@ -253,9 +257,6 @@
 
 	runtime->hw = snd_stm_pcm_reader_hw;
 
-	/* Interrupt handlers will need the substream pointer... */
-	pcm_reader->substream = substream;
-
 	return 0;
 }
 
@@ -264,19 +265,12 @@
 	struct snd_stm_pcm_reader *pcm_reader =
 			snd_pcm_substream_chip(substream);
 
-	snd_stm_printd(1, "snd_stm_pcm_reader_close(substream=0x%p)\n",
+	snd_stm_printt("snd_stm_pcm_reader_close(substream=0x%p)\n",
 			substream);
 
-	snd_stm_assert(pcm_reader, return -EINVAL);
+	snd_assert(pcm_reader, return -EINVAL);
 	snd_stm_magic_assert(pcm_reader, return -EINVAL);
 
-	if (pcm_reader->conv_group) {
-		snd_stm_conv_release_group(pcm_reader->conv_group);
-		pcm_reader->conv_group = NULL;
-	}
-
-	pcm_reader->substream = NULL;
-
 	return 0;
 }
 
@@ -286,23 +280,35 @@
 			snd_pcm_substream_chip(substream);
 	struct snd_pcm_runtime *runtime = substream->runtime;
 
-	snd_stm_printd(1, "snd_stm_pcm_reader_hw_free(substream=0x%p)\n",
+	snd_stm_printt("snd_stm_pcm_reader_hw_free(substream=0x%p)\n",
 			substream);
 
-	snd_stm_assert(pcm_reader, return -EINVAL);
+	snd_assert(pcm_reader, return -EINVAL);
 	snd_stm_magic_assert(pcm_reader, return -EINVAL);
-	snd_stm_assert(runtime, return -EINVAL);
+	snd_assert(runtime, return -EINVAL);
 
 	/* This callback may be called more than once... */
 
-	if (snd_stm_buffer_is_allocated(pcm_reader->buffer)) {
-		/* Let the FDMA stop */
-		dma_wait_for_completion(pcm_reader->fdma_channel);
+	if (pcm_reader->buffer) {
+		/* Dispose buffer */
 
-		/* Free buffer */
-		snd_stm_buffer_free(pcm_reader->buffer);
+		snd_stm_printt("Freeing buffer for %s: buffer=0x%p, "
+				"dma_addr=0x%08x, dma_area=0x%p, "
+				"dma_bytes=%u\n", pcm_reader->device->bus_id,
+				pcm_reader->buffer, runtime->dma_addr,
+				runtime->dma_area, runtime->dma_bytes);
+
+		iounmap(runtime->dma_area);
+
+		/* TODO: symmetrical to the above (BPA2 etc.) */
+		bigphysarea_free(pcm_reader->buffer, runtime->dma_bytes);
+
+		pcm_reader->buffer = NULL;
+		runtime->dma_area = NULL;
+		runtime->dma_addr = 0;
+		runtime->dma_bytes = 0;
 
-		/* Free FDMA parameters (whole list) */
+		/* Dispose FDMA parameters (whole list) */
 		dma_params_free(pcm_reader->fdma_params_list);
 		dma_req_free(pcm_reader->fdma_channel,
 				pcm_reader->fdma_request);
@@ -330,15 +336,15 @@
 	};
 	int i;
 
-	snd_stm_printd(1, "snd_stm_pcm_reader_hw_params(substream=0x%p,"
+	snd_stm_printt("snd_stm_pcm_reader_hw_params(substream=0x%p,"
 			" hw_params=0x%p)\n", substream, hw_params);
 
-	snd_stm_assert(pcm_reader, return -EINVAL);
+	snd_assert(pcm_reader, return -EINVAL);
 	snd_stm_magic_assert(pcm_reader, return -EINVAL);
-	snd_stm_assert(runtime, return -EINVAL);
+	snd_assert(runtime, return -EINVAL);
 
 	/* This function may be called many times, so let's be prepared... */
-	if (snd_stm_buffer_is_allocated(pcm_reader->buffer))
+	if (pcm_reader->buffer)
 		snd_stm_pcm_reader_hw_free(substream);
 
 	/* Get the numbers... */
@@ -346,55 +352,44 @@
 	buffer_bytes = params_buffer_bytes(hw_params);
 	periods = params_periods(hw_params);
 	period_bytes = buffer_bytes / periods;
-	snd_stm_assert(periods * period_bytes == buffer_bytes, return -EINVAL);
+	snd_assert(periods * period_bytes == buffer_bytes, return -EINVAL);
 
 	/* Allocate buffer */
 
-	result = snd_stm_buffer_alloc(pcm_reader->buffer, substream,
-			buffer_bytes);
-	if (result != 0) {
+	pcm_reader->buffer = bigphysarea_alloc(buffer_bytes);
+	/* TODO: move to BPA2, use pcm lib as fallback... */
+	if (!pcm_reader->buffer) {
 		snd_stm_printe("Can't allocate %d bytes buffer for '%s'!\n",
 				buffer_bytes, pcm_reader->device->bus_id);
 		result = -ENOMEM;
 		goto error_buf_alloc;
 	}
 
+	runtime->dma_addr = virt_to_phys(pcm_reader->buffer);
+	runtime->dma_area = ioremap_nocache(runtime->dma_addr, buffer_bytes);
+	runtime->dma_bytes = buffer_bytes;
+
+	snd_stm_printt("Allocated buffer for %s: buffer=0x%p, "
+			"dma_addr=0x%08x, dma_area=0x%p, "
+			"dma_bytes=%u\n", pcm_reader->device->bus_id,
+			pcm_reader->buffer, runtime->dma_addr,
+			runtime->dma_area, runtime->dma_bytes);
+
 	/* Set FDMA transfer size (number of opcodes generated
 	 * after request line assertion) */
 
 	frame_bytes = snd_pcm_format_physical_width(params_format(hw_params)) *
 			params_channels(hw_params) / 8;
 	transfer_bytes = snd_stm_pcm_transfer_bytes(frame_bytes,
-			pcm_reader->fdma_max_transfer_size * 4);
+			pcm_reader->info->fdma_max_transfer_size * 4);
 	transfer_size = transfer_bytes / 4;
 
-	snd_stm_printd(1, "FDMA request trigger limit set to %d.\n",
+	snd_stm_printt("FDMA request trigger limit set to %d.\n",
 			transfer_size);
-	snd_stm_assert(buffer_bytes % transfer_bytes == 0, return -EINVAL);
-	snd_stm_assert(transfer_size <= pcm_reader->fdma_max_transfer_size,
+	snd_assert(buffer_bytes % transfer_bytes == 0, return -EINVAL);
+	snd_assert(transfer_size <= pcm_reader->info->fdma_max_transfer_size,
 			return -EINVAL);
-	if (pcm_reader->ver > ver__AUD_PCMIN__65_2_0) {
-		snd_stm_assert(transfer_size == 1 || transfer_size % 2 == 0,
-				return -EINVAL);
-		snd_stm_assert(transfer_size <=
-				mask__AUD_PCMIN_FMT__DMA_REQ_TRIG_LMT(
-				pcm_reader), return -EINVAL);
-		set__AUD_PCMIN_FMT__DMA_REQ_TRIG_LMT(pcm_reader, transfer_size);
-		set__AUD_PCMIN_FMT__BACK_STALLING__DISABLED(pcm_reader);
-
-		/* This is a workaround for a problem in early releases
-		 * of multi-channel PCM Readers with FIFO underrunning (!!!),
-		 * caused by spurious request line generation... */
-		if (pcm_reader->ver < ver__AUD_PCMIN__65_3_4 &&
-				transfer_size > 2)
-			fdma_req_config.count = transfer_size / 2;
-		else
-			fdma_req_config.count = transfer_size;
-	} else {
-		fdma_req_config.count = transfer_size;
-	}
-	snd_stm_printd(1, "FDMA transfer size set to %d.\n",
-			fdma_req_config.count);
+	fdma_req_config.count = transfer_size;
 
 	/* Configure FDMA transfer */
 
@@ -411,6 +406,7 @@
 			kmalloc(sizeof(*pcm_reader->fdma_params_list) *
 			periods, GFP_KERNEL);
 	if (!pcm_reader->fdma_params_list) {
+		/* TODO: move to BPA2 (see above) */
 		snd_stm_printe("Can't allocate %d bytes for FDMA parameters "
 				"list!\n", sizeof(*pcm_reader->fdma_params_list)
 				* periods);
@@ -418,7 +414,7 @@
 		goto error_params_alloc;
 	}
 
-	snd_stm_printd(1, "Configuring FDMA transfer nodes:\n");
+	snd_stm_printt("Configuring FDMA transfer nodes:\n");
 
 	for (i = 0; i < periods; i++) {
 		dma_params_init(&pcm_reader->fdma_params_list[i], MODE_PACED,
@@ -447,8 +443,7 @@
 		dma_params_req(&pcm_reader->fdma_params_list[i],
 				pcm_reader->fdma_request);
 
-		snd_stm_printd(1, "- %d: %d bytes from 0x%08x\n", i,
-				period_bytes,
+		snd_stm_printt("- %d: %d bytes from 0x%08x\n", i, period_bytes,
 				runtime->dma_addr + i * period_bytes);
 
 		dma_params_addrs(&pcm_reader->fdma_params_list[i],
@@ -468,12 +463,18 @@
 	return 0;
 
 error_compile_list:
-	kfree(pcm_reader->fdma_params_list);
-error_params_alloc:
 	dma_req_free(pcm_reader->fdma_channel,
 			pcm_reader->fdma_request);
 error_req_config:
-	snd_stm_buffer_free(pcm_reader->buffer);
+	iounmap(runtime->dma_area);
+	/* TODO: symmetrical to the above (BPA2 etc.) */
+	bigphysarea_free(pcm_reader->buffer, runtime->dma_bytes);
+	pcm_reader->buffer = NULL;
+	runtime->dma_area = NULL;
+	runtime->dma_addr = 0;
+	runtime->dma_bytes = 0;
+error_params_alloc:
+	kfree(pcm_reader->fdma_params_list);
 error_buf_alloc:
 	return result;
 }
@@ -485,33 +486,35 @@
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	unsigned int format, lr_pol;
 
-	snd_stm_printd(1, "snd_stm_pcm_reader_prepare(substream=0x%p)\n",
+	snd_stm_printt("snd_stm_pcm_reader_prepare(substream=0x%p)\n",
 			substream);
 
-	snd_stm_assert(pcm_reader, return -EINVAL);
+	snd_assert(pcm_reader, return -EINVAL);
 	snd_stm_magic_assert(pcm_reader, return -EINVAL);
-	snd_stm_assert(runtime, return -EINVAL);
+	snd_assert(runtime, return -EINVAL);
 
 	/* Get format value from connected converter */
 
-	if (pcm_reader->conv_group)
-		format = snd_stm_conv_get_format(pcm_reader->conv_group);
+	if (pcm_reader->conv)
+		format = snd_stm_conv_get_format(pcm_reader->conv);
 	else
 		format = DEFAULT_FORMAT;
 
 	/* Number of bits per subframe (which is one channel sample)
 	 * on input. */
 
-	switch (format & SND_STM_FORMAT__SUBFRAME_MASK) {
-	case SND_STM_FORMAT__SUBFRAME_32_BITS:
-		snd_stm_printd(1, "- 32 bits per subframe\n");
-		set__AUD_PCMIN_FMT__NBIT__32_BITS(pcm_reader);
-		set__AUD_PCMIN_FMT__DATA_SIZE__24_BITS(pcm_reader);
+	switch (format & SND_STM_FORMAT__OUTPUT_SUBFRAME_MASK) {
+	case SND_STM_FORMAT__OUTPUT_SUBFRAME_32_BITS:
+		snd_stm_printt("- 32 bits per subframe\n");
+		REGFIELD_SET(pcm_reader->base, AUD_PCMIN_FMT, NBIT, 32_BITS);
+		REGFIELD_SET(pcm_reader->base, AUD_PCMIN_FMT,
+				DATA_SIZE, 24_BITS);
 		break;
-	case SND_STM_FORMAT__SUBFRAME_16_BITS:
-		snd_stm_printd(1, "- 16 bits per subframe\n");
-		set__AUD_PCMIN_FMT__NBIT__16_BITS(pcm_reader);
-		set__AUD_PCMIN_FMT__DATA_SIZE__16_BITS(pcm_reader);
+	case SND_STM_FORMAT__OUTPUT_SUBFRAME_16_BITS:
+		snd_stm_printt("- 16 bits per subframe\n");
+		REGFIELD_SET(pcm_reader->base, AUD_PCMIN_FMT, NBIT, 16_BITS);
+		REGFIELD_SET(pcm_reader->base, AUD_PCMIN_FMT,
+				DATA_SIZE, 16_BITS);
 		break;
 	default:
 		snd_BUG();
@@ -522,26 +525,32 @@
 	 * for detailed explanation see ie.
 	 * http://www.cirrus.com/en/pubs/appNote/AN282REV1.pdf */
 
-	set__AUD_PCMIN_FMT__ORDER__MSB_FIRST(pcm_reader);
-	set__AUD_PCMIN_FMT__SCLK_EDGE__RISING(pcm_reader);
+	REGFIELD_SET(pcm_reader->base, AUD_PCMIN_FMT,
+			ORDER, MSB_FIRST);
+	REGFIELD_SET(pcm_reader->base, AUD_PCMIN_FMT,
+			SCLK_EDGE, RISING);
 	switch (format & SND_STM_FORMAT__MASK) {
 	case SND_STM_FORMAT__I2S:
-		snd_stm_printd(1, "- I2S\n");
-		set__AUD_PCMIN_FMT__ALIGN__LEFT(pcm_reader);
-		set__AUD_PCMIN_FMT__PADDING__1_CYCLE_DELAY(pcm_reader);
-		lr_pol = value__AUD_PCMIN_FMT__LR_POL__LEFT_LOW(pcm_reader);
+		snd_stm_printt("- I2S\n");
+		REGFIELD_SET(pcm_reader->base, AUD_PCMIN_FMT, ALIGN, LEFT);
+		REGFIELD_SET(pcm_reader->base, AUD_PCMIN_FMT,
+				PADDING, 1_CYCLE_DELAY);
+		lr_pol = AUD_PCMOUT_FMT__LR_POL__VALUE__LEFT_LOW;
 		break;
 	case SND_STM_FORMAT__LEFT_JUSTIFIED:
-		snd_stm_printd(1, "- left justified\n");
-		set__AUD_PCMIN_FMT__ALIGN__LEFT(pcm_reader);
-		set__AUD_PCMIN_FMT__PADDING__NO_DELAY(pcm_reader);
-		lr_pol = value__AUD_PCMIN_FMT__LR_POL__LEFT_HIGH(pcm_reader);
+		snd_stm_printt("- left justified\n");
+		REGFIELD_SET(pcm_reader->base, AUD_PCMIN_FMT, ALIGN, LEFT);
+		REGFIELD_SET(pcm_reader->base, AUD_PCMIN_FMT,
+				PADDING, NO_DELAY);
+		lr_pol = AUD_PCMOUT_FMT__LR_POL__VALUE__LEFT_HIGH;
 		break;
 	case SND_STM_FORMAT__RIGHT_JUSTIFIED:
-		snd_stm_printd(1, "- right justified\n");
-		set__AUD_PCMIN_FMT__ALIGN__RIGHT(pcm_reader);
-		set__AUD_PCMIN_FMT__PADDING__NO_DELAY(pcm_reader);
-		lr_pol = value__AUD_PCMIN_FMT__LR_POL__LEFT_HIGH(pcm_reader);
+		snd_stm_printt("- right justified\n");
+		REGFIELD_SET(pcm_reader->base, AUD_PCMIN_FMT,
+				ALIGN, RIGHT);
+		REGFIELD_SET(pcm_reader->base, AUD_PCMIN_FMT,
+				PADDING, NO_DELAY);
+		lr_pol = AUD_PCMOUT_FMT__LR_POL__VALUE__LEFT_HIGH;
 		break;
 	default:
 		snd_BUG();
@@ -551,14 +560,31 @@
 	/* Configure data memory format */
 
 	switch (runtime->format) {
+	case SNDRV_PCM_FORMAT_S16_LE:
+		REGFIELD_SET(pcm_reader->base, AUD_PCMIN_CTRL,
+				MEM_FMT, 16_BITS_16_BITS);
+
+		/* Workaround for a problem with L/R channels swap in case of
+		 * 16/16 memory model: PCM puts left channel data in
+		 * word's upper two bytes, but due to little endianess
+		 * character of our memory it will be interpreted as right
+		 * channel data...  The workaround is to invert L/R signal,
+		 * however it is cheating, because in such case channel
+		 * phases are shifted by one sample...
+		 * (ask me for more details if above is not clear ;-)
+		 * TODO this somehow better... */
+		REGFIELD_POKE(pcm_reader->base, AUD_PCMIN_FMT, LR_POL, !lr_pol);
+		break;
+
 	case SNDRV_PCM_FORMAT_S32_LE:
 		/* Actually "16 bits/0 bits" means "24/20/18/16 bits on the
 		 * left than zeros"... ;-) */
-		set__AUD_PCMIN_CTRL__MEM_FMT__16_BITS_0_BITS(pcm_reader);
+		REGFIELD_SET(pcm_reader->base, AUD_PCMIN_CTRL,
+				MEM_FMT, 16_BITS_0_BITS);
 
 		/* In x/0 bits memory mode there is no problem with
 		 * L/R polarity */
-		set__AUD_PCMIN_FMT__LR_POL(pcm_reader, lr_pol);
+		REGFIELD_POKE(pcm_reader->base, AUD_PCMIN_FMT, LR_POL, lr_pol);
 		break;
 
 	default:
@@ -568,12 +594,15 @@
 
 	/* Number of channels... */
 
-	snd_stm_assert(runtime->channels % 2 == 0, return -EINVAL);
-	snd_stm_assert(runtime->channels >= 2 && runtime->channels <= 10,
+	snd_assert(runtime->channels % 2 == 0, return -EINVAL);
+	snd_assert(runtime->channels >= 2 && runtime->channels <= MAX_CHANNELS,
 			return -EINVAL);
 
-	if (pcm_reader->ver > ver__AUD_PCMIN__65_2_0)
-		set__AUD_PCMIN_FMT__NUM_CH(pcm_reader, runtime->channels / 2);
+	/* Will be here in 7200 cut 2.0... */
+#if 0
+	REGFIELD_POKE(pcm_reader->base, AUD_PCMIN_FMT, NUM_CH,
+			runtime->channels / 2);
+#endif
 
 	return 0;
 }
@@ -584,15 +613,15 @@
 	struct snd_stm_pcm_reader *pcm_reader =
 			snd_pcm_substream_chip(substream);
 
-	snd_stm_printd(1, "snd_stm_pcm_reader_start(substream=0x%p)\n",
+	snd_stm_printt("snd_stm_pcm_reader_start(substream=0x%p)\n",
 			substream);
 
-	snd_stm_assert(pcm_reader, return -EINVAL);
+	snd_assert(pcm_reader, return -EINVAL);
 	snd_stm_magic_assert(pcm_reader, return -EINVAL);
 
 	/* Un-reset PCM reader */
 
-	set__AUD_PCMIN_RST__RSTP__RUNNING(pcm_reader);
+	REGFIELD_SET(pcm_reader->base, AUD_PCMIN_RST, RSTP, RUNNING);
 
 	/* Launch FDMA transfer */
 
@@ -603,30 +632,24 @@
 				pcm_reader->device->bus_id);
 		return -EINVAL;
 	}
-	while (dma_get_status(pcm_reader->fdma_channel) !=
-			DMA_CHANNEL_STATUS_RUNNING)
-		udelay(5);
 
-	/* Enable required reader interrupt (and clear possible stalled) */
+	/* Launch PCM reader */
 
-	enable_irq(pcm_reader->irq);
-	set__AUD_PCMIN_ITS_CLR__OVF__CLEAR(pcm_reader);
-	set__AUD_PCMIN_IT_EN_SET__OVF__SET(pcm_reader);
+	pcm_reader->substream = substream;
+	REGFIELD_SET(pcm_reader->base, AUD_PCMIN_CTRL, MODE, PCM);
 
-	/* Launch the reader */
+	/* Enable reader interrupts */
 
-	set__AUD_PCMIN_CTRL__MODE__PCM(pcm_reader);
+	REGFIELD_SET(pcm_reader->base, AUD_PCMIN_IT_EN_SET, VSYNC, SET);
+	REGFIELD_SET(pcm_reader->base, AUD_PCMIN_IT_EN_SET, OVF, SET);
 
 	/* Wake up & unmute ADC */
 
-	if (pcm_reader->conv_group) {
-		snd_stm_conv_enable(pcm_reader->conv_group,
-				0, substream->runtime->channels - 1);
-		snd_stm_conv_unmute(pcm_reader->conv_group);
+	if (pcm_reader->conv) {
+		snd_stm_conv_enable(pcm_reader->conv);
+		snd_stm_conv_unmute(pcm_reader->conv);
 	}
 
-	pcm_reader->running = 1;
-
 	return 0;
 }
 
@@ -635,29 +658,28 @@
 	struct snd_stm_pcm_reader *pcm_reader =
 			snd_pcm_substream_chip(substream);
 
-	snd_stm_printd(1, "snd_stm_pcm_reader_stop(substream=0x%p)\n",
+	snd_stm_printt("snd_stm_pcm_reader_stop(substream=0x%p)\n",
 			substream);
 
-	snd_stm_assert(pcm_reader, return -EINVAL);
+	snd_assert(pcm_reader, return -EINVAL);
 	snd_stm_magic_assert(pcm_reader, return -EINVAL);
 
-	pcm_reader->running = 0;
-
 	/* Mute & shutdown DAC */
 
-	if (pcm_reader->conv_group) {
-		snd_stm_conv_mute(pcm_reader->conv_group);
-		snd_stm_conv_disable(pcm_reader->conv_group);
+	if (pcm_reader->conv) {
+		snd_stm_conv_mute(pcm_reader->conv);
+		snd_stm_conv_disable(pcm_reader->conv);
 	}
 
 	/* Disable interrupts */
 
-	set__AUD_PCMIN_IT_EN_CLR__OVF__CLEAR(pcm_reader);
-	disable_irq(pcm_reader->irq);
+	REGFIELD_SET(pcm_reader->base, AUD_PCMIN_IT_EN_CLR, VSYNC, CLEAR);
+	REGFIELD_SET(pcm_reader->base, AUD_PCMIN_IT_EN_CLR, OVF, CLEAR);
 
 	/* Stop PCM reader */
 
-	set__AUD_PCMIN_CTRL__MODE__OFF(pcm_reader);
+	REGFIELD_SET(pcm_reader->base, AUD_PCMIN_CTRL, MODE, OFF);
+	pcm_reader->substream = NULL;
 
 	/* Stop FDMA transfer */
 
@@ -665,7 +687,7 @@
 
 	/* Reset PCM reader */
 
-	set__AUD_PCMIN_RST__RSTP__RESET(pcm_reader);
+	REGFIELD_SET(pcm_reader->base, AUD_PCMIN_RST, RSTP, RESET);
 
 	return 0;
 }
@@ -673,7 +695,7 @@
 static int snd_stm_pcm_reader_trigger(struct snd_pcm_substream *substream,
 		int command)
 {
-	snd_stm_printd(1, "snd_stm_pcm_reader_trigger(substream=0x%p,"
+	snd_stm_printt("snd_stm_pcm_reader_trigger(substream=0x%p,"
 		       "command=%d)\n", substream, command);
 
 	switch (command) {
@@ -695,19 +717,19 @@
 	int residue;
 	snd_pcm_uframes_t pointer;
 
-	snd_stm_printd(2, "snd_stm_pcm_reader_pointer(substream=0x%p)\n",
+	snd_stm_printt("snd_stm_pcm_reader_pointer(substream=0x%p)\n",
 			substream);
 
-	snd_stm_assert(pcm_reader, return -EINVAL);
+	snd_assert(pcm_reader, return -EINVAL);
 	snd_stm_magic_assert(pcm_reader, return -EINVAL);
-	snd_stm_assert(runtime, return -EINVAL);
+	snd_assert(runtime, return -EINVAL);
 
 	residue = get_dma_residue(pcm_reader->fdma_channel);
 	pointer = bytes_to_frames(runtime, runtime->dma_bytes - residue);
 
-	snd_stm_printd(2, "FDMA residue value is %i and buffer size is %u"
+	snd_stm_printt("FDMA residue value is %i and buffer size is %u"
 			" bytes...\n", residue, runtime->dma_bytes);
-	snd_stm_printd(2, "... so HW pointer in frames is %lu (0x%lx)!\n",
+	snd_stm_printt("... so HW pointer in frames is %lu (0x%lx)!\n",
 			pointer, pointer);
 
 	return pointer;
@@ -716,7 +738,7 @@
 static struct snd_pcm_ops snd_stm_pcm_reader_pcm_ops = {
 	.open =      snd_stm_pcm_reader_open,
 	.close =     snd_stm_pcm_reader_close,
-	.mmap =      snd_stm_buffer_mmap,
+	.mmap =      snd_stm_mmap,
 	.ioctl =     snd_pcm_lib_ioctl,
 	.hw_params = snd_stm_pcm_reader_hw_params,
 	.hw_free =   snd_stm_pcm_reader_hw_free,
@@ -733,21 +755,17 @@
 
 #define DUMP_REGISTER(r) \
 		snd_iprintf(buffer, "AUD_PCMIN_%s (offset 0x%02x) = 0x%08x\n", \
-				__stringify(r), \
-				offset__AUD_PCMIN_##r(pcm_reader), \
-				get__AUD_PCMIN_##r(pcm_reader))
+				__stringify(r), AUD_PCMIN_##r, \
+				REGISTER_PEEK(pcm_reader->base, AUD_PCMIN_##r))
 
 static void snd_stm_pcm_reader_dump_registers(struct snd_info_entry *entry,
 		struct snd_info_buffer *buffer)
 {
 	struct snd_stm_pcm_reader *pcm_reader = entry->private_data;
 
-	snd_stm_assert(pcm_reader, return);
+	snd_assert(pcm_reader, return);
 	snd_stm_magic_assert(pcm_reader, return);
 
-	snd_iprintf(buffer, "--- %s ---\n", pcm_reader->device->bus_id);
-	snd_iprintf(buffer, "base = 0x%p\n", pcm_reader->base);
-
 	DUMP_REGISTER(RST);
 	DUMP_REGISTER(DATA);
 	DUMP_REGISTER(ITS);
@@ -758,31 +776,26 @@
 	DUMP_REGISTER(CTRL);
 	DUMP_REGISTER(STA);
 	DUMP_REGISTER(FMT);
-
-	snd_iprintf(buffer, "\n");
 }
 
 static int snd_stm_pcm_reader_register(struct snd_device *snd_device)
 {
+	int result;
 	struct snd_stm_pcm_reader *pcm_reader = snd_device->device_data;
 
-	snd_stm_printd(1, "snd_stm_pcm_reader_register(snd_device=0x%p)\n",
+	snd_stm_printt("snd_stm_pcm_reader_register(snd_device=0x%p)\n",
 			snd_device);
 
-	snd_stm_assert(pcm_reader, return -EINVAL);
+	snd_assert(pcm_reader, return -EINVAL);
 	snd_stm_magic_assert(pcm_reader, return -EINVAL);
 
-	snd_stm_printd(0, "--- Registering reader '%s'...\n",
-			pcm_reader->device->bus_id);
-
 	/* Set reset mode */
 
-	set__AUD_PCMIN_RST__RSTP__RESET(pcm_reader);
+	REGFIELD_SET(pcm_reader->base, AUD_PCMIN_RST, RSTP, RESET);
 
 	/* TODO: well, hardcoded - shall anyone use it?
 	 * And what it actually means? */
-
-	set__AUD_PCMIN_CTRL__RND__NO_ROUNDING(pcm_reader);
+	REGFIELD_SET(pcm_reader->base, AUD_PCMIN_CTRL, RND, NO_ROUNDING);
 
 	/* Registers view in ALSA's procfs */
 
@@ -790,7 +803,14 @@
 			pcm_reader->device->bus_id,
 			snd_stm_pcm_reader_dump_registers, pcm_reader);
 
-	snd_stm_printd(0, "--- Registered successfully!\n");
+	/* Create ALSA controls */
+
+	result = snd_stm_conv_add_route_ctl(pcm_reader->device,
+			snd_device->card, pcm_reader->info->card_device);
+	if (result < 0) {
+		snd_stm_printe("Failed to add converter route control!\n");
+		return result;
+	}
 
 	return 0;
 }
@@ -799,12 +819,9 @@
 {
 	struct snd_stm_pcm_reader *pcm_reader = snd_device->device_data;
 
-	snd_stm_printd(1, "snd_stm_pcm_reader_disconnect(snd_device=0x%p)\n",
+	snd_stm_printt("snd_stm_pcm_reader_unregister(snd_device=0x%p)\n",
 			snd_device);
 
-	snd_stm_assert(pcm_reader, return -EINVAL);
-	snd_stm_magic_assert(pcm_reader, return -EINVAL);
-
 	snd_stm_info_unregister(pcm_reader->proc_entry);
 
 	return 0;
@@ -821,18 +838,14 @@
  * Platform driver routines
  */
 
-static int snd_stm_pcm_reader_probe(struct platform_device *pdev)
+static int __init snd_stm_pcm_reader_probe(struct platform_device *pdev)
 {
 	int result = 0;
 	struct snd_stm_pcm_reader *pcm_reader;
-	struct snd_card *card = snd_stm_card_get();
+	struct snd_card *card;
 	int i;
 
-	snd_stm_printd(1, "snd_stm_pcm_reader_probe(pdev=%p)\n", pdev);
-
-	snd_stm_printd(0, "Probing device '%s'...\n", pdev->dev.bus_id);
-
-	snd_stm_assert(card != NULL, return -EINVAL);
+	snd_printd("--- Probing device '%s'...\n", pdev->dev.bus_id);
 
 	pcm_reader = kzalloc(sizeof(*pcm_reader), GFP_KERNEL);
 	if (!pcm_reader) {
@@ -843,9 +856,7 @@
 	}
 	snd_stm_magic_set(pcm_reader);
 	pcm_reader->info = pdev->dev.platform_data;
-	snd_stm_assert(pcm_reader->info != NULL, return -EINVAL);
-	pcm_reader->ver = pcm_reader->info->ver;
-	snd_stm_assert(pcm_reader->ver > 0, return -EINVAL);
+	snd_assert(pcm_reader->info != NULL, return -EINVAL);
 	pcm_reader->device = &pdev->dev;
 
 	/* Get resources */
@@ -857,8 +868,8 @@
 		goto error_memory_request;
 	}
 	pcm_reader->fifo_phys_address = pcm_reader->mem_region->start +
-			offset__AUD_PCMIN_DATA(pcm_reader);
-	snd_stm_printd(0, "FIFO physical address: 0x%lx.\n",
+		AUD_PCMIN_DATA;
+	snd_printd("FIFO physical address: 0x%lx.\n",
 			pcm_reader->fifo_phys_address);
 
 	result = snd_stm_irq_request(pdev, &pcm_reader->irq,
@@ -874,44 +885,27 @@
 		goto error_fdma_request;
 	}
 
-	/* FDMA transfer size depends (among others ;-) on FIFO length,
-	 * which is:
-	 * - 2 cells (8 bytes) in STx7100/9 and STx7200 cut 1.0
-	 * - 70 cells (280 bytes) in STx7111 and STx7200 cut 2.0. */
-
-	if (pcm_reader->ver < ver__AUD_PCMIN__65_3_1)
-		pcm_reader->fdma_max_transfer_size = 2;
-	else
-		pcm_reader->fdma_max_transfer_size = 30;
-
 	/* Get component capabilities */
 
-	snd_stm_printd(0, "Reader's name is '%s'\n", pcm_reader->info->name);
+	snd_printd("Reader's name is '%s'\n", pcm_reader->info->name);
 
-	if (pcm_reader->ver < ver__AUD_PCMIN__65_3_3) {
-		/* STx7111 has a hardware bug in PCM reader in multichannels
-		 * mode, so we will just not be using it ;-) */
-		static unsigned int channels_2[] = { 2 };
-
-		snd_stm_assert(pcm_reader->info->channels == 2, return -EINVAL);
-		pcm_reader->channels_constraint.list = channels_2;
-		pcm_reader->channels_constraint.count = 1;
-	} else {
-		static unsigned int channels_2_10[] = { 2, 4, 6, 8, 10 };
-
-		snd_stm_assert(pcm_reader->info->channels > 0, return -EINVAL);
-		snd_stm_assert(pcm_reader->info->channels <= 10,
-				return -EINVAL);
-		snd_stm_assert(pcm_reader->info->channels % 2 == 0,
-				return -EINVAL);
-		pcm_reader->channels_constraint.list = channels_2_10;
-		pcm_reader->channels_constraint.count =
-			pcm_reader->info->channels / 2;
-	}
+	card = snd_stm_cards_get(pcm_reader->info->card_id);
+	snd_assert(card != NULL, return -EINVAL);
+	snd_printd("Reader will be a member of a card '%s' as a PCM device "
+			"no. %d.\n", card->id, pcm_reader->info->card_device);
+
+	snd_assert(pcm_reader->info->channels != NULL, return -EINVAL);
+	snd_assert(pcm_reader->info->channels_num > 0, return -EINVAL);
+	pcm_reader->channels_constraint.list = pcm_reader->info->channels;
+	pcm_reader->channels_constraint.count = pcm_reader->info->channels_num;
 	pcm_reader->channels_constraint.mask = 0;
-	for (i = 0; i < pcm_reader->channels_constraint.count; i++)
-		snd_stm_printd(0, "Reader capable of capturing %u-channels PCM."
-				"\n", pcm_reader->channels_constraint.list[i]);
+	for (i = 0; i < pcm_reader->info->channels_num; i++)
+		snd_printd("Player capable of playing %u-channels PCM.\n",
+				pcm_reader->info->channels[i]);
+
+	/* Preallocate buffer */
+
+	/* TODO */
 
 	/* Create ALSA lowlevel device */
 
@@ -936,40 +930,14 @@
 	snd_pcm_set_ops(pcm_reader->pcm, SNDRV_PCM_STREAM_CAPTURE,
 			&snd_stm_pcm_reader_pcm_ops);
 
-	/* Initialize buffer */
-
-	pcm_reader->buffer = snd_stm_buffer_create(pcm_reader->pcm,
-			pcm_reader->device,
-			snd_stm_pcm_reader_hw.buffer_bytes_max);
-	if (!pcm_reader->buffer) {
-		snd_stm_printe("Cannot initialize buffer!\n");
-		result = -ENOMEM;
-		goto error_buffer_create;
-	}
-
-	/* Register in converters router */
-
-	pcm_reader->conv_source = snd_stm_conv_register_source(
-			&platform_bus_type, pdev->dev.bus_id,
-			pcm_reader->info->channels,
-			card, pcm_reader->info->card_device);
-	if (!pcm_reader->conv_source) {
-		snd_stm_printe("Cannot register in converters router!\n");
-		result = -ENOMEM;
-		goto error_conv_register_source;
-	}
-
 	/* Done now */
 
 	platform_set_drvdata(pdev, pcm_reader);
 
+	snd_printd("--- Probed successfully!\n");
+
 	return 0;
 
-error_conv_register_source:
-	snd_stm_buffer_dispose(pcm_reader->buffer);
-error_buffer_create:
-	/* snd_pcm_free() is not available - PCM device will be released
-	 * during card release */
 error_pcm:
 	snd_device_free(card, pcm_reader);
 error_device:
@@ -989,13 +957,9 @@
 {
 	struct snd_stm_pcm_reader *pcm_reader = platform_get_drvdata(pdev);
 
-	snd_stm_printd(1, "snd_stm_pcm_reader_remove(pdev=%p)\n", pdev);
-
-	snd_stm_assert(pcm_reader, return -EINVAL);
+	snd_assert(pcm_reader, return -EINVAL);
 	snd_stm_magic_assert(pcm_reader, return -EINVAL);
 
-	snd_stm_conv_unregister_source(pcm_reader->conv_source);
-	snd_stm_buffer_dispose(pcm_reader->buffer);
 	snd_stm_fdma_release(pcm_reader->fdma_channel);
 	snd_stm_irq_release(pcm_reader->irq, pcm_reader);
 	snd_stm_memory_release(pcm_reader->mem_region, pcm_reader->base);
@@ -1008,7 +972,7 @@
 
 static struct platform_driver snd_stm_pcm_reader_driver = {
 	.driver = {
-		.name = "snd_pcm_reader",
+		.name = "pcm_reader",
 	},
 	.probe = snd_stm_pcm_reader_probe,
 	.remove = snd_stm_pcm_reader_remove,
@@ -1023,7 +987,7 @@
 	return platform_driver_register(&snd_stm_pcm_reader_driver);
 }
 
-void snd_stm_pcm_reader_exit(void)
+void snd_stm_pcm_reader_cleanup(void)
 {
 	platform_driver_unregister(&snd_stm_pcm_reader_driver);
 }
diff -urN linux-sh4-2.6.23.17_stm23_0119-orig/sound//stm/spdif_player.c linux-sh4/sound//stm/spdif_player.c
--- linux-sh4-2.6.23.17_stm23_0119-orig/sound//stm/spdif_player.c	2009-06-06 20:17:15.000000000 +0200
+++ linux-sh4/sound//stm/spdif_player.c	2009-07-18 22:49:41.000000000 +0200
@@ -3,7 +3,7 @@
  *
  *   Copyright (c) 2005-2007 STMicroelectronics Limited
  *
- *   Author: Pawel Moll <pawel.moll@st.com>
+ *   Author: Pawel MOLL <pawel.moll@st.com>
  *
  *   This program is free software; you can redistribute it and/or modify
  *   it under the terms of the GNU General Public License as published by
@@ -25,9 +25,11 @@
 #include <linux/io.h>
 #include <linux/platform_device.h>
 #include <linux/interrupt.h>
-#include <linux/delay.h>
+#include <linux/bpa2.h>
 #include <asm/cacheflush.h>
+#include <linux/stm/soc.h>
 #include <linux/stm/stm-dma.h>
+#include <linux/stm/registers.h>
 #include <sound/driver.h>
 #include <sound/core.h>
 #include <sound/pcm.h>
@@ -36,9 +38,9 @@
 #include <sound/info.h>
 #include <sound/asoundef.h>
 
-#define COMPONENT spdif_player
+#undef TRACE /* See common.h debug features */
+#define MAGIC 8 /* See common.h debug features */
 #include "common.h"
-#include "reg_aud_spdif.h"
 
 
 
@@ -82,29 +84,27 @@
 	struct snd_stm_spdif_player_info *info;
 	struct device *device;
 	struct snd_pcm *pcm;
-	int ver; /* IP version, used by register access macros */
 
 	/* Resources */
 	struct resource *mem_region;
 	void *base;
 	unsigned long fifo_phys_address;
 	unsigned int irq;
-	int fdma_channel;
+	unsigned int fdma_channel;
 
 	/* Environment settings */
-	struct snd_stm_fsynth_channel *fsynth_channel;
-	struct snd_stm_conv_source *conv_source;
+	struct device *fsynth_device;
+	int fsynth_channel;
+	struct snd_stm_conv *conv;
 
 	/* Default settings (controlled by controls ;-) */
 	struct snd_stm_spdif_player_settings default_settings;
 	spinlock_t default_settings_lock; /* Protects default_settings */
 
 	/* Runtime data */
-	struct snd_stm_conv_group *conv_group;
-	struct snd_stm_buffer *buffer;
+	void *buffer;
 	struct snd_info_entry *proc_entry;
 	struct snd_pcm_substream *substream;
-	int fdma_max_transfer_size;
 	struct stm_dma_params fdma_params;
 	struct stm_dma_req *fdma_request;
 	struct snd_stm_spdif_player_settings stream_settings;
@@ -126,42 +126,39 @@
 	struct snd_stm_spdif_player *spdif_player = dev_id;
 	unsigned int status;
 
-	snd_stm_printd(2, "snd_stm_spdif_player_irq_handler(irq=%d, "
+	snd_stm_printt("snd_stm_spdif_player_irq_handler(irq=%d, "
 			"dev_id=0x%p)\n", irq, dev_id);
 
-	snd_stm_assert(spdif_player, return -EINVAL);
+	snd_assert(spdif_player, return -EINVAL);
 	snd_stm_magic_assert(spdif_player, return -EINVAL);
 
 	/* Get interrupt status & clear them immediately */
 	preempt_disable();
-	status = get__AUD_SPDIF_ITS(spdif_player);
-	set__AUD_SPDIF_ITS_CLR(spdif_player, status);
+	status = REGISTER_PEEK(spdif_player->base, AUD_SPDIF_ITS);
+	REGISTER_POKE(spdif_player->base, AUD_SPDIF_ITS_CLR, status);
 	preempt_enable();
 
-	if (unlikely(status &
-			mask__AUD_SPDIF_ITS__UNF__PENDING(spdif_player))) {
+	/* Underflow? */
+	if (unlikely(status & REGFIELD_VALUE(AUD_SPDIF_ITS, UNF, PENDING))) {
 		snd_stm_printe("Underflow detected in SPDIF player '%s'!\n",
 				spdif_player->device->bus_id);
-
-		snd_pcm_stop(spdif_player->substream, SNDRV_PCM_STATE_XRUN);
-
 		result = IRQ_HANDLED;
-	} else if (likely(status &
-			mask__AUD_SPDIF_ITS__NSAMPLE__PENDING(spdif_player))) {
-		/* Period successfully played */
+	}
+
+	/* Period successfully played */
+	if (likely(status & REGFIELD_VALUE(AUD_SPDIF_ITS, NSAMPLE, PENDING)))
 		do {
-			snd_stm_assert(spdif_player->substream, break);
+			snd_assert(spdif_player->substream, break);
 
-			snd_stm_printd(2, "Period elapsed ('%s')\n",
+			snd_stm_printt("Period elapsed ('%s')\n",
 					spdif_player->device->bus_id);
 			snd_pcm_period_elapsed(spdif_player->substream);
 
 			result = IRQ_HANDLED;
 		} while (0);
-	}
 
 	/* Some alien interrupt??? */
-	snd_stm_assert(result == IRQ_HANDLED);
+	snd_assert(result == IRQ_HANDLED);
 
 	return result;
 }
@@ -178,7 +175,14 @@
 	.formats	= (SNDRV_PCM_FMTBIT_S32_LE |
 				SNDRV_PCM_FMTBIT_S24_LE),
 
-	.rates		= SNDRV_PCM_RATE_CONTINUOUS,
+	.rates		= (SNDRV_PCM_RATE_32000 |
+				SNDRV_PCM_RATE_44100 |
+				SNDRV_PCM_RATE_48000 |
+				SNDRV_PCM_RATE_64000 |
+				SNDRV_PCM_RATE_88200 |
+				SNDRV_PCM_RATE_96000 |
+				SNDRV_PCM_RATE_176400 |
+				SNDRV_PCM_RATE_192000),
 	.rate_min	= 32000,
 	.rate_max	= 192000,
 
@@ -227,7 +231,14 @@
 				SNDRV_PCM_INFO_PAUSE),
 	.formats	= (SNDRV_PCM_FMTBIT_S32_LE),
 
-	.rates		= SNDRV_PCM_RATE_CONTINUOUS,
+	.rates		= (SNDRV_PCM_RATE_32000 |
+				SNDRV_PCM_RATE_44100 |
+				SNDRV_PCM_RATE_48000 |
+				SNDRV_PCM_RATE_64000 |
+				SNDRV_PCM_RATE_88200 |
+				SNDRV_PCM_RATE_96000 |
+				SNDRV_PCM_RATE_176400 |
+				SNDRV_PCM_RATE_192000),
 	.rate_min	= 32000,
 	.rate_max	= 192000,
 
@@ -250,26 +261,24 @@
 			snd_pcm_substream_chip(substream);
 	struct snd_pcm_runtime *runtime = substream->runtime;
 
-	snd_stm_printd(1, "snd_stm_spdif_player_open(substream=0x%p)\n",
+	snd_stm_printt("snd_stm_spdif_player_open(substream=0x%p)\n",
 			substream);
 
-	snd_stm_assert(spdif_player, return -EINVAL);
+	snd_assert(spdif_player, return -EINVAL);
 	snd_stm_magic_assert(spdif_player, return -EINVAL);
-	snd_stm_assert(runtime, return -EINVAL);
+	snd_assert(runtime, return -EINVAL);
 
 	snd_pcm_set_sync(substream);  /* TODO: ??? */
 
-	/* Get attached converters handle */
+	/* Get attached converter handle */
 
-	spdif_player->conv_group =
-			snd_stm_conv_request_group(spdif_player->conv_source);
-	if (spdif_player->conv_group)
-		snd_stm_printd(1, "'%s' is attached to '%s' converter(s)...\n",
-				spdif_player->device->bus_id,
-				snd_stm_conv_get_name(
-				spdif_player->conv_group));
+	spdif_player->conv = snd_stm_conv_get_attached(spdif_player->device);
+	if (spdif_player->conv)
+		snd_printd("Converter '%s' attached to '%s'...\n",
+				spdif_player->conv->name,
+				spdif_player->device->bus_id);
 	else
-		snd_stm_printd(1, "Warning! No converter attached to '%s'!\n",
+		snd_printd("Warning! No converter attached to '%s'!\n",
 				spdif_player->device->bus_id);
 
 	/* Get default data */
@@ -293,7 +302,7 @@
 	 * of a FDMA transfer bytes (which varies depending on channels
 	 * number and sample bytes) */
 	result = snd_stm_pcm_hw_constraint_transfer_bytes(runtime,
-			spdif_player->fdma_max_transfer_size * 4);
+			spdif_player->info->fdma_max_transfer_size * 4);
 	if (result < 0) {
 		snd_stm_printe("Can't set buffer bytes constraint!\n");
 		return result;
@@ -305,9 +314,6 @@
 	else
 		runtime->hw = snd_stm_spdif_player_hw_raw;
 
-	/* Interrupt handler will need the substream pointer... */
-	spdif_player->substream = substream;
-
 	return 0;
 }
 
@@ -316,19 +322,12 @@
 	struct snd_stm_spdif_player *spdif_player =
 			snd_pcm_substream_chip(substream);
 
-	snd_stm_printd(1, "snd_stm_spdif_player_close(substream=0x%p)\n",
+	snd_stm_printt("snd_stm_spdif_player_close(substream=0x%p)\n",
 			substream);
 
-	snd_stm_assert(spdif_player, return -EINVAL);
+	snd_assert(spdif_player, return -EINVAL);
 	snd_stm_magic_assert(spdif_player, return -EINVAL);
 
-	if (spdif_player->conv_group) {
-		snd_stm_conv_release_group(spdif_player->conv_group);
-		spdif_player->conv_group = NULL;
-	}
-
-	spdif_player->substream = NULL;
-
 	return 0;
 }
 
@@ -338,23 +337,35 @@
 			snd_pcm_substream_chip(substream);
 	struct snd_pcm_runtime *runtime = substream->runtime;
 
-	snd_stm_printd(1, "snd_stm_spdif_player_hw_free(substream=0x%p)\n",
+	snd_stm_printt("snd_stm_spdif_player_hw_free(substream=0x%p)\n",
 			substream);
 
-	snd_stm_assert(spdif_player, return -EINVAL);
+	snd_assert(spdif_player, return -EINVAL);
 	snd_stm_magic_assert(spdif_player, return -EINVAL);
-	snd_stm_assert(runtime, return -EINVAL);
+	snd_assert(runtime, return -EINVAL);
 
 	/* This callback may be called more than once... */
 
-	if (snd_stm_buffer_is_allocated(spdif_player->buffer)) {
-		/* Let the FDMA stop */
-		dma_wait_for_completion(spdif_player->fdma_channel);
+	if (spdif_player->buffer) {
+		/* Dispose buffer */
 
-		/* Free buffer */
-		snd_stm_buffer_free(spdif_player->buffer);
+		snd_stm_printt("Freeing buffer for %s: buffer=0x%p, "
+				"dma_addr=0x%08x, dma_area=0x%p, "
+				"dma_bytes=%u\n", spdif_player->device->bus_id,
+				spdif_player->buffer, runtime->dma_addr,
+				runtime->dma_area, runtime->dma_bytes);
+
+		iounmap(runtime->dma_area);
+
+		/* TODO: symmetrical to the above (BPA2 etc.) */
+		bigphysarea_free(spdif_player->buffer, runtime->dma_bytes);
+
+		spdif_player->buffer = NULL;
+		runtime->dma_area = NULL;
+		runtime->dma_addr = 0;
+		runtime->dma_bytes = 0;
 
-		/* Free FDMA parameters */
+		/* Dispose FDMA parameters */
 
 		dma_params_free(&spdif_player->fdma_params);
 		dma_req_free(spdif_player->fdma_channel,
@@ -381,22 +392,22 @@
 		.initiator = spdif_player->info->fdma_initiator,
 	};
 
-	snd_stm_printd(1, "snd_stm_spdif_player_hw_params(substream=0x%p,"
+	snd_stm_printt("snd_stm_spdif_player_hw_params(substream=0x%p,"
 			" hw_params=0x%p)\n", substream, hw_params);
 
-	snd_stm_assert(spdif_player, return -EINVAL);
+	snd_assert(spdif_player, return -EINVAL);
 	snd_stm_magic_assert(spdif_player, return -EINVAL);
-	snd_stm_assert(runtime, return -EINVAL);
+	snd_assert(runtime, return -EINVAL);
 
 	/* This function may be called many times, so let's be prepared... */
-	if (snd_stm_buffer_is_allocated(spdif_player->buffer))
+	if (spdif_player->buffer)
 		snd_stm_spdif_player_hw_free(substream);
 
 	/* Allocate buffer */
 
 	buffer_bytes = params_buffer_bytes(hw_params);
-	result = snd_stm_buffer_alloc(spdif_player->buffer, substream,
-			buffer_bytes);
+	spdif_player->buffer = bigphysarea_alloc(buffer_bytes);
+	/* TODO: move to BPA2, use pcm lib as fallback... */
 	if (!spdif_player->buffer) {
 		snd_stm_printe("Can't allocate %d bytes buffer for '%s'!\n",
 				buffer_bytes, spdif_player->device->bus_id);
@@ -404,36 +415,45 @@
 		goto error_buf_alloc;
 	}
 
+	runtime->dma_addr = virt_to_phys(spdif_player->buffer);
+	runtime->dma_area = ioremap_nocache(runtime->dma_addr, buffer_bytes);
+	runtime->dma_bytes = buffer_bytes;
+
+	snd_stm_printt("Allocated buffer for %s: buffer=0x%p, "
+			"dma_addr=0x%08x, dma_area=0x%p, "
+			"dma_bytes=%u\n", spdif_player->device->bus_id,
+			spdif_player->buffer, runtime->dma_addr,
+			runtime->dma_area, runtime->dma_bytes);
+
 	/* Set FDMA transfer size (number of opcodes generated
 	 * after request line assertion) */
 
 	frame_bytes = snd_pcm_format_physical_width(params_format(hw_params)) *
 			params_channels(hw_params) / 8;
 	transfer_bytes = snd_stm_pcm_transfer_bytes(frame_bytes,
-			spdif_player->fdma_max_transfer_size * 4);
+			spdif_player->info->fdma_max_transfer_size * 4);
 	transfer_size = transfer_bytes / 4;
-	snd_stm_printd(1, "FDMA request trigger limit and transfer size set "
-			"to %d.\n", transfer_size);
+	snd_stm_printt("FDMA request trigger limit and transfer size set to "
+			"%d.\n", transfer_size);
 
-	snd_stm_assert(buffer_bytes % transfer_bytes == 0, return -EINVAL);
-	snd_stm_assert(transfer_size <= spdif_player->fdma_max_transfer_size,
+	snd_assert(buffer_bytes % transfer_bytes == 0, return -EINVAL);
+	snd_assert(transfer_size <= spdif_player->info->fdma_max_transfer_size,
 			return -EINVAL);
 	fdma_req_config.count = transfer_size;
 
-	if (spdif_player->ver >= ver__AUD_SPDIF__65_3_1) {
-		/* FDMA request trigger control was introduced in
-		 * STx7111... */
-		snd_stm_assert(transfer_size == 1 || transfer_size % 2 == 0,
-				return -EINVAL);
-		snd_stm_assert(transfer_size <=
-				mask__AUD_SPDIF_CONFIG__DMA_REQ_TRIG_LMT(
-				spdif_player), return -EINVAL);
-		set__AUD_SPDIF_CONFIG__DMA_REQ_TRIG_LMT(spdif_player,
-				transfer_size);
-	}
+#if defined(CONFIG_CPU_SUBTYPE_STX7111)
+	snd_assert(transfer_size == 1 || transfer_size % 2 == 0,
+			return -EINVAL);
+	snd_assert(transfer_size <= AUD_SPDIF_CONFIG__DMA_REQ_TRIG_LMT__MASK,
+			return -EINVAL);
+	REGFIELD_POKE(spdif_player->base, AUD_SPDIF_CONFIG,
+			DMA_REQ_TRIG_LMT, transfer_size);
+#endif
 
 	/* Configure FDMA transfer */
 
+	/* TODO: try to use SPDIF FMDA channel */
+
 	spdif_player->fdma_request = dma_req_config(spdif_player->fdma_channel,
 			spdif_player->info->fdma_request_line,
 			&fdma_req_config);
@@ -468,7 +488,13 @@
 	dma_req_free(spdif_player->fdma_channel,
 			spdif_player->fdma_request);
 error_req_config:
-	snd_stm_buffer_free(spdif_player->buffer);
+	iounmap(runtime->dma_area);
+	/* TODO: symmetrical to the above (BPA2 etc.) */
+	bigphysarea_free(spdif_player->buffer, runtime->dma_bytes);
+	spdif_player->buffer = NULL;
+	runtime->dma_area = NULL;
+	runtime->dma_addr = 0;
+	runtime->dma_bytes = 0;
 error_buf_alloc:
 	return result;
 }
@@ -482,13 +508,13 @@
 	unsigned long status;
 	struct snd_aes_iec958 *iec958;
 
-	snd_stm_printd(1, "snd_stm_spdif_player_prepare(substream=0x%p)\n",
+	snd_stm_printt("snd_stm_spdif_player_prepare(substream=0x%p)\n",
 			substream);
 
-	snd_stm_assert(spdif_player, return -EINVAL);
+	snd_assert(spdif_player, return -EINVAL);
 	snd_stm_magic_assert(spdif_player, return -EINVAL);
-	snd_stm_assert(runtime, return -EINVAL);
-	snd_stm_assert(runtime->period_size * runtime->channels <
+	snd_assert(runtime, return -EINVAL);
+	snd_assert(runtime->period_size * runtime->channels <
 			MAX_SAMPLES_PER_PERIOD, return -EINVAL);
 
 	/* Configure SPDIF-PCM synchronisation */
@@ -497,34 +523,35 @@
 
 	/* Get oversampling value from connected converter */
 
-	if (spdif_player->conv_group) {
-		unsigned int format = snd_stm_conv_get_format(
-				spdif_player->conv_group);
+	if (spdif_player->conv) {
+		unsigned int format =
+				snd_stm_conv_get_format(spdif_player->conv);
 
-		snd_stm_assert((format & SND_STM_FORMAT__MASK) ==
+		snd_assert((format & SND_STM_FORMAT__MASK) ==
 				SND_STM_FORMAT__SPDIF, return -EINVAL);
 
 		oversampling = snd_stm_conv_get_oversampling(
-				spdif_player->conv_group);
+				spdif_player->conv);
 		if (oversampling == 0)
 			oversampling = DEFAULT_OVERSAMPLING;
 	} else {
 		oversampling = DEFAULT_OVERSAMPLING;
 	}
 
-	snd_stm_printd(1, "Player %s: sampling frequency %d, oversampling %d\n",
+	snd_stm_printt("Player %s: sampling frequency %d, oversampling %d\n",
 			spdif_player->device->bus_id, runtime->rate,
 			oversampling);
 
-	snd_stm_assert(oversampling > 0, return -EINVAL);
+	snd_assert(oversampling > 0, return -EINVAL);
 
 	/* Allowed oversampling values (SPDIF subframe is 32 bits long,
 	 * so oversampling must be multiple of 128... */
-	snd_stm_assert(oversampling % 128 == 0, return -EINVAL);
+	snd_assert(oversampling % 128 == 0, return -EINVAL);
 
 	/* Set up frequency synthesizer */
 
-	snd_stm_fsynth_set_frequency(spdif_player->fsynth_channel,
+	snd_stm_fsynth_set_frequency(spdif_player->fsynth_device,
+			spdif_player->fsynth_channel,
 			runtime->rate * oversampling);
 
 	/* Configure SPDIF player frequency divider
@@ -542,12 +569,14 @@
 	 *   - Fs - sampling rate (frequency)
 	 */
 
-	set__AUD_SPDIF_CTRL__CLK_DIV(spdif_player, oversampling / 128);
+	REGFIELD_POKE(spdif_player->base, AUD_SPDIF_CTRL, CLK_DIV,
+			oversampling / 128);
 
 	/* Configure NSAMPLE interrupt (in samples,
 	 * so period size times channels) */
 
-	set__AUD_SPDIF_CTRL__MEMREAD(spdif_player, runtime->period_size * 2);
+	REGFIELD_POKE(spdif_player->base, AUD_SPDIF_CTRL, MEMREAD,
+			runtime->period_size * 2);
 
 	/* Reset IEC958 software formatting counters */
 
@@ -560,45 +589,49 @@
 	iec958 = &spdif_player->stream_settings.iec958;
 	status = iec958->status[0] | iec958->status[1] << 8 |
 		iec958->status[2] << 16 | iec958->status[3] << 24;
-	set__AUD_SPDIF_CL1__CL1(spdif_player, status);
-	set__AUD_SPDIF_CL2_CR2_UV__CL2(spdif_player, iec958->status[4] & 0xf);
-	set__AUD_SPDIF_CR1__CR1(spdif_player, status);
-	set__AUD_SPDIF_CL2_CR2_UV__CR2(spdif_player, iec958->status[4] & 0xf);
+	REGFIELD_POKE(spdif_player->base, AUD_SPDIF_CL1,
+			CL1, status);
+	REGFIELD_POKE(spdif_player->base, AUD_SPDIF_CL2_CR2_UV,
+			CL2, iec958->status[4] & 0xf);
+	REGFIELD_POKE(spdif_player->base, AUD_SPDIF_CR1,
+			CR1, status);
+	REGFIELD_POKE(spdif_player->base, AUD_SPDIF_CL2_CR2_UV,
+			CR2, iec958->status[4] & 0xf);
 
 	/* User data - well, can't do too much here... */
-	set__AUD_SPDIF_CL2_CR2_UV__LU(spdif_player, 0);
-	set__AUD_SPDIF_CL2_CR2_UV__RU(spdif_player, 0);
+	REGFIELD_POKE(spdif_player->base, AUD_SPDIF_CL2_CR2_UV, LU, 0);
+	REGFIELD_POKE(spdif_player->base, AUD_SPDIF_CL2_CR2_UV, RU, 0);
 
 	if (spdif_player->stream_settings.encoding_mode ==
 			SNDRV_STM_SPDIF_ENCODING_MODE_PCM) {
 		/* Linear PCM: validity bit are zeroed */
-		set__AUD_SPDIF_CL2_CR2_UV__LV(spdif_player, 0);
-		set__AUD_SPDIF_CL2_CR2_UV__RV(spdif_player, 0);
+		REGFIELD_POKE(spdif_player->base, AUD_SPDIF_CL2_CR2_UV, LV, 0);
+		REGFIELD_POKE(spdif_player->base, AUD_SPDIF_CL2_CR2_UV, RV, 0);
 	} else {
 		struct snd_stm_spdif_player_settings *settings =
 				&spdif_player->stream_settings;
 
 		/* Encoded mode: validity bits are one */
-		set__AUD_SPDIF_CL2_CR2_UV__LV(spdif_player, 1);
-		set__AUD_SPDIF_CL2_CR2_UV__RV(spdif_player, 1);
+		REGFIELD_POKE(spdif_player->base, AUD_SPDIF_CL2_CR2_UV, LV, 1);
+		REGFIELD_POKE(spdif_player->base, AUD_SPDIF_CL2_CR2_UV, RV, 1);
 
 		/* Number of frames is data/pause bursts */
-		set__AUD_SPDIF_BST_FL__DBURST(spdif_player,
+		REGFIELD_POKE(spdif_player->base, AUD_SPDIF_BST_FL, DBURST,
 				settings->iec61937_audio_repetition);
-		set__AUD_SPDIF_BST_FL__PDBURST(spdif_player,
+		REGFIELD_POKE(spdif_player->base, AUD_SPDIF_BST_FL, PDBURST,
 				settings->iec61937_pause_repetition);
 
 		/* IEC61937 Preamble */
-		set__AUD_SPDIF_PA_PB__PA(spdif_player,
+		REGFIELD_POKE(spdif_player->base, AUD_SPDIF_PA_PB, PA,
 				settings->iec61937_preamble[0] |
 				settings->iec61937_preamble[1] << 8);
-		set__AUD_SPDIF_PA_PB__PB(spdif_player,
+		REGFIELD_POKE(spdif_player->base, AUD_SPDIF_PA_PB, PB,
 				settings->iec61937_preamble[2] |
 				settings->iec61937_preamble[3] << 8);
-		set__AUD_SPDIF_PC_PD__PC(spdif_player,
+		REGFIELD_POKE(spdif_player->base, AUD_SPDIF_PC_PD, PC,
 				settings->iec61937_preamble[4] |
 				settings->iec61937_preamble[5] << 8);
-		set__AUD_SPDIF_PC_PD__PD(spdif_player,
+		REGFIELD_POKE(spdif_player->base, AUD_SPDIF_PC_PD, PD,
 				settings->iec61937_preamble[6] |
 				settings->iec61937_preamble[7] << 8);
 
@@ -615,15 +648,15 @@
 	struct snd_stm_spdif_player *spdif_player =
 			snd_pcm_substream_chip(substream);
 
-	snd_stm_printd(1, "snd_stm_spdif_player_start(substream=0x%p)\n",
+	snd_stm_printt("snd_stm_spdif_player_start(substream=0x%p)\n",
 			substream);
 
-	snd_stm_assert(spdif_player, return -EINVAL);
+	snd_assert(spdif_player, return -EINVAL);
 	snd_stm_magic_assert(spdif_player, return -EINVAL);
 
 	/* Un-reset SPDIF player */
 
-	set__AUD_SPDIF_RST__SRSTP__RUNNING(spdif_player);
+	REGFIELD_SET(spdif_player->base, AUD_SPDIF_RST, SRSTP, RUNNING);
 
 	/* Launch FDMA transfer */
 
@@ -634,32 +667,27 @@
 				spdif_player->device->bus_id);
 		return -EINVAL;
 	}
-	while (dma_get_status(spdif_player->fdma_channel) !=
-			DMA_CHANNEL_STATUS_RUNNING)
-		udelay(5);
-
-	/* Enable player interrupts (and clear possible stalled ones) */
-
-	enable_irq(spdif_player->irq);
-	set__AUD_SPDIF_ITS_CLR__NSAMPLE__CLEAR(spdif_player);
-	set__AUD_SPDIF_IT_EN_SET__NSAMPLE__SET(spdif_player);
-	set__AUD_SPDIF_ITS_CLR__UNF__CLEAR(spdif_player);
-	set__AUD_SPDIF_IT_EN_SET__UNF__SET(spdif_player);
 
-	/* Launch the player */
+	/* Launch SPDIF player */
+
+	spdif_player->substream = substream;
 
 	if (spdif_player->stream_settings.encoding_mode ==
 			SNDRV_STM_SPDIF_ENCODING_MODE_PCM)
-		set__AUD_SPDIF_CTRL__MODE__PCM(spdif_player);
+		REGFIELD_SET(spdif_player->base, AUD_SPDIF_CTRL, MODE, PCM);
 	else
-		set__AUD_SPDIF_CTRL__MODE__ENCODED(spdif_player);
+		REGFIELD_SET(spdif_player->base, AUD_SPDIF_CTRL, MODE, ENCODED);
+
+	/* Enable player interrupts */
+
+	REGFIELD_SET(spdif_player->base, AUD_SPDIF_IT_EN_SET, NSAMPLE, SET);
+	REGFIELD_SET(spdif_player->base, AUD_SPDIF_IT_EN_SET, UNF, SET);
 
 	/* Wake up & unmute converter */
 
-	if (spdif_player->conv_group) {
-		snd_stm_conv_enable(spdif_player->conv_group,
-				0, substream->runtime->channels - 1);
-		snd_stm_conv_unmute(spdif_player->conv_group);
+	if (spdif_player->conv) {
+		snd_stm_conv_enable(spdif_player->conv);
+		snd_stm_conv_unmute(spdif_player->conv);
 	}
 
 	return 0;
@@ -670,28 +698,28 @@
 	struct snd_stm_spdif_player *spdif_player =
 			snd_pcm_substream_chip(substream);
 
-	snd_stm_printd(1, "snd_stm_spdif_player_stop(substream=0x%p)\n",
+	snd_stm_printt("snd_stm_spdif_player_stop(substream=0x%p)\n",
 			substream);
 
-	snd_stm_assert(spdif_player, return -EINVAL);
+	snd_assert(spdif_player, return -EINVAL);
 	snd_stm_magic_assert(spdif_player, return -EINVAL);
 
 	/* Mute & shutdown converter */
 
-	if (spdif_player->conv_group) {
-		snd_stm_conv_mute(spdif_player->conv_group);
-		snd_stm_conv_disable(spdif_player->conv_group);
+	if (spdif_player->conv) {
+		snd_stm_conv_mute(spdif_player->conv);
+		snd_stm_conv_disable(spdif_player->conv);
 	}
 
 	/* Disable interrupts */
 
-	set__AUD_SPDIF_IT_EN_CLR__NSAMPLE__CLEAR(spdif_player);
-	set__AUD_SPDIF_IT_EN_CLR__UNF__CLEAR(spdif_player);
-	disable_irq(spdif_player->irq);
+	REGFIELD_SET(spdif_player->base, AUD_SPDIF_IT_EN_CLR, NSAMPLE, CLEAR);
+	REGFIELD_SET(spdif_player->base, AUD_SPDIF_IT_EN_CLR, UNF, CLEAR);
 
 	/* Stop SPDIF player */
 
-	set__AUD_SPDIF_CTRL__MODE__OFF(spdif_player);
+	REGFIELD_SET(spdif_player->base, AUD_SPDIF_CTRL, MODE, OFF);
+	spdif_player->substream = NULL;
 
 	/* Stop FDMA transfer */
 
@@ -699,7 +727,7 @@
 
 	/* Reset SPDIF player */
 
-	set__AUD_SPDIF_RST__SRSTP__RESET(spdif_player);
+	REGFIELD_SET(spdif_player->base, AUD_SPDIF_RST, SRSTP, RESET);
 
 	return 0;
 }
@@ -710,10 +738,10 @@
 	struct snd_stm_spdif_player *spdif_player =
 			snd_pcm_substream_chip(substream);
 
-	snd_stm_printd(1, "snd_stm_spdif_player_pause(substream=0x%p)\n",
+	snd_stm_printt("snd_stm_spdif_player_pause(substream=0x%p)\n",
 			substream);
 
-	snd_stm_assert(spdif_player, return -EINVAL);
+	snd_assert(spdif_player, return -EINVAL);
 	snd_stm_magic_assert(spdif_player, return -EINVAL);
 
 	/* "Mute" player
@@ -722,9 +750,11 @@
 
 	if (spdif_player->stream_settings.encoding_mode ==
 			SNDRV_STM_SPDIF_ENCODING_MODE_PCM)
-		set__AUD_SPDIF_CTRL__MODE__MUTE_PCM_NULL(spdif_player);
+		REGFIELD_SET(spdif_player->base, AUD_SPDIF_CTRL, MODE,
+				MUTE_PCM_NULL);
 	else
-		set__AUD_SPDIF_CTRL__MODE__MUTE_PAUSE_BURSTS(spdif_player);
+		REGFIELD_SET(spdif_player->base, AUD_SPDIF_CTRL, MODE,
+				MUTE_PAUSE_BURSTS);
 
 	return 0;
 }
@@ -735,19 +765,19 @@
 	struct snd_stm_spdif_player *spdif_player =
 		snd_pcm_substream_chip(substream);
 
-	snd_stm_printd(1, "snd_stm_spdif_player_release(substream=0x%p)\n",
+	snd_stm_printt("snd_stm_spdif_player_release(substream=0x%p)\n",
 			substream);
 
-	snd_stm_assert(spdif_player, return -EINVAL);
+	snd_assert(spdif_player, return -EINVAL);
 	snd_stm_magic_assert(spdif_player, return -EINVAL);
 
 	/* "Unmute" player */
 
 	if (spdif_player->stream_settings.encoding_mode ==
 			SNDRV_STM_SPDIF_ENCODING_MODE_PCM)
-		set__AUD_SPDIF_CTRL__MODE__PCM(spdif_player);
+		REGFIELD_SET(spdif_player->base, AUD_SPDIF_CTRL, MODE, PCM);
 	else
-		set__AUD_SPDIF_CTRL__MODE__ENCODED(spdif_player);
+		REGFIELD_SET(spdif_player->base, AUD_SPDIF_CTRL, MODE, ENCODED);
 
 	return 0;
 }
@@ -755,7 +785,7 @@
 static int snd_stm_spdif_player_trigger(struct snd_pcm_substream *substream,
 		int command)
 {
-	snd_stm_printd(1, "snd_stm_spdif_player_trigger(substream=0x%p,"
+	snd_stm_printt("snd_stm_spdif_player_trigger(substream=0x%p,"
 			" command=%d)\n", substream, command);
 
 	switch (command) {
@@ -781,19 +811,19 @@
 	int residue;
 	snd_pcm_uframes_t pointer;
 
-	snd_stm_printd(2, "snd_stm_spdif_player_pointer(substream=0x%p)\n",
+	snd_stm_printt("snd_stm_spdif_player_pointer(substream=0x%p)\n",
 			substream);
 
-	snd_stm_assert(spdif_player, return -EINVAL);
+	snd_assert(spdif_player, return -EINVAL);
 	snd_stm_magic_assert(spdif_player, return -EINVAL);
-	snd_stm_assert(runtime, return -EINVAL);
+	snd_assert(runtime, return -EINVAL);
 
 	residue = get_dma_residue(spdif_player->fdma_channel);
 	pointer = bytes_to_frames(runtime, runtime->dma_bytes - residue);
 
-	snd_stm_printd(2, "FDMA residue value is %i and buffer size is %u"
+	snd_stm_printt("FDMA residue value is %i and buffer size is %u"
 			" bytes...\n", residue, runtime->dma_bytes);
-	snd_stm_printd(2, "... so HW pointer in frames is %lu (0x%lx)!\n",
+	snd_stm_printt("... so HW pointer in frames is %lu (0x%lx)!\n",
 			pointer, pointer);
 
 	return pointer;
@@ -816,7 +846,7 @@
 {
 	unsigned char data;
 
-	snd_stm_assert(spdif_player, return);
+	snd_assert(spdif_player, return);
 	snd_stm_magic_assert(spdif_player, return);
 
 	/* Clean VUC bits */
@@ -861,14 +891,14 @@
 		snd_pcm_substream_chip(substream);
 	struct snd_pcm_runtime *runtime = substream->runtime;
 
-	snd_stm_printd(2, "snd_stm_spdif_player_copy(substream=0x%p, "
-			"channel=%d, pos=%lu, buf=0x%p, count=%lu)\n",
-			substream, channel, pos, src, count);
+	snd_stm_printt("snd_stm_spdif_player_copy(substream=0x%p, channel=%d,"
+			" pos=%lu, buf=0x%p, count=%lu)\n", substream,
+			channel, pos, src, count);
 
-	snd_stm_assert(spdif_player, return -EINVAL);
+	snd_assert(spdif_player, return -EINVAL);
 	snd_stm_magic_assert(spdif_player, return -EINVAL);
-	snd_stm_assert(runtime, return -EINVAL);
-	snd_stm_assert(channel == -1, return -EINVAL); /* Interleaved buffer */
+	snd_assert(runtime, return -EINVAL);
+	snd_assert(channel == -1, return -EINVAL); /* Interleaved buffer */
 
 	if (spdif_player->stream_settings.input_mode ==
 			SNDRV_STM_SPDIF_INPUT_MODE_NORMAL) {
@@ -880,7 +910,7 @@
 						count)))
 			return -EFAULT;
 
-		snd_stm_printd(2, "Formatting SPDIF frame (format=%d)\n",
+		snd_stm_printt("Formatting SPDIF frame (format=%d)\n",
 				runtime->format);
 
 #if 0
@@ -889,7 +919,7 @@
 
 			copy_from_user(data, src, 64);
 
-			snd_stm_printd(0, "Input:\n");
+			snd_stm_printt("Input:\n");
 			snd_stm_hex_dump(data, 64);
 		}
 #endif
@@ -923,7 +953,7 @@
 		}
 
 #if 0
-		snd_stm_printd(0, "Output:\n");
+		snd_stm_printt("Output:\n");
 		snd_stm_hex_dump(runtime->dma_area +
 				frames_to_bytes(runtime, pos), 64);
 #endif
@@ -946,14 +976,14 @@
 		snd_pcm_substream_chip(substream);
 	struct snd_pcm_runtime *runtime = substream->runtime;
 
-	snd_stm_printd(2, "snd_stm_spdif_player_silence(substream=0x%p, "
+	snd_stm_printt("snd_stm_spdif_player_silence(substream=0x%p, "
 			"channel=%d, pos=%lu, count=%lu)\n",
 			substream, channel, pos, count);
 
-	snd_stm_assert(spdif_player, return -EINVAL);
+	snd_assert(spdif_player, return -EINVAL);
 	snd_stm_magic_assert(spdif_player, return -EINVAL);
-	snd_stm_assert(runtime, return -EINVAL);
-	snd_stm_assert(channel == -1, return -EINVAL); /* Interleaved buffer */
+	snd_assert(runtime, return -EINVAL);
+	snd_assert(channel == -1, return -EINVAL); /* Interleaved buffer */
 
 	if (spdif_player->stream_settings.input_mode ==
 			SNDRV_STM_SPDIF_INPUT_MODE_NORMAL) {
@@ -983,7 +1013,7 @@
 static struct snd_pcm_ops snd_stm_spdif_player_spdif_ops = {
 	.open =      snd_stm_spdif_player_open,
 	.close =     snd_stm_spdif_player_close,
-	.mmap =      snd_stm_buffer_mmap,
+	.mmap =      snd_stm_mmap,
 	.ioctl =     snd_pcm_lib_ioctl,
 	.hw_params = snd_stm_spdif_player_hw_params,
 	.hw_free =   snd_stm_spdif_player_hw_free,
@@ -1005,10 +1035,10 @@
 {
 	struct snd_stm_spdif_player *spdif_player = snd_kcontrol_chip(kcontrol);
 
-	snd_stm_printd(1, "snd_stm_spdif_player_ctl_default_get("
+	snd_stm_printt("snd_stm_spdif_player_ctl_default_get("
 			"kcontrol=0x%p, ucontrol=0x%p)\n", kcontrol, ucontrol);
 
-	snd_stm_assert(spdif_player, return -EINVAL);
+	snd_assert(spdif_player, return -EINVAL);
 	snd_stm_magic_assert(spdif_player, return -EINVAL);
 
 	spin_lock(&spdif_player->default_settings_lock);
@@ -1024,10 +1054,10 @@
 	struct snd_stm_spdif_player *spdif_player = snd_kcontrol_chip(kcontrol);
 	int changed = 0;
 
-	snd_stm_printd(1, "snd_stm_spdif_player_ctl_default_put("
+	snd_stm_printt("snd_stm_spdif_player_ctl_default_put("
 			"kcontrol=0x%p, ucontrol=0x%p)\n", kcontrol, ucontrol);
 
-	snd_stm_assert(spdif_player, return -EINVAL);
+	snd_assert(spdif_player, return -EINVAL);
 	snd_stm_magic_assert(spdif_player, return -EINVAL);
 
 	spin_lock(&spdif_player->default_settings_lock);
@@ -1051,10 +1081,10 @@
 {
 	struct snd_stm_spdif_player *spdif_player = snd_kcontrol_chip(kcontrol);
 
-	snd_stm_printd(1, "snd_stm_spdif_player_ctl_raw_get(kcontrol=0x%p, "
+	snd_stm_printt("snd_stm_spdif_player_ctl_raw_get(kcontrol=0x%p, "
 			"ucontrol=0x%p)\n", kcontrol, ucontrol);
 
-	snd_stm_assert(spdif_player, return -EINVAL);
+	snd_assert(spdif_player, return -EINVAL);
 	snd_stm_magic_assert(spdif_player, return -EINVAL);
 
 	spin_lock(&spdif_player->default_settings_lock);
@@ -1073,10 +1103,10 @@
 	int changed = 0;
 	enum snd_stm_spdif_player_input_mode input_mode;
 
-	snd_stm_printd(1, "snd_stm_spdif_player_ctl_raw_put(kcontrol=0x%p, "
+	snd_stm_printt("snd_stm_spdif_player_ctl_raw_put(kcontrol=0x%p, "
 			"ucontrol=0x%p)\n", kcontrol, ucontrol);
 
-	snd_stm_assert(spdif_player, return -EINVAL);
+	snd_assert(spdif_player, return -EINVAL);
 	snd_stm_magic_assert(spdif_player, return -EINVAL);
 
 	if (ucontrol->value.integer.value[0])
@@ -1101,10 +1131,10 @@
 {
 	struct snd_stm_spdif_player *spdif_player = snd_kcontrol_chip(kcontrol);
 
-	snd_stm_printd(1, "snd_stm_spdif_player_ctl_encoded_get(kcontrol=0x%p, "
-			" ucontrol=0x%p)\n", kcontrol, ucontrol);
+	snd_stm_printt("snd_stm_spdif_player_ctl_encoded_get(kcontrol=0x%p, "
+			"ucontrol=0x%p)\n", kcontrol, ucontrol);
 
-	snd_stm_assert(spdif_player, return -EINVAL);
+	snd_assert(spdif_player, return -EINVAL);
 	snd_stm_magic_assert(spdif_player, return -EINVAL);
 
 	spin_lock(&spdif_player->default_settings_lock);
@@ -1123,10 +1153,10 @@
 	int changed = 0;
 	enum snd_stm_spdif_player_encoding_mode encoding_mode;
 
-	snd_stm_printd(1, "snd_stm_spdif_player_ctl_encoded_put(kcontrol=0x%p,"
-			" ucontrol=0x%p)\n", kcontrol, ucontrol);
+	snd_stm_printt("snd_stm_spdif_player_ctl_encoded_put(kcontrol=0x%p, "
+			"ucontrol=0x%p)\n", kcontrol, ucontrol);
 
-	snd_stm_assert(spdif_player, return -EINVAL);
+	snd_assert(spdif_player, return -EINVAL);
 	snd_stm_magic_assert(spdif_player, return -EINVAL);
 
 	if (ucontrol->value.integer.value[0])
@@ -1160,10 +1190,10 @@
 {
 	struct snd_stm_spdif_player *spdif_player = snd_kcontrol_chip(kcontrol);
 
-	snd_stm_printd(1, "snd_stm_spdif_player_ctl_preamble_get(kcontrol=0x%p"
-			", ucontrol=0x%p)\n", kcontrol, ucontrol);
+	snd_stm_printt("snd_stm_spdif_player_ctl_preamble_get(kcontrol=0x%p, "
+			"ucontrol=0x%p)\n", kcontrol, ucontrol);
 
-	snd_stm_assert(spdif_player, return -EINVAL);
+	snd_assert(spdif_player, return -EINVAL);
 	snd_stm_magic_assert(spdif_player, return -EINVAL);
 
 	spin_lock(&spdif_player->default_settings_lock);
@@ -1181,10 +1211,10 @@
 	struct snd_stm_spdif_player *spdif_player = snd_kcontrol_chip(kcontrol);
 	int changed = 0;
 
-	snd_stm_printd(1, "snd_stm_spdif_player_ctl_preamble_put(kcontrol=0x%p"
-			", ucontrol=0x%p)\n", kcontrol, ucontrol);
+	snd_stm_printt("snd_stm_spdif_player_ctl_preamble_put(kcontrol=0x%p, "
+			"ucontrol=0x%p)\n", kcontrol, ucontrol);
 
-	snd_stm_assert(spdif_player, return -EINVAL);
+	snd_assert(spdif_player, return -EINVAL);
 	snd_stm_magic_assert(spdif_player, return -EINVAL);
 
 	spin_lock(&spdif_player->default_settings_lock);
@@ -1214,10 +1244,10 @@
 {
 	struct snd_stm_spdif_player *spdif_player = snd_kcontrol_chip(kcontrol);
 
-	snd_stm_printd(1, "snd_stm_spdif_player_ctl_audio_repetition_get("
+	snd_stm_printt("snd_stm_spdif_player_ctl_audio_repetition_get("
 			"kcontrol=0x%p, ucontrol=0x%p)\n", kcontrol, ucontrol);
 
-	snd_stm_assert(spdif_player, return -EINVAL);
+	snd_assert(spdif_player, return -EINVAL);
 	snd_stm_magic_assert(spdif_player, return -EINVAL);
 
 	spin_lock(&spdif_player->default_settings_lock);
@@ -1234,10 +1264,10 @@
 	struct snd_stm_spdif_player *spdif_player = snd_kcontrol_chip(kcontrol);
 	int changed = 0;
 
-	snd_stm_printd(1, "snd_stm_spdif_player_ctl_audio_repetition_put("
+	snd_stm_printt("snd_stm_spdif_player_ctl_audio_repetition_put("
 			"kcontrol=0x%p, ucontrol=0x%p)\n", kcontrol, ucontrol);
 
-	snd_stm_assert(spdif_player, return -EINVAL);
+	snd_assert(spdif_player, return -EINVAL);
 	snd_stm_magic_assert(spdif_player, return -EINVAL);
 
 	spin_lock(&spdif_player->default_settings_lock);
@@ -1257,10 +1287,10 @@
 {
 	struct snd_stm_spdif_player *spdif_player = snd_kcontrol_chip(kcontrol);
 
-	snd_stm_printd(1, "snd_stm_spdif_player_ctl_pause_repetition_get("
+	snd_stm_printt("snd_stm_spdif_player_ctl_pause_repetition_get("
 			"kcontrol=0x%p, ucontrol=0x%p)\n", kcontrol, ucontrol);
 
-	snd_stm_assert(spdif_player, return -EINVAL);
+	snd_assert(spdif_player, return -EINVAL);
 	snd_stm_magic_assert(spdif_player, return -EINVAL);
 
 	spin_lock(&spdif_player->default_settings_lock);
@@ -1277,10 +1307,10 @@
 	struct snd_stm_spdif_player *spdif_player = snd_kcontrol_chip(kcontrol);
 	int changed = 0;
 
-	snd_stm_printd(1, "snd_stm_spdif_player_ctl_pause_repetition_put("
+	snd_stm_printt("snd_stm_spdif_player_ctl_pause_repetition_put("
 			"kcontrol=0x%p, ucontrol=0x%p)\n", kcontrol, ucontrol);
 
-	snd_stm_assert(spdif_player, return -EINVAL);
+	snd_assert(spdif_player, return -EINVAL);
 	snd_stm_magic_assert(spdif_player, return -EINVAL);
 
 	spin_lock(&spdif_player->default_settings_lock);
@@ -1295,7 +1325,7 @@
 	return changed;
 }
 
-static struct snd_kcontrol_new snd_stm_spdif_player_ctls[] = {
+static struct snd_kcontrol_new __initdata snd_stm_spdif_player_ctls[] = {
 	{
 		.iface = SNDRV_CTL_ELEM_IFACE_PCM,
 		.name = SNDRV_CTL_NAME_IEC958("", PLAYBACK, DEFAULT),
@@ -1359,20 +1389,18 @@
 #define DUMP_REGISTER(r) \
 		snd_iprintf(buffer, "AUD_SPDIF_%s (offset 0x%02x) =" \
 				" 0x%08x\n", __stringify(r), \
-				offset__AUD_SPDIF_##r(spdif_player), \
-				get__AUD_SPDIF_##r(spdif_player))
+				AUD_SPDIF_##r, \
+				REGISTER_PEEK(spdif_player->base, \
+				AUD_SPDIF_##r))
 
 static void snd_stm_spdif_player_dump_registers(struct snd_info_entry *entry,
 		struct snd_info_buffer *buffer)
 {
 	struct snd_stm_spdif_player *spdif_player = entry->private_data;
 
-	snd_stm_assert(spdif_player, return);
+	snd_assert(spdif_player, return);
 	snd_stm_magic_assert(spdif_player, return);
 
-	snd_iprintf(buffer, "--- %s ---\n", spdif_player->device->bus_id);
-	snd_iprintf(buffer, "base = 0x%p\n", spdif_player->base);
-
 	DUMP_REGISTER(RST);
 	DUMP_REGISTER(DATA);
 	DUMP_REGISTER(ITS);
@@ -1389,53 +1417,35 @@
 	DUMP_REGISTER(CL2_CR2_UV);
 	DUMP_REGISTER(PAU_LAT);
 	DUMP_REGISTER(BST_FL);
-	if (spdif_player->ver >= ver__AUD_SPDIF__65_3_1)
-		DUMP_REGISTER(CONFIG);
-
-	snd_iprintf(buffer, "\n");
+#if defined(CONFIG_CPU_SUBTYPE_STX7111)
+	DUMP_REGISTER(CONFIG);
+#endif
 }
 
 static int snd_stm_spdif_player_register(struct snd_device *snd_device)
 {
 	int result;
 	struct snd_stm_spdif_player *spdif_player = snd_device->device_data;
-	int i;
 
-	snd_stm_printd(1, "snd_stm_spdif_player_register(snd_device=0x%p)\n",
+	snd_stm_printt("snd_stm_spdif_player_register(snd_device=0x%p)\n",
 			snd_device);
 
-	snd_stm_assert(spdif_player, return -EINVAL);
+	snd_assert(spdif_player, return -EINVAL);
 	snd_stm_magic_assert(spdif_player, return -EINVAL);
 
-	snd_stm_printd(0, "--- Registering player '%s'...\n",
-			spdif_player->device->bus_id);
-
 	/* Initialize hardware (format etc.) */
 
-	set__AUD_SPDIF_RST__SRSTP__RESET(spdif_player);
+	REGFIELD_SET(spdif_player->base, AUD_SPDIF_RST, SRSTP, RESET);
 
 	/* TODO: well, hardcoded - shall anyone use it?
 	 * And what it actually means? */
-	set__AUD_SPDIF_CTRL__RND__NO_ROUNDING(spdif_player);
+	REGFIELD_SET(spdif_player->base, AUD_SPDIF_CTRL, RND, NO_ROUNDING);
 
-	set__AUD_SPDIF_CTRL__IDLE__NORMAL(spdif_player);
+	REGFIELD_SET(spdif_player->base, AUD_SPDIF_CTRL, IDLE, NORMAL);
 
 	/* Hardware stuffing is not implemented yet... */
 	/* TODO: oh, is that so? */
-	set__AUD_SPDIF_CTRL__STUFFING__SOFTWARE(spdif_player);
-
-	/* Get frequency synthesizer channel */
-
-	snd_stm_assert(spdif_player->info->fsynth_bus_id != NULL,
-			return -EINVAL);
-	snd_stm_printd(0, "Player connected to %s's output %d.\n",
-			spdif_player->info->fsynth_bus_id,
-			spdif_player->info->fsynth_output);
-
-	spdif_player->fsynth_channel = snd_stm_fsynth_get_channel(
-			spdif_player->info->fsynth_bus_id,
-			spdif_player->info->fsynth_output);
-	snd_stm_assert(spdif_player->fsynth_channel != NULL, return -EINVAL);
+	REGFIELD_SET(spdif_player->base, AUD_SPDIF_CTRL, STUFFING, SOFTWARE);
 
 	/* Registers view in ALSA's procfs */
 
@@ -1445,29 +1455,21 @@
 
 	/* Create ALSA controls */
 
-	result = snd_stm_fsynth_add_adjustement_ctl(
-			spdif_player->fsynth_channel, snd_device->card,
-			spdif_player->info->card_device);
+	result = snd_stm_conv_add_route_ctl(spdif_player->device,
+			snd_device->card, spdif_player->info->card_device);
 	if (result < 0) {
-		snd_stm_printe("Failed to add fsynth adjustment control!\n");
+		snd_stm_printe("Failed to add converter route control!\n");
 		return result;
 	}
 
-	for (i = 0; i < ARRAY_SIZE(snd_stm_spdif_player_ctls); i++) {
-		snd_stm_spdif_player_ctls[i].device =
-				spdif_player->info->card_device;
-		result = snd_ctl_add(snd_device->card,
-				snd_ctl_new1(&snd_stm_spdif_player_ctls[i],
-				spdif_player));
-		if (result < 0) {
-			snd_stm_printe("Failed to add SPDIF ALSA control!\n");
-			return result;
-		}
-		snd_stm_spdif_player_ctls[i].index++;
+	result = snd_stm_fsynth_add_adjustement_ctl(spdif_player->fsynth_device,
+			spdif_player->fsynth_channel,
+			snd_device->card, spdif_player->info->card_device);
+	if (result < 0) {
+		snd_stm_printe("Failed to add fsynth adjustment control!\n");
+		return result;
 	}
 
-	snd_stm_printd(0, "--- Registered successfully!\n");
-
 	return 0;
 }
 
@@ -1475,12 +1477,9 @@
 {
 	struct snd_stm_spdif_player *spdif_player = snd_device->device_data;
 
-	snd_stm_printd(1, "snd_stm_spdif_player_disconnect(snd_device=0x%p)\n",
+	snd_stm_printt("snd_stm_spdif_player_unregister(snd_device=0x%p)\n",
 			snd_device);
 
-	snd_stm_assert(spdif_player, return -EINVAL);
-	snd_stm_magic_assert(spdif_player, return -EINVAL);
-
 	snd_stm_info_unregister(spdif_player->proc_entry);
 
 	return 0;
@@ -1497,18 +1496,14 @@
  * Platform driver routines
  */
 
-static int snd_stm_spdif_player_probe(struct platform_device *pdev)
+static int __init snd_stm_spdif_player_probe(struct platform_device *pdev)
 {
 	int result = 0;
 	struct snd_stm_spdif_player *spdif_player;
-	struct snd_card *card = snd_stm_card_get();
-	int buffer_bytes_max;
-
-	snd_stm_printd(1, "snd_stm_spdif_player_probe(pdev=%p)\n", pdev);
-
-	snd_stm_printd(0, "Probing device '%s'...\n", pdev->dev.bus_id);
+	struct snd_card *card;
+	int i;
 
-	snd_stm_assert(card != NULL, return -EINVAL);
+	snd_printd("--- Probing device '%s'...\n", pdev->dev.bus_id);
 
 	spdif_player = kzalloc(sizeof(*spdif_player), GFP_KERNEL);
 	if (!spdif_player) {
@@ -1519,9 +1514,7 @@
 	}
 	snd_stm_magic_set(spdif_player);
 	spdif_player->info = pdev->dev.platform_data;
-	snd_stm_assert(spdif_player->info != NULL, return -EINVAL);
-	spdif_player->ver = spdif_player->info->ver;
-	snd_stm_assert(spdif_player->ver > 0, return -EINVAL);
+	snd_assert(spdif_player->info != NULL, return -EINVAL);
 	spdif_player->device = &pdev->dev;
 
 	spin_lock_init(&spdif_player->default_settings_lock);
@@ -1535,8 +1528,8 @@
 		goto error_memory_request;
 	}
 	spdif_player->fifo_phys_address = spdif_player->mem_region->start +
-			offset__AUD_SPDIF_DATA(spdif_player);
-	snd_stm_printd(0, "FIFO physical address: 0x%lx.\n",
+		AUD_SPDIF_DATA;
+	snd_printd("FIFO physical address: 0x%lx.\n",
 			spdif_player->fifo_phys_address);
 
 	result = snd_stm_irq_request(pdev, &spdif_player->irq,
@@ -1552,21 +1545,28 @@
 		goto error_fdma_request;
 	}
 
-	/* FDMA transfer size depends (among others ;-) on FIFO length,
-	 * which is:
-	 * - 6 cells (24 bytes) in STx7100/9 and STx7200 cut 1.0
-	 * - 30 cells (120 bytes) in STx7111 and STx7200 cut 2.0. */
-
-	if (spdif_player->ver < ver__AUD_SPDIF__65_2_0)
-		spdif_player->fdma_max_transfer_size = 2;
-	else if (spdif_player->ver == ver__AUD_SPDIF__65_2_0)
-		spdif_player->fdma_max_transfer_size = 4;
-	else
-		spdif_player->fdma_max_transfer_size = 20;
-
 	/* Get component caps */
 
-	snd_stm_printd(0, "Player's name is '%s'\n", spdif_player->info->name);
+	snd_printd("Player's name is '%s'\n", spdif_player->info->name);
+
+	card = snd_stm_cards_get(spdif_player->info->card_id);
+	snd_assert(card != NULL, return -EINVAL);
+	snd_printd("Player will be a member of a card '%s' as a PCM device "
+			"no. %d.\n", card->id, spdif_player->info->card_device);
+
+	/* Get fsynth device */
+
+	snd_printd("Player connected to %s's output %d.\n",
+			spdif_player->info->fsynth_bus_id,
+			spdif_player->info->fsynth_output);
+	spdif_player->fsynth_device = snd_stm_find_device(NULL,
+			spdif_player->info->fsynth_bus_id);
+	snd_assert(spdif_player->fsynth_device != NULL, return -EINVAL);
+	spdif_player->fsynth_channel = spdif_player->info->fsynth_output;
+
+	/* Preallocate buffer */
+
+	/* TODO */
 
 	/* Create ALSA lowlevel device */
 
@@ -1591,41 +1591,36 @@
 	snd_pcm_set_ops(spdif_player->pcm, SNDRV_PCM_STREAM_PLAYBACK,
 			&snd_stm_spdif_player_spdif_ops);
 
-	/* Initialize buffer */
+	/* Create ALSA controls */
 
-	buffer_bytes_max = snd_stm_spdif_player_hw_normal.buffer_bytes_max;
-	if (buffer_bytes_max < snd_stm_spdif_player_hw_raw.buffer_bytes_max)
-		buffer_bytes_max = snd_stm_spdif_player_hw_raw.buffer_bytes_max;
-	spdif_player->buffer = snd_stm_buffer_create(spdif_player->pcm,
-			spdif_player->device, buffer_bytes_max);
-	if (!spdif_player->buffer) {
-		snd_stm_printe("Cannot initialize buffer!\n");
-		result = -ENOMEM;
-		goto error_buffer_create;
+	result = 0;
+	for (i = 0; i < ARRAY_SIZE(snd_stm_spdif_player_ctls); i++) {
+		snd_stm_spdif_player_ctls[i].device =
+				spdif_player->info->card_device;
+		result |= snd_ctl_add(card,
+				snd_ctl_new1(&snd_stm_spdif_player_ctls[i],
+				spdif_player));
+		/* TODO: index per card */
+		snd_stm_spdif_player_ctls[i].index++;
 	}
-
-	/* Register in converters router */
-
-	spdif_player->conv_source = snd_stm_conv_register_source(
-			&platform_bus_type, pdev->dev.bus_id,
-			2, card, spdif_player->info->card_device);
-	if (!spdif_player->conv_source) {
-		snd_stm_printe("Cannot register in converters router!\n");
-		result = -ENOMEM;
-		goto error_conv_register_source;
+	result |= snd_stm_fsynth_add_adjustement_ctl(
+			spdif_player->fsynth_device,
+			spdif_player->fsynth_channel, card,
+			spdif_player->info->card_device);
+	if (result < 0) {
+		snd_stm_printe("Failed to add all ALSA controls!\n");
+		goto error_controls;
 	}
 
 	/* Done now */
 
 	platform_set_drvdata(pdev, spdif_player);
 
+	snd_printd("--- Probed successfully!\n");
+
 	return 0;
 
-error_conv_register_source:
-	snd_stm_buffer_dispose(spdif_player->buffer);
-error_buffer_create:
-	/* snd_pcm_free() is not available - PCM device will be released
-	 * during card release */
+error_controls:
 error_pcm:
 	snd_device_free(card, spdif_player);
 error_device:
@@ -1645,13 +1640,9 @@
 {
 	struct snd_stm_spdif_player *spdif_player = platform_get_drvdata(pdev);
 
-	snd_stm_printd(1, "snd_stm_spdif_player_remove(pdev=%p)\n", pdev);
-
-	snd_stm_assert(spdif_player, return -EINVAL);
+	snd_assert(spdif_player, return -EINVAL);
 	snd_stm_magic_assert(spdif_player, return -EINVAL);
 
-	snd_stm_conv_unregister_source(spdif_player->conv_source);
-	snd_stm_buffer_dispose(spdif_player->buffer);
 	snd_stm_fdma_release(spdif_player->fdma_channel);
 	snd_stm_irq_release(spdif_player->irq, spdif_player);
 	snd_stm_memory_release(spdif_player->mem_region, spdif_player->base);
@@ -1664,7 +1655,7 @@
 
 static struct platform_driver snd_stm_spdif_player_driver = {
 	.driver = {
-		.name = "snd_spdif_player",
+		.name = "spdif_player",
 	},
 	.probe = snd_stm_spdif_player_probe,
 	.remove = snd_stm_spdif_player_remove,
@@ -1681,7 +1672,7 @@
 	return platform_driver_register(&snd_stm_spdif_player_driver);
 }
 
-void snd_stm_spdif_player_exit(void)
+void snd_stm_spdif_player_cleanup(void)
 {
 	platform_driver_unregister(&snd_stm_spdif_player_driver);
 }
diff -urN linux-sh4-2.6.23.17_stm23_0119-orig/sound//stm/stx7100.c linux-sh4/sound//stm/stx7100.c
--- linux-sh4-2.6.23.17_stm23_0119-orig/sound//stm/stx7100.c	2009-06-06 20:17:15.000000000 +0200
+++ linux-sh4/sound//stm/stx7100.c	2009-07-18 22:05:22.000000000 +0200
@@ -1,9 +1,9 @@
 /*
- *   STMicrolectronics STx7100/STx7109 SoC description & audio glue driver
+ *   STMicrolectronics STx7100 SoC description
  *
  *   Copyright (c) 2005-2007 STMicroelectronics Limited
  *
- *   Author: Pawel Moll <pawel.moll@st.com>
+ *   Author: Pawel MOLL <pawel.moll@st.com>
  *
  *   This program is free software; you can redistribute it and/or modify
  *   it under the terms of the GNU General Public License as published by
@@ -23,27 +23,45 @@
 
 #include <linux/init.h>
 #include <linux/module.h>
+#include <linux/stm/fdma-reqs.h>
 #include <sound/driver.h>
 #include <sound/core.h>
 
-#define COMPONENT stx7100
+#undef TRACE
 #include "common.h"
-#include "reg_7100_audcfg.h"
 
 
 
 /*
- * ALSA module parameters
+ * ALSA cards list and descriptions
  */
 
-static int index = -1; /* First available index */
-static char *id = "STx7100"; /* Default card ID */
-
-module_param(index, int, 0444);
-MODULE_PARM_DESC(index, "Index value for STx7100/STx7109 audio subsystem "
-		"card.");
-module_param(id, charp, 0444);
-MODULE_PARM_DESC(id, "ID string for STx7100/STx7109 audio subsystem card.");
+static struct snd_stm_card __initdata snd_stm_stx7100_cards[] = {
+	{
+		.index = 0,
+		.id = "PCM",
+		.short_name = "PCM output",
+		.long_name = "Digital audio output (PCM player 0)",
+	},
+	{
+		.index = 1,
+		.id = "ANALOG",
+		.short_name = "Analog output",
+		.long_name = "Analog audio output (PCM player 1)",
+	},
+	{
+		.index = 2,
+		.id = "SPDIF",
+		.short_name = "SPDIF output",
+		.long_name = "SPDIF audio output",
+	},
+	{
+		.index = 4,
+		.id = "INPUT",
+		.short_name = "PCM input",
+		.long_name = "Digital audio input (PCM reader)",
+	}
+};
 
 
 
@@ -51,10 +69,10 @@
  * Audio subsystem components & platform devices
  */
 
-/* STx7100/STx7109 audio glue */
+/* Audio IO controls */
 
-static struct platform_device stx7100_glue = {
-	.name          = "snd_stx7100_glue",
+static struct platform_device audio_outputs = {
+	.name          = "audio_outputs",
 	.id            = -1,
 	.num_resources = 1,
 	.resource      = (struct resource[]) {
@@ -69,7 +87,7 @@
 /* Frequency synthesizer */
 
 static struct platform_device fsynth = {
-	.name          = "snd_fsynth",
+	.name          = "fsynth",
 	.id            = -1,
 	.num_resources = 1,
 	.resource      = (struct resource[]) {
@@ -82,22 +100,13 @@
 	.dev.platform_data = &(struct snd_stm_fsynth_info) {
 		.channels_from = 0,
 		.channels_to = 2,
-		.value_pcm_clk_sel = 1,
-		.value_ref_clk_in = 0,
 	},
 };
 
 /* Internal DAC */
 
-static struct snd_stm_conv_int_dac_info conv_int_dac_info = {
-	/* .ver = see snd_stm_stx7100_init() */
-	.source_bus_id = "snd_pcm_player.1",
-	.channel_from = 0,
-	.channel_to = 1,
-};
-
-static struct platform_device conv_int_dac = {
-	.name          = "snd_conv_int_dac",
+static struct platform_device conv_internal_dac = {
+	.name          = "conv_internal_dac",
 	.id            = -1,
 	.num_resources = 1,
 	.resource      = (struct resource[]) {
@@ -107,24 +116,64 @@
 			.end   = 0x19210103,
 		},
 	},
-	.dev.platform_data = &conv_int_dac_info,
+	.dev.platform_data = &(struct snd_stm_conv_internal_dac_info) {
+		.name = "Internal audio DAC",
+		.card_id = "ANALOG",
+		.card_device = 0,
+		.source_bus_id = "pcm_player.1",
+	},
+};
+
+/* PCM reader */
+
+struct snd_stm_pcm_reader_info pcm_reader_info = {
+	.name = "PCM reader",
+	.card_id = "INPUT",
+	.card_device = 0,
+	.channels_num = 1,
+	.channels = (int []) { 2 },
+	.fdma_initiator = 1,
+	/* .fdma_request_line = see snd_stm_stx7100_init() */
+	.fdma_max_transfer_size = 2,
+};
+
+static struct platform_device pcm_reader = {
+	.name          = "pcm_reader",
+	.id            = -1,
+	.num_resources = 2,
+	.resource      = (struct resource[]) {
+		{
+			.flags = IORESOURCE_MEM,
+			.start = 0x18102000,
+			.end   = 0x18102027,
+		},
+		{
+			.flags = IORESOURCE_IRQ,
+			.start = 146,
+			.end   = 146,
+		},
+	},
+	.dev.platform_data = &pcm_reader_info,
 };
 
 /* PCM players */
 
 struct snd_stm_pcm_player_info pcm_player_0_info = {
-	.name = "PCM player #0 (HDMI)",
-	/* .ver = see snd_stm_stx7100_init() */
+	.name = "PCM player #0",
+	.card_id = "PCM",
 	.card_device = 0,
-	.fsynth_bus_id = "snd_fsynth",
+	.fsynth_bus_id = "fsynth",
 	.fsynth_output = 0,
-	.channels = 10,
+	/* .channels_num = see snd_stm_stx7100_init() */
+	/* .channels = see snd_stm_stx7100_init() */
+	/* .invert_sclk_edge_falling = see snd_stm_stx7100_init() */
 	.fdma_initiator = 1,
-	/* .fdma_request_line = see snd_stm_stx7100_init() */
+	/* .fdma_request_line = see snd_stm_stx7100_init() */
+	.fdma_max_transfer_size = 2,
 };
 
 static struct platform_device pcm_player_0 = {
-	.name          = "snd_pcm_player",
+	.name          = "pcm_player",
 	.id            = 0,
 	.num_resources = 2,
 	.resource      = (struct resource[]) {
@@ -144,17 +193,20 @@
 
 struct snd_stm_pcm_player_info pcm_player_1_info = {
 	.name = "PCM player #1",
-	/* .ver = see snd_stm_stx7100_init() */
-	.card_device = 1,
-	.fsynth_bus_id = "snd_fsynth",
+	.card_id = "ANALOG",
+	.card_device = 0,
+	.fsynth_bus_id = "fsynth",
 	.fsynth_output = 1,
-	.channels = 2,
+	/* .channels_num = see snd_stm_stx7100_init() */
+	/* .channels = see snd_stm_stx7100_init() */
+	/* .invert_sclk_edge_falling = see snd_stm_stx7100_init() */
 	.fdma_initiator = 1,
-	/* .fdma_request_line = see snd_stm_stx7100_init() */
+	/* .fdma_request_line = see snd_stm_stx7100_init() */
+	.fdma_max_transfer_size = 2,
 };
 
 static struct platform_device pcm_player_1 = {
-	.name          = "snd_pcm_player",
+	.name          = "pcm_player",
 	.id            = 1,
 	.num_resources = 2,
 	.resource      = (struct resource[]) {
@@ -175,17 +227,18 @@
 /* SPDIF player */
 
 struct snd_stm_spdif_player_info spdif_player_info = {
-	.name = "SPDIF player (HDMI)",
-	/* .ver = see snd_stm_stx7100_init() */
-	.card_device = 2,
-	.fsynth_bus_id = "snd_fsynth",
+	.name = "SPDIF player",
+	.card_id = "SPDIF",
+	.card_device = 0,
+	.fsynth_bus_id = "fsynth",
 	.fsynth_output = 2,
 	.fdma_initiator = 1,
-	/* .fdma_request_line = see snd_stm_stx7100_init() */
+	/* .fdma_request_line = see snd_stm_stx7100_init() */
+	.fdma_max_transfer_size = 2,
 };
 
 static struct platform_device spdif_player = {
-	.name          = "snd_spdif_player",
+	.name          = "spdif_player",
 	.id            = -1,
 	.num_resources = 2,
 	.resource      = (struct resource[]) {
@@ -205,15 +258,8 @@
 
 /* HDMI-connected I2S to SPDIF converter */
 
-static struct snd_stm_conv_i2sspdif_info conv_i2sspdif_info = {
-	/* .ver = see snd_stm_stx7100_init() */
-	.source_bus_id = "snd_pcm_player.0",
-	.channel_from = 0,
-	.channel_to = 1,
-};
-
-static struct platform_device conv_i2sspdif = {
-	.name          = "snd_conv_i2sspdif",
+static struct platform_device conv_i2s_spdif = {
+	.name          = "conv_i2s-spdif",
 	.id            = -1,
 	.num_resources = 2,
 	.resource      = (struct resource[]) {
@@ -228,341 +274,130 @@
 			.end   = 142,
 		},
 	},
-	.dev.platform_data = &conv_i2sspdif_info,
+	.dev.platform_data = &(struct snd_stm_conv_i2s_spdif_info) {
+		.name = "I2S to SPDIF converter",
+		.card_id = "PCM",
+		.card_device = 0,
+		.source_bus_id = "pcm_player.0",
+	},
 };
 
-/* PCM reader */
 
-struct snd_stm_pcm_reader_info pcm_reader_info = {
-	.name = "PCM Reader",
-	/* .ver = see snd_stm_stx7100_init() */
-	.card_device = 3,
-	.channels = 2,
-	.fdma_initiator = 1,
-	/* .fdma_request_line = see snd_stm_stx7100_init() */
-};
 
-static struct platform_device pcm_reader = {
-	.name          = "snd_pcm_reader",
-	.id            = -1,
-	.num_resources = 2,
-	.resource      = (struct resource[]) {
-		{
-			.flags = IORESOURCE_MEM,
-			.start = 0x18102000,
-			.end   = 0x18102027,
-		},
-		{
-			.flags = IORESOURCE_IRQ,
-			.start = 146,
-			.end   = 146,
-		},
-	},
-	.dev.platform_data = &pcm_reader_info,
-};
+/*
+ * Initialization and runtime configuration
+ */
 
-static struct platform_device *snd_stm_stx7100_devices[] = {
-	&stx7100_glue,
+static struct platform_device *snd_stm_stx7100_devices[] = {
+	&audio_outputs,
 	&fsynth,
+	&pcm_reader,
 	&pcm_player_0,
 	&pcm_player_1,
-	&conv_int_dac,
+	&conv_internal_dac,
 	&spdif_player,
-	&conv_i2sspdif,
-	&pcm_reader,
-};
-
-
-
-/*
- * Audio glue driver implementation
- */
-
-struct snd_stm_stx7100_glue {
-	int ver;
-
-	struct resource *mem_region;
-	void *base;
-
-	struct snd_info_entry *proc_entry;
-
-	snd_stm_magic_field;
+	&conv_i2s_spdif,
 };
 
-static void snd_stm_stx7100_glue_dump_registers(struct snd_info_entry *entry,
-		struct snd_info_buffer *buffer)
-{
-	struct snd_stm_stx7100_glue *stx7100_glue = entry->private_data;
-
-	snd_stm_assert(stx7100_glue, return);
-	snd_stm_magic_assert(stx7100_glue, return);
-
-	snd_iprintf(buffer, "--- snd_stx7100_glue ---\n");
-	snd_iprintf(buffer, "base = 0x%p\n", stx7100_glue->base);
-
-	snd_iprintf(buffer, "AUDCFG_IO_CTRL (offset 0x00) = 0x%08x\n",
-			get__710X_AUDCFG_IO_CTRL(stx7100_glue));
-
-	snd_iprintf(buffer, "\n");
-}
+static int channels_2[] = { 2 };
+static int channels_10[] = { 10 };
+static int channels_2_10[] = { 2, 4, 6, 8, 10 };
 
-static int __init snd_stm_stx7100_glue_register(struct snd_device *snd_device)
-{
-	struct snd_stm_stx7100_glue *stx7100_glue = snd_device->device_data;
-
-	snd_stm_assert(stx7100_glue, return -EINVAL);
-	snd_stm_magic_assert(stx7100_glue, return -EINVAL);
-
-	/* Enable audio outputs */
-
-	set__710X_AUDCFG_IO_CTRL(stx7100_glue,
-		mask__710X_AUDCFG_IO_CTRL__SPDIF_EN__ENABLE(stx7100_glue) |
-		mask__710X_AUDCFG_IO_CTRL__DATA1_EN__OUTPUT(stx7100_glue) |
-		mask__710X_AUDCFG_IO_CTRL__DATA0_EN__OUTPUT(stx7100_glue) |
-		mask__710X_AUDCFG_IO_CTRL__PCM_CLK_EN__OUTPUT(stx7100_glue));
-
-	/* Additional procfs info */
-
-	snd_stm_info_register(&stx7100_glue->proc_entry, "stx7100_glue",
-			snd_stm_stx7100_glue_dump_registers, stx7100_glue);
-
-	return 0;
-}
-
-static int __exit snd_stm_stx7100_glue_disconnect(struct snd_device *snd_device)
-{
-	struct snd_stm_stx7100_glue *stx7100_glue = snd_device->device_data;
-
-	snd_stm_assert(stx7100_glue, return -EINVAL);
-	snd_stm_magic_assert(stx7100_glue, return -EINVAL);
-
-	/* Remove procfs entry */
-
-	snd_stm_info_unregister(stx7100_glue->proc_entry);
-
-	/* Disable audio outputs */
-
-	set__710X_AUDCFG_IO_CTRL(stx7100_glue,
-		mask__710X_AUDCFG_IO_CTRL__SPDIF_EN__DISABLE(stx7100_glue) |
-		mask__710X_AUDCFG_IO_CTRL__DATA1_EN__INPUT(stx7100_glue) |
-		mask__710X_AUDCFG_IO_CTRL__DATA0_EN__INPUT(stx7100_glue) |
-		mask__710X_AUDCFG_IO_CTRL__PCM_CLK_EN__INPUT(stx7100_glue));
-
-	return 0;
-}
-
-static struct snd_device_ops snd_stm_stx7100_glue_snd_device_ops = {
-	.dev_register = snd_stm_stx7100_glue_register,
-	.dev_disconnect = snd_stm_stx7100_glue_disconnect,
-};
-
-static int __init snd_stm_stx7100_glue_probe(struct platform_device *pdev)
+int __init snd_stm_stx7100_init(void)
 {
 	int result = 0;
-	struct snd_stm_stx7100_glue *stx7100_glue;
-
-	snd_stm_printd(0, "--- Probing device '%s'...\n", pdev->dev.bus_id);
-
-	stx7100_glue = kzalloc(sizeof(*stx7100_glue), GFP_KERNEL);
-	if (!stx7100_glue) {
-		snd_stm_printe("Can't allocate memory "
-				"for a device description!\n");
-		result = -ENOMEM;
-		goto error_alloc;
-	}
-	snd_stm_magic_set(stx7100_glue);
-
-	result = snd_stm_memory_request(pdev, &stx7100_glue->mem_region,
-			&stx7100_glue->base);
-	if (result < 0) {
-		snd_stm_printe("Memory region request failed!\n");
-		goto error_memory_request;
-	}
-
-	/* ALSA component */
-
-	result = snd_device_new(snd_stm_card_get(), SNDRV_DEV_LOWLEVEL,
-			stx7100_glue, &snd_stm_stx7100_glue_snd_device_ops);
-	if (result < 0) {
-		snd_stm_printe("ALSA low level device creation failed!\n");
-		goto error_device;
-	}
-
-	/* Done now */
-
-	platform_set_drvdata(pdev, stx7100_glue);
-
-	snd_stm_printd(0, "--- Probed successfully!\n");
-
-	return result;
-
-error_device:
-	snd_stm_memory_release(stx7100_glue->mem_region, stx7100_glue->base);
-error_memory_request:
-	snd_stm_magic_clear(stx7100_glue);
-	kfree(stx7100_glue);
-error_alloc:
-	return result;
-}
-
-static int __exit snd_stm_stx7100_glue_remove(struct platform_device *pdev)
-{
-	struct snd_stm_stx7100_glue *stx7100_glue =
-			platform_get_drvdata(pdev);
-
-	snd_stm_assert(stx7100_glue, return -EINVAL);
-	snd_stm_magic_assert(stx7100_glue, return -EINVAL);
-
-	snd_stm_memory_release(stx7100_glue->mem_region, stx7100_glue->base);
-
-	snd_stm_magic_clear(stx7100_glue);
-	kfree(stx7100_glue);
-
-	return 0;
-}
-
-static struct platform_driver snd_stm_stx7100_glue_driver = {
-	.driver = {
-		.name = "snd_stx7100_glue",
-	},
-	.probe = snd_stm_stx7100_glue_probe,
-	.remove = snd_stm_stx7100_glue_remove,
-};
-
-
-
-/*
- * Audio initialization
- */
-
-static int __init snd_stm_stx7100_init(void)
-{
-	int result;
 	const char *soc_type;
-	struct snd_card *card;
-
-	snd_stm_printd(0, "snd_stm_stx7100_init()\n");
 
 	switch (cpu_data->type) {
 	case CPU_STB7100:
 		soc_type = "STx7100";
 
 		/* FDMA request line configuration */
-		pcm_player_0_info.fdma_request_line = 26;
-		pcm_player_1_info.fdma_request_line = 27;
-		spdif_player_info.fdma_request_line = 29;
-		pcm_reader_info.fdma_request_line = 28;
+		pcm_player_0_info.fdma_request_line = STB7100_FDMA_REQ_PCM_0;
+		pcm_player_1_info.fdma_request_line = STB7100_FDMA_REQ_PCM_1;
+		spdif_player_info.fdma_request_line = STB7100_FDMA_REQ_SPDIF;
+		pcm_reader_info.fdma_request_line = STB7100_FDMA_REQ_PCM_READ;
+
+		/* STx7100 PCM players have small hardware bug - bit SCLK_EDGE
+		 * in AUD_PCMOUT_FMT register has opposite meaning than stated
+		 * in datasheet - 0 means that PCM serial output is clocked
+		 * (changed) during falling SCLK edge (which is usually what
+		 * we want ;-) */
+		pcm_player_0_info.invert_sclk_edge_falling = 1;
+		pcm_player_1_info.invert_sclk_edge_falling = 1;
 
-		/* IP versions */
-		pcm_reader_info.ver = 1;
 		if (cpu_data->cut_major < 3) {
 			/* STx7100 cut < 3.0 */
-			pcm_player_0_info.ver = 1;
-			pcm_player_1_info.ver = 1;
+			/* Hardware bug again - in early 7100s player ignored
+			 * NUM_CH setting in AUD_PCMOUT_FMT register */
+			pcm_player_0_info.channels_num =
+				ARRAY_SIZE(channels_10);
+			pcm_player_0_info.channels = channels_10;
+			pcm_player_1_info.channels_num =
+				ARRAY_SIZE(channels_10);
+			pcm_player_1_info.channels = channels_10;
 		} else {
 			/* STx7100 cut >= 3.0 */
-			pcm_player_0_info.ver = 2;
-			pcm_player_1_info.ver = 2;
+			pcm_player_0_info.channels_num =
+				ARRAY_SIZE(channels_2_10);
+			pcm_player_0_info.channels = channels_2_10;
+			pcm_player_1_info.channels_num = ARRAY_SIZE(channels_2);
+			pcm_player_1_info.channels = channels_2;
 		}
-		conv_int_dac_info.ver = 1;
-		spdif_player_info.ver = 1;
-		conv_i2sspdif_info.ver = 1;
-
 		break;
 
 	case CPU_STB7109:
 		soc_type = "STx7109";
 
 		/* FDMA request line configuration */
-		pcm_player_0_info.fdma_request_line = 24;
-		pcm_player_1_info.fdma_request_line = 25;
-		spdif_player_info.fdma_request_line = 27;
-		pcm_reader_info.fdma_request_line = 26;
+		pcm_player_0_info.fdma_request_line = STB7109_FDMA_REQ_PCM_0;
+		pcm_player_1_info.fdma_request_line = STB7109_FDMA_REQ_PCM_1;
+		spdif_player_info.fdma_request_line = STB7109_FDMA_REQ_SPDIF;
+		pcm_reader_info.fdma_request_line = STB7109_FDMA_REQ_PCM_READ;
+
+		pcm_player_0_info.channels_num = ARRAY_SIZE(channels_2_10);
+		pcm_player_0_info.channels = channels_2_10;
+		pcm_player_1_info.channels_num = ARRAY_SIZE(channels_2);
+		pcm_player_1_info.channels = channels_2;
 
-		/* IP versions */
-		pcm_reader_info.ver = 2;
 		if (cpu_data->cut_major < 3) {
 			/* STx7109 cut < 3.0 */
-			pcm_player_0_info.ver = 3;
-			pcm_player_1_info.ver = 3;
-		} else {
-			/* STx7109 cut >= 3.0 */
-			pcm_player_0_info.ver = 4;
-			pcm_player_1_info.ver = 4;
+			/* PCM players of early 7109s have small hardware
+			 * bug - bit SCLK_EDGE in AUD_PCMOUT_FMT register has
+			 * opposite meaning than stated in datasheet - 0 means
+			 * that PCM serial output is clocked (changed) during
+			 * falling SCLK edge (which is usually what we
+			 * want ;-) */
+			pcm_player_0_info.invert_sclk_edge_falling = 1;
+			pcm_player_1_info.invert_sclk_edge_falling = 1;
 		}
-		conv_int_dac_info.ver = 2;
-		spdif_player_info.ver = 2;
-		conv_i2sspdif_info.ver = 2;
-
 		break;
 
 	default:
-		snd_stm_printe("Not supported (other than STx7100 or STx7109)"
-				" SOC detected!\n");
+		/* Unknown CPU! */
+		snd_stm_printe("Not supported CPU detected!\n");
 		result = -EINVAL;
-		goto error_soc_type;
-	}
-
-	result = platform_driver_register(&snd_stm_stx7100_glue_driver);
-	if (result != 0) {
-		snd_stm_printe("Failed to register audio glue driver!\n");
-		goto error_driver_register;
+		break;
 	}
 
-	card = snd_stm_card_new(index, id, THIS_MODULE);
-	if (card == NULL) {
-		snd_stm_printe("ALSA card creation failed!\n");
-		result = -ENOMEM;
-		goto error_card_new;
-	}
-	strcpy(card->driver, soc_type);
-	snprintf(card->shortname, 31, "%s audio subsystem", soc_type);
-	snprintf(card->longname, 79, "STMicroelectronics %s cut %d.%d SOC "
-			"audio subsystem", soc_type, cpu_data->cut_major,
-			cpu_data->cut_minor);
-
-	result = snd_stm_add_platform_devices(snd_stm_stx7100_devices,
-			ARRAY_SIZE(snd_stm_stx7100_devices));
-	if (result != 0) {
-		snd_stm_printe("Failed to add platform devices!\n");
-		goto error_add_devices;
-	}
+	if (result == 0)
+		result = snd_stm_cards_init(soc_type,
+				snd_stm_stx7100_cards,
+				ARRAY_SIZE(snd_stm_stx7100_cards));
+
+	if (result == 0) {
+		result = snd_stm_add_plaform_devices(snd_stm_stx7100_devices,
+				ARRAY_SIZE(snd_stm_stx7100_devices));
 
-	result = snd_stm_card_register();
-	if (result != 0) {
-		snd_stm_printe("Failed to register ALSA cards!\n");
-		goto error_card_register;
+		if (result != 0)
+			snd_stm_cards_free();
 	}
 
-	return 0;
-
-error_card_register:
-	snd_stm_remove_platform_devices(snd_stm_stx7100_devices,
-			ARRAY_SIZE(snd_stm_stx7100_devices));
-error_add_devices:
-	snd_stm_card_free();
-error_card_new:
-	platform_driver_unregister(&snd_stm_stx7100_glue_driver);
-error_driver_register:
-error_soc_type:
 	return result;
 }
 
-static void __exit snd_stm_stx7100_exit(void)
+void __exit snd_stm_stx7100_cleanup(void)
 {
-	snd_stm_printd(0, "snd_stm_stx7100_exit()\n");
-
-	snd_stm_card_free();
-
-	snd_stm_remove_platform_devices(snd_stm_stx7100_devices,
-			ARRAY_SIZE(snd_stm_stx7100_devices));
-
-	platform_driver_unregister(&snd_stm_stx7100_glue_driver);
+	snd_stm_remove_plaform_devices(snd_stm_stx7100_devices,
+			ARRAY_SIZE(snd_stm_stx7100_devices));
 }
-
-MODULE_AUTHOR("Pawel Moll <pawel.moll@st.com>");
-MODULE_DESCRIPTION("STMicroelectronics STx7100/STx7109 audio driver");
-MODULE_LICENSE("GPL");
-
-module_init(snd_stm_stx7100_init);
-module_exit(snd_stm_stx7100_exit);
diff -rcN linux-sh4-2.6.23.17_stm23_0119-orig/sound//stm/synchro.c linux-sh4/sound//stm/synchro.c
*** linux-sh4-2.6.23.17_stm23_0119-orig/sound//stm/synchro.c	1970-01-01 01:00:00.000000000 +0100
--- linux-sh4/sound//stm/synchro.c	2009-07-18 23:02:14.000000000 +0200
***************
*** 0 ****
--- 1,41 ----
+ /*
+  *   Audio playback synchronization routines for STMicroelectronics' SoCs
+  *
+  *   Copyright (c) 2005-2007 STMicroelectronics Limited
+  *
+  *   Author: Pawel MOLL <pawel.moll@st.com>
+  *
+  *   This program is free software; you can redistribute it and/or modify
+  *   it under the terms of the GNU General Public License as published by
+  *   the Free Software Foundation; either version 2 of the License, or
+  *   (at your option) any later version.
+  *
+  *   This program is distributed in the hope that it will be useful,
+  *   but WITHOUT ANY WARRANTY; without even the implied warranty of
+  *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  *   GNU General Public License for more details.
+  *
+  *   You should have received a copy of the GNU General Public License
+  *   along with this program; if not, write to the Free Software
+  *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+  *
+  */
+ 
+ #include <linux/init.h>
+ 
+ #undef TRACE /* See common.h debug features */
+ #define MAGIC 9 /* See common.h debug features */
+ #include "common.h"
+ 
+ /*
+  * Initialization
+  */
+ 
+ int __init snd_stm_synchro_init(void)
+ {
+ 	return 0;
+ }
+ 
+ void snd_stm_synchro_cleanup(void)
+ {
+ }
diff -rcN linux-sh4-2.6.23.17_stm23_0119-orig/include/sound//core.h linux-sh4/include/sound//core.h
*** linux-sh4-2.6.23.17_stm23_0119-orig/include/sound//core.h	2007-10-09 22:31:38.000000000 +0200
--- linux-sh4/include/sound//core.h	2009-07-18 21:46:34.000000000 +0200
***************
*** 451,455 ****
--- 451,456 ----
  const struct snd_pci_quirk *
  snd_pci_quirk_lookup(struct pci_dev *pci, const struct snd_pci_quirk *list);
  
+ int snd_get_minor(int type, int card, int dev);
  
  #endif /* __SOUND_CORE_H */
diff -rcN linux-sh4-2.6.23.17_stm23_0119-orig/include/sound//stm.h linux-sh4/include/sound//stm.h
*** linux-sh4-2.6.23.17_stm23_0119-orig/include/sound//stm.h	2009-06-06 20:17:15.000000000 +0200
--- linux-sh4/include/sound//stm.h	2009-07-18 22:35:56.000000000 +0200
***************
*** 3,9 ****
   *
   *   Copyright (c) 2005-2007 STMicroelectronics Limited
   *
!  *   Author: Pawel Moll <pawel.moll@st.com>
   *
   *   This program is free software; you can redistribute it and/or modify
   *   it under the terms of the GNU General Public License as published by
--- 3,9 ----
   *
   *   Copyright (c) 2005-2007 STMicroelectronics Limited
   *
!  *   Author: Pawel MOLL <pawel.moll@st.com>
   *
   *   This program is free software; you can redistribute it and/or modify
   *   it under the terms of the GNU General Public License as published by
***************
*** 24,30 ****
  #ifndef __SOUND_STM_H
  #define __SOUND_STM_H
  
- #include <linux/i2c.h>
  #include <sound/driver.h>
  #include <sound/core.h>
  
--- 24,29 ----
***************
*** 34,82 ****
   * Converters (DAC, ADC, I2S to SPDIF, SPDIF to I2S, etc.)
   */
  
! /* Link type (format) description */
! #define SND_STM_FORMAT__I2S              0x00000001
! #define SND_STM_FORMAT__LEFT_JUSTIFIED   0x00000002
! #define SND_STM_FORMAT__RIGHT_JUSTIFIED  0x00000003
! #define SND_STM_FORMAT__SPDIF            0x00000004
  #define SND_STM_FORMAT__MASK             0x0000000f
  
  /* Following values are valid only for I2S, Left Justified and
   * Right justified formats and can be bit-added to format;
   * they define size of one subframe (channel) transmitted.
   * For SPDIF the frame size is fixed and defined by standard. */
! #define SND_STM_FORMAT__SUBFRAME_32_BITS 0x00000010
! #define SND_STM_FORMAT__SUBFRAME_16_BITS 0x00000020
! #define SND_STM_FORMAT__SUBFRAME_MASK    0x000000f0
  
- /* Converter operations
-  * All converter should be disabled and muted till explicitly
-  * enabled/unmuted. */
- 
- struct snd_stm_conv_converter;
- 
- struct snd_stm_conv_ops {
  	/* Configuration */
! 	unsigned int (*get_format)(void *priv);
! 	int (*get_oversampling)(void *priv);
  
  	/* Operations */
! 	int (*set_enabled)(int enabled, void *priv);
! 	int (*set_muted)(int muted, void *priv);
  };
  
! /* Registers new converter
!  * Converters sharing the same group name shall use the same input format
!  * and oversampling value - they usually should represent one "output";
!  * when more than one group is connected to the same source, active one
!  * will be selectable using "Route" ALSA control.
!  * Returns negative value on error or unique converter index number (>=0) */
! struct snd_stm_conv_converter *snd_stm_conv_register_converter(
! 		const char *group, struct snd_stm_conv_ops *ops, void *priv,
! 		struct bus_type *source_bus, const char *source_bus_id,
! 		int source_channel_from, int source_channel_to, int *index);
  
- int snd_stm_conv_unregister_converter(struct snd_stm_conv_converter *converter);
  
  
  /*
--- 33,75 ----
   * Converters (DAC, ADC, I2S to SPDIF, SPDIF to I2S, etc.)
   */
  
! /* Link type (format) description
!  * Please note, that 0 value means I2S with 32 bits per
!  * subframe (channel) and is a default setting. */
! #define SND_STM_FORMAT__I2S              0x00000000
! #define SND_STM_FORMAT__LEFT_JUSTIFIED   0x00000001
! #define SND_STM_FORMAT__RIGHT_JUSTIFIED  0x00000002
! #define SND_STM_FORMAT__SPDIF            0x00000003
  #define SND_STM_FORMAT__MASK             0x0000000f
  
  /* Following values are valid only for I2S, Left Justified and
   * Right justified formats and can be bit-added to format;
   * they define size of one subframe (channel) transmitted.
   * For SPDIF the frame size is fixed and defined by standard. */
! #define SND_STM_FORMAT__OUTPUT_SUBFRAME_32_BITS 0x00000000
! #define SND_STM_FORMAT__OUTPUT_SUBFRAME_16_BITS 0x00000010
! #define SND_STM_FORMAT__OUTPUT_SUBFRAME_MASK    0x000000f0
! 
! /* Converter handle */
! struct snd_stm_conv {
! 	const char *name;
  
  	/* Configuration */
! 	unsigned int (*get_format)(struct snd_stm_conv *conv);
! 	int (*get_oversampling)(struct snd_stm_conv *conv);
  
  	/* Operations */
! 	int (*enable)(struct snd_stm_conv *conv);
! 	int (*disable)(struct snd_stm_conv *conv);
! 	int (*mute)(struct snd_stm_conv *conv);
! 	int (*unmute)(struct snd_stm_conv *conv);
! 
! 	/* Master (must be enabled prior to this one) */
! 	struct snd_stm_conv *master;
  };
  
! int snd_stm_conv_attach(struct snd_stm_conv *conv, struct device *source);
  
  
  
  /*
***************
*** 89,188 ****
   * as a platform data:
   *
   * static struct i2c_board_info external_dac __initdata = {
!  * 	I2C_BOARD_INFO("snd_conv_i2c", <I2C address>),
   * 	.type = "<i.e. chip model>",
   * 	.platform_data = &(struct snd_stm_conv_i2c_info) {
   * 		<see below>
   * 	},
   * };
   *
!  * and add it:
!  *
!  * i2c_register_board_info(<I2C bus number>, &external_dac, 1);
   *
!  * If you wish to perform some actions on the device before it
!  * is being used, you may define "init" callback, which will
!  * be called with i2c_client pointer during driver probe.
   */
- struct snd_stm_conv_i2c_info {
- 	const char *group;
- 
- 	const char *source_bus_id;
- 	int channel_from, channel_to;
- 	unsigned int format;
- 	int oversampling;
  
! 	int (*init)(struct i2c_client *client, void *priv);
! 	void *priv;
  
- 	int enable_supported;
  	const char *enable_cmd;
  	int enable_cmd_len;
  	const char *disable_cmd;
  	int disable_cmd_len;
- 
- 	int mute_supported;
  	const char *mute_cmd;
  	int mute_cmd_len;
  	const char *unmute_cmd;
  	int unmute_cmd_len;
  };
  
! /* GPIO-controlled DAC/ADC generic implementation
   *
!  * Define platform device named "snd_conv_gpio", pass
   * following structure as platform_data and add it in normal way :-) */
- struct snd_stm_conv_gpio_info {
- 	const char *group;
- 
- 	const char *source_bus_id;
- 	int channel_from, channel_to;
- 	unsigned int format;
- 	int oversampling;
- 
- 	int enable_supported;
- 	unsigned enable_gpio;
- 	int enable_value;
- 
- 	int mute_supported;
- 	unsigned mute_gpio;
- 	int mute_value;
- };
- 
- /* EPLD-controlled DAC/ADC generic implementation
-  *
-  * Define platform device named "snd_conv_epld", pass
-  * following structure as platform_data and add it in normal way :-) */
- struct snd_stm_conv_epld_info {
- 	const char *group;
- 
- 	const char *source_bus_id;
- 	int channel_from, channel_to;
- 	unsigned int format;
- 	int oversampling;
- 
- 	int enable_supported;
- 	unsigned enable_offset;
- 	unsigned enable_mask;
- 	unsigned enable_value;
- 	unsigned disable_value;
- 
- 	int mute_supported;
- 	unsigned mute_offset;
- 	unsigned mute_mask;
- 	unsigned mute_value;
- 	unsigned unmute_value;
- };
  
! /* Dummy converter - use it (as a platform device) to define format or
!  * oversampling only */
! struct snd_stm_conv_dummy_info {
! 	const char *group;
! 
! 	const char *source_bus_id;
! 	int channel_from, channel_to;
! 	unsigned int format;
! 	int oversampling;
  };
  
  #endif
--- 82,131 ----
   * as a platform data:
   *
   * static struct i2c_board_info external_dac __initdata = {
!  * 	.driver_name = "snd_conv_i2c",
   * 	.type = "<i.e. chip model>",
+  * 	.addr = <I2C address>
   * 	.platform_data = &(struct snd_stm_conv_i2c_info) {
   * 		<see below>
   * 	},
   * };
   *
!  * and add it using:
   *
!  * i2c_new_device(i2c_get_adapter(<i2c adapter (bus) id>), &external_dac);
   */
  
! struct snd_stm_conv_i2c_info {
! 	const char *name;
! 	const char *card_id;
  
  	const char *enable_cmd;
  	int enable_cmd_len;
  	const char *disable_cmd;
  	int disable_cmd_len;
  	const char *mute_cmd;
  	int mute_cmd_len;
  	const char *unmute_cmd;
  	int unmute_cmd_len;
  };
  
! /* GPIO-controlled (STPIO interface) DAC/ADC generic implementation
   *
!  * Define platform device named "snd_conv_stpio", pass
   * following structure as platform_data and add it in normal way :-) */
  
! struct snd_stm_conv_stpio_info {
! 	const char *name;
! 	const char *card_id;
! 
! 	struct stpio_pin *enable_pin;
! 	unsigned int enable_value;
! 	struct stpio_pin *disable_pin;
! 	unsigned int disable_value;
! 	struct stpio_pin *mute_pin;
! 	unsigned int mute_value;
! 	struct stpio_pin *unmute_pin;
! 	unsigned int unmute_value;
  };
  
  #endif
diff -rcN linux-sh4-2.6.23.17_stm23_0119-orig/include/linux/stm/registers//asc.h linux-sh4/include/linux/stm/registers//asc.h
*** linux-sh4-2.6.23.17_stm23_0119-orig/include/linux/stm/registers//asc.h	1970-01-01 01:00:00.000000000 +0100
--- linux-sh4/include/linux/stm/registers//asc.h	2009-06-10 11:15:48.000000000 +0200
***************
*** 0 ****
--- 1,350 ----
+ #ifndef __STM_REGISTERS_ASC_H
+ #define __STM_REGISTERS_ASC_H
+ 
+ 
+ 
+ /* ASC baudrate generator */
+ 
+ #define ASC_BAUDRATE 0x00 /* RW, reset value: 1 */
+ /* This register is the dual function baudrate generator and reload value register. A read
+  * from this register returns the content of the 16-bit counter/accumulator; writing to it
+  * updates the 16-bit reload register.
+  * If bit ASC_CTRL.RUN is 1, then any value written in the ASC_BaudRate register
+  * is immediately copied to the timer. However, if the RUN bit is 0 when the register is
+  * written, then the timer is not reloaded until the first comms clock cycle after the RUN
+  * bit is 1.
+  * The mode of operation of the baudrate generator depends on the setting of bit
+  * ASC_CTRL.BAUDMODE.
+  * Mode 0
+  * When bit ASC_CTRL.BAUDMODE is set to 0, the baudrate and the required reload
+  * value for a given baudrate can be determined by the following formulae:
+  * where: ASCBaudRate represents the content of the ASC_BaudRate register,
+  * taken as an unsigned 16-bit integer.
+  * fcomms is the frequency of the comms clock (clock channel CLK_IC_DIV2).
+  * Mode 0 should be used for all baudrates below 19.2 Kbaud.
+  * Table 39 lists commonly used baudrates with the required reload values and the
+  * approximate deviation errors for an example baudrate with a comms clock of
+  * 100 MHz.
+  * Mode 1
+  * When bit ASC_CTRL.BAUDMODE is set to 1, the baudrate is given by:
+  * where: fcomms is the comms clock frequency and ASCBaudRate is the value written to
+  * the ASC_BaudRate register. Mode 1 should be used for baudrates of 19.2 Kbytes
+  * and above as it has a lower deviation error than mode 0 at higher frequencies. */
+ 
+ #define ASC_BAUDRATE__RELOAD_VAL__SHIFT 0
+ #define ASC_BAUDRATE__RELOAD_VAL__MASK  0x0000ffff
+ 
+ 
+ 
+ /* ASC transmit buffer */
+ 
+ #define ASC_TX_BUF 0x04 /* W, reset value: 0 */
+ /* A transmission is started by writing to the transmit buffer register ASC_TX_BUF.
+  * Serial data transmission is only possible when the baudrate generator bit
+  * ASC_CTRL.RUN is set to 1.
+  * Data transmission is double buffered or uses a FIFO, so a new character may be
+  * written to the transmit buffer register before the transmission of the previous
+  * character is complete. This allows characters to be sent back to back without gaps. */
+ 
+ #define ASC_TX_BUF__TD__SHIFT 0
+ #define ASC_TX_BUF__TD__MASK  0x000001ff
+ /* TD[8]:
+  * Transmit buffer data D8, or parity bit, or wake up bit or undefined depending on the operating
+  * mode (the setting of field ASC_CTRL.MODE).
+  * If the MODE field selects an 8-bit frame then this bit should be written as 0.
+  * TD[7]:
+  * Transmit buffer data D7, or parity bit depending on the operating mode (the setting of field
+  * ASC_CTRL.MODE).
+  * TD[6:0]: transmit buffer data D6 to D0 */
+ 
+ 
+ 
+ /* ASC receive buffer */
+ 
+ #define ASC_RX_BUF 0x08 /* R, reset value: 0 */
+ /* Serial data reception is only possible when the baudrate generator bit
+  * ASC_CTRL.RUN is set to 1. */
+ 
+ #define ASC_RX_BUF__RD__SHIFT 0
+ #define ASC_RX_BUF__RD__MASK  0x000001ff
+ /* RD[8]:
+  * Receive buffer data D8, or parity error bit, or wake up bit depending on the operating mode (the
+  * setting of field ASC_CTRL.MODE)
+  * If the MODE field selects an 8-bit frame then this bit is undefined. Software should ignore this
+  * bit when reading 8-bit frames
+  * RD[7]:
+  * Receive buffer data D7, or parity error bit depending on the operating mode (the setting of field
+  * ASC_CTRL.MODE)
+  * RD[6:0]:
+  * Receive buffer data D6 to D0 */
+ 
+ 
+ 
+ /* ASC control */
+ 
+ #define ASC_CTRL 0x0c /* RW, reset value: 0 */
+ /* This register controls the operating mode of the ASC and contains control bits for
+  * mode and error check selection, and status flags for error identification.
+  * Programming the mode control field (MODE) to one of the reserved combinations
+  * may result in unpredictable behavior. Serial data transmission or reception is only
+  * possible when the baudrate generator run bit (RUN) is set to 1. When the RUN bit is
+  * set to 0, TxD is 1. Setting the RUN bit to 0 immediately freezes the state of the
+  * transmitter and receiver. This should only be done when the ASC is idle.
+  * Serial data transmission or reception is only possible when the baudrate generator
+  * RUN bit is set to 1. A transmission is started by writing to the transmit buffer register
+  * ASC_Tx_Buf. */
+ 
+ #define ASC_CTRL__MODE__SHIFT 0
+ #define ASC_CTRL__MODE__MASK  0x00000007
+ /* MODE: ASC mode control
+  * 000: reserved	001: 8-bit data
+  * 010: reserved	011: 7-bit data + parity
+  * 100: 9-bit data	101: 8-bit data + wake up bit
+  * 110: reserved	111: 8-bit data + parity */
+ 
+ #define ASC_CTRL__STOPBITS__SHIFT 3
+ #define ASC_CTRL__STOPBITS__MASK  0x00000003
+ /* STOPBITS: number of stop bits selection
+  * 00: 0.5 stop bits	01: 1 stop bits
+  * 10: 1.5 stop bits	11: 2 stop bits */
+ 
+ #define ASC_CTRL__PARITYODD__SHIFT 5
+ #define ASC_CTRL__PARITYODD__MASK  0x00000001
+ /* PARITYODD: parity selection
+  * 0: even parity (parity bit set on odd number of 1's in data)
+  * 1: odd parity (parity bit set on even number of 1's in data) */
+ 
+ #define ASC_CTRL__LOOPBACK__SHIFT 6
+ #define ASC_CTRL__LOOPBACK__MASK  0x00000001
+ /* LOOPBACK: loopback mode enable bit
+  * 0: standard transmit/receive mode	1: loopback mode enabled */
+ 
+ #define ASC_CTRL__RUN__SHIFT 7
+ #define ASC_CTRL__RUN__MASK  0x00000001
+ /* RUN: baudrate generator run bit
+  * 0: baudrate generator disabled (ASC inactive)	1: baudrate generator enabled */
+ 
+ #define ASC_CTRL__RX_EN__SHIFT 8
+ #define ASC_CTRL__RX_EN__MASK  0x00000001
+ /* RX_EN: receiver enable bit
+  * 0: receiver disabled	1: receiver enabled */
+ 
+ #define ASC_CTRL__SC_EN__SHIFT 9
+ #define ASC_CTRL__SC_EN__MASK  0x00000001
+ /* SC_EN: smartcard enable
+  * 0: smartcard mode disabled	1: smartcard mode enabled */
+ 
+ #define ASC_CTRL__FIFO_EN__SHIFT 10
+ #define ASC_CTRL__FIFO_EN__MASK  0x00000001
+ /* FIFO_EN: FIFO enable:
+  * 0: FIFO disabled	1: FIFO enabled */
+ 
+ #define ASC_CTRL__CTS_EN__SHIFT 11
+ #define ASC_CTRL__CTS_EN__MASK  0x00000001
+ /* CTS_EN: CTS enable
+  * 0: CTS ignored		1: CTS enabled */
+ 
+ #define ASC_CTRL__BAUDMODE__SHIFT 12
+ #define ASC_CTRL__BAUDMODE__MASK  0x00000001
+ /* BAUDMODE: baudrate generation mode
+  * 0: baud counter decrements, ticks when it reaches 1	1: baud counter added to itself, ticks when
+  * there is a carry */
+ 
+ #define ASC_CTRL__NACK_DISABLE__SHIFT 13
+ #define ASC_CTRL__NACK_DISABLE__MASK  0x00000001
+ /* NACK_DISABLE: NACKing behavior control
+  * 0: NACKing behavior in smartcard mode	1: no NACKing behavior in smartcard mode */
+ 
+ 
+ 
+ /* ASC interrupt enable */
+ 
+ #define ASC_INT_EN 0x10 /* RW, reset value: 0 */
+ 
+ #define ASC_INT_EN__RX_BUFFULL__SHIFT 0
+ #define ASC_INT_EN__RX_BUFFULL__MASK  0x00000001
+ /* RX_BUFFULL: receiver buffer full interrupt enable
+  * 0: receiver buffer full interrupt disable	1: receiver buffer full interrupt enable */
+ 
+ #define ASC_INT_EN__TX_EMPTY__SHIFT 1
+ #define ASC_INT_EN__TX_EMPTY__MASK  0x00000001
+ /* TX_EMPTY: transmitter empty interrupt enable
+  * 0: transmitter empty interrupt disable	1: transmitter empty interrupt enable */
+ 
+ #define ASC_INT_EN__TX_HALFEMPTY__SHIFT 2
+ #define ASC_INT_EN__TX_HALFEMPTY__MASK  0x00000001
+ /* TX_HALFEMPTY: transmitter buffer half empty interrupt enable
+  * 0: transmitter buffer half empty interrupt disable	1: transmitter buffer half empty interrupt
+  * enable */
+ 
+ #define ASC_INT_EN__PARITY_ERR__SHIFT 3
+ #define ASC_INT_EN__PARITY_ERR__MASK  0x00000001
+ /* PARITY_ERR: parity error interrupt enable:
+  * 0: parity error interrupt disable	1: parity error interrupt enable */
+ 
+ #define ASC_INT_EN__FRAME_ERR__SHIFT 4
+ #define ASC_INT_EN__FRAME_ERR__MASK  0x00000001
+ /* FRAME_ERR: framing error interrupt enable
+  * 0: framing error interrupt disable	1: framing error interrupt enable */
+ 
+ #define ASC_INT_EN__OVERRUN_ERROR__SHIFT 5
+ #define ASC_INT_EN__OVERRUN_ERROR__MASK  0x00000001
+ /* OVERRUN_ERR: overrun error interrupt enable
+  * 0: overrun error interrupt disable	1: overrun error interrupt enable */
+ 
+ #define ASC_INT_EN__TIMEOUT_NOTEMPTY__SHIFT 6
+ #define ASC_INT_EN__TIMEOUT_NOTEMPTY__MASK  0x00000001
+ /* TIMEOUT_NOTEMPTY: time out when not empty interrupt enable
+  * 0: time out when input FIFO or buffer not empty interrupt disable
+  * 1: time out when input FIFO or buffer not empty interrupt enable */
+ 
+ #define ASC_INT_EN__TIMEOUT_IDLE__SHIFT 7
+ #define ASC_INT_EN__TIMEOUT_IDLE__MASK  0x00000001
+ /* TIMEOUT_IDLE: time out when the receiver FIFO is empty interrupt enable
+  * 0: time out when the input FIFO or buffer is empty interrupt disable
+  * 1: time out when the input FIFO or buffer is empty interrupt enable */
+ 
+ #define ASC_INT_EN__RX_HALFFULL__SHIFT 8
+ #define ASC_INT_EN__RX_HALFFULL__MASK  0x00000001
+ /* RX_HALFFULL: receiver FIFO is half full interrupt enable
+  * 0: receiver FIFO is half full interrupt disable	1: receiver FIFO is half full interrupt enable */
+ 
+ 
+ 
+ /* ASC interrupt status */
+ 
+ #define ASC_STA 0x14 /* R, reset value: 3 (Rx buffer full and Tx buffer empty) */
+ 
+ #define ASC_STA__RX_BUFFULL__SHIFT 0
+ #define ASC_STA__RX_BUFFULL__MASK  0x00000001
+ /* RX_BUFFULL: Receiver FIFO not empty (FIFO operation) or buffer full (double buffered
+  * operation)
+  * 0: receiver FIFO is empty or buffer is not full	1: receiver FIFO is not empty or buffer is full */
+ 
+ #define ASC_STA__TX_EMPTY__SHIFT 1
+ #define ASC_STA__TX_EMPTY__MASK  0x00000001
+ /* TX_EMPTY: Transmitter empty flag
+  * 0: transmitter is not empty	1: transmitter is empty */
+ 
+ #define ASC_STA__TX_HALFEMPTY__SHIFT 2
+ #define ASC_STA__TX_HALFEMPTY__MASK  0x00000001
+ /* TX_HALFEMPTY: Transmitter FIFO at least half empty flag or buffer empty
+  * 0: the FIFOs are enabled and the transmitter FIFO is more than half full (more than eight
+  * characters) or the FIFOs are disabled and the transmit buffer is not empty.
+  * 1: the FIFOs are enabled and the transmitter FIFO is at least half empty (eight or less
+  * characters) or the FIFOs are disabled and the transmit buffer is empty */
+ 
+ #define ASC_STA__PARITY_ERR__SHIFT 3
+ #define ASC_STA__PARITY_ERR__MASK  0x00000001
+ /* PARITY_ERR: Input parity error flag:
+  * 0: no parity error	1: parity error */
+ 
+ #define ASC_STA__FRAME_ERR__SHIFT 4
+ #define ASC_STA__FRAME_ERR__MASK  0x00000001
+ /* FRAME_ERR: Input frame error flag
+  * 0: no framing error	1: framing error (stop bits not found) */
+ 
+ #define ASC_STA__OVERRUN_ERR__SHIFT 5
+ #define ASC_STA__OVERRUN_ERR__MASK  0x00000001
+ /* OVERRUN_ERR: Overrun error flag
+  * 0: no overrun error
+  * 1: overrun error, that is, data received when the input buffer is full */
+ 
+ #define ASC_STA__TONE__SHIFT 6
+ #define ASC_STA__TONE__MASK  0x00000001
+ /* TONE: Time out when the receiver FIFO or buffer is not empty
+  * 0: no time out or the receiver FIFO or buffer is empty
+  * 1: time out when the receiver FIFO or buffer is not empty */
+ 
+ #define ASC_STA__TOE__SHIFT 7
+ #define ASC_STA__TOE__MASK  0x00000001
+ /* TOE: Time out when the receiver FIFO or buffer is empty
+  * 0: no time out or the receiver FIFO or buffer is not empty
+  * 1: time out when the receiver FIFO or buffer is empty */
+ 
+ #define ASC_STA__RX_HALFFULL__SHIFT 8
+ #define ASC_STA__RX_HALFFULL__MASK  0x00000001
+ /* RX_HALFFULL: Receiver FIFO is half full
+  * 0: the receiver FIFO contains eight characters or less
+  * 1: the receiver FIFO contains more than eight characters */
+ 
+ #define ASC_STA__TX_FULL__SHIFT 9
+ #define ASC_STA__TX_FULL__MASK  0x00000001
+ /* TX_FULL: Transmitter FIFO or buffer is full
+  * 0: the FIFOs are enabled and the transmitter FIFO is empty or contains less than 16
+  * characters or the FIFOs are disabled and the transmit buffer is empty
+  * 1: the FIFOs are enabled and the transmitter FIFO contains 16 characters or the FIFOs are
+  * disabled and the transmit buffer is full */
+ 
+ #define ASC_STA__NKD__SHIFT 10
+ #define ASC_STA__NKD__MASK  0x00000001
+ /* NKD: Transmission failure acknowledgement by receiver in smartcard mode.
+  * 0: data transmitted successfully
+  * 1: data transmission unsuccessful (data NACKed by smartcard) */
+ 
+ 
+ 
+ /* ASC guard time */
+ 
+ #define ASC_GUARDTIME 0x18 /* RW, reset value: 0 */
+ /* This register defines the number of stop bits and the delay of the assertion of the
+  * interrupt TX_EMPTY by a programmable number of baud clock ticks. The value in the
+  * register is the number of baud clock ticks to delay assertion of TX_EMPTY. This
+  * value must be in the range 0 to 511. */
+ 
+ #define ASC_GUARDTIME__GUARDTIME__SHIFT 0
+ #define ASC_GUARDTIME__GUARDTIME__MASK  0x000001ff
+ 
+ 
+ 
+ /* ASC time out */
+ 
+ #define ASC_TIMEOUT 0x1c /* RW, reset value: 0 */
+ /* The time out period in baudrate ticks. The ASC contains an 8-bit time out counter,
+  * which reloads from ASC_TIMEOUT when one or more of the following is true:
+  * If none of these conditions hold, the counter decrements to 0 at every baudrate tick.
+  * The TONE (time out when not empty) bit of the ASC_STA register is 1 when the
+  * input FIFO is not empty and the time out counter is zero. The TIMEOUT_IDLE bit of
+  * the ASC_STA register is 1 when the input FIFO is empty and the time out counter is
+  * zero.
+  * When the software has emptied the input FIFO, the time out counter resets and starts
+  * decrementing. If no more characters arrive, when the counter reaches zero the
+  * TIMEOUT_IDLE bit of the ASC_STA register is set. */
+ 
+ #define ASC_TIMEOUT__TIMEOUT__SHIFT 0
+ #define ASC_TIMEOUT__TIMEOUT__MASK  0x000000ff
+ 
+ 
+ 
+ /* ASC transmit FIFO reset */
+ 
+ #define ASC_TX_RST 0x20 /* W */
+ /* Reset the transmit FIFO. Registers ASC_TX_RST have no storage associated with
+  * them. A write of any value to these registers resets the corresponding transmitter
+  * FIFO. */
+ 
+ 
+ 
+ /* ASC receive FIFO reset */
+ 
+ #define ASC_RX_RST 0x24 /* W */
+ /* Reset the receiver FIFO. The registers ASC_RX_RST have no actual storage
+  * associated with them. A write of any value to one of these registers resets the
+  * corresponding receiver FIFO. */
+ 
+ 
+ 
+ /* ASC number of retries on transmission */
+ 
+ #define ASC_RETRIES 0x28 /* RW, reset value: 1 */
+ /* Defines the number of transmissions attempted on a piece of data before the UART
+  * discards the data. If a transmission still fails after NUM_RETRIES, the NKD bit is set
+  * in the ASC_STA register where it can be read and acted on by software. This
+  * register does not have to be reinitialized after a NACK error. */
+ 
+ #define ASC_RETRIES__NUM_RETRIES__SHIFT 0
+ #define ASC_RETRIES__NUM_RETRIES__MASK  0x000000ff
+ 
+ 
+ 
+ #endif
diff -rcN linux-sh4-2.6.23.17_stm23_0119-orig/include/linux/stm/registers//audcfg_adac.h linux-sh4/include/linux/stm/registers//audcfg_adac.h
*** linux-sh4-2.6.23.17_stm23_0119-orig/include/linux/stm/registers//audcfg_adac.h	1970-01-01 01:00:00.000000000 +0100
--- linux-sh4/include/linux/stm/registers//audcfg_adac.h	2009-06-10 11:15:48.000000000 +0200
***************
*** 0 ****
--- 1,39 ----
+ #ifndef __STM_REGISTERS_AUDCFG_ADAC_H
+ #define __STM_REGISTERS_AUDCFG_ADAC_H
+ 
+ 
+ 
+ #define AUDCFG_ADAC_CTRL 0x00
+ 
+ #define AUDCFG_ADAC_CTRL__NRST__SHIFT         0
+ #define AUDCFG_ADAC_CTRL__NRST__MASK          0x1
+ #define AUDCFG_ADAC_CTRL__NRST__VALUE__RESET  0x0
+ #define AUDCFG_ADAC_CTRL__NRST__VALUE__NORMAL 0x1
+ 
+ #define AUDCFG_ADAC_CTRL__MODE__SHIFT          1
+ #define AUDCFG_ADAC_CTRL__MODE__MASK           0x3
+ #define AUDCFG_ADAC_CTRL__MODE__VALUE__DEFAULT 0x0
+ 
+ #define AUDCFG_ADAC_CTRL__NSB__SHIFT             3
+ #define AUDCFG_ADAC_CTRL__NSB__MASK              0x1
+ #define AUDCFG_ADAC_CTRL__NSB__VALUE__POWER_DOWN 0x0
+ #define AUDCFG_ADAC_CTRL__NSB__VALUE__NORMAL     0x1
+ 
+ #define AUDCFG_ADAC_CTRL__SOFTMUTE__SHIFT         4
+ #define AUDCFG_ADAC_CTRL__SOFTMUTE__MASK          0x1
+ #define AUDCFG_ADAC_CTRL__SOFTMUTE__VALUE__NORMAL 0x0
+ #define AUDCFG_ADAC_CTRL__SOFTMUTE__VALUE__MUTE   0x1
+ 
+ #define AUDCFG_ADAC_CTRL__PDNANA__SHIFT             5
+ #define AUDCFG_ADAC_CTRL__PDNANA__MASK              0x1
+ #define AUDCFG_ADAC_CTRL__PDNANA__VALUE__POWER_DOWN 0x0
+ #define AUDCFG_ADAC_CTRL__PDNANA__VALUE__NORMAL     0x1
+ 
+ #define AUDCFG_ADAC_CTRL__PDNBG__SHIFT             6
+ #define AUDCFG_ADAC_CTRL__PDNBG__MASK              0x1
+ #define AUDCFG_ADAC_CTRL__PDNBG__VALUE__POWER_DOWN 0x0
+ #define AUDCFG_ADAC_CTRL__PDNBG__VALUE__NORMAL     0x1
+ 
+ 
+ 
+ #endif
diff -rcN linux-sh4-2.6.23.17_stm23_0119-orig/include/linux/stm/registers//audcfg_fsyn.h linux-sh4/include/linux/stm/registers//audcfg_fsyn.h
*** linux-sh4-2.6.23.17_stm23_0119-orig/include/linux/stm/registers//audcfg_fsyn.h	1970-01-01 01:00:00.000000000 +0100
--- linux-sh4/include/linux/stm/registers//audcfg_fsyn.h	2009-06-10 11:15:48.000000000 +0200
***************
*** 0 ****
--- 1,113 ----
+ #ifndef __STM_REGISTERS_AUDCFG_FSYN_H
+ #define __STM_REGISTERS_AUDCFG_FSYN_H
+ 
+ 
+ 
+ #define AUDCFG_FSYN_CFG 0x00
+ 
+ #define AUDCFG_FSYN_CFG__RSTP__SHIFT          0
+ #define AUDCFG_FSYN_CFG__RSTP__MASK           0x1
+ #define AUDCFG_FSYN_CFG__RSTP__VALUE__RUNNING 0x0
+ #define AUDCFG_FSYN_CFG__RSTP__VALUE__RESET   0x1
+ 
+ #define AUDCFG_FSYN_CFG__PCM_CLK_SEL__SHIFT 2
+ #define AUDCFG_FSYN_CFG__PCM_CLK_SEL__MASK  0xf
+ #if defined(CONFIG_CPU_SUBTYPE_STB7100) || defined(CONFIG_CPU_SUBTYPE_STX7111)
+ #define AUDCFG_FSYN_CFG__PCM_CLK_SEL__VALUE__EXTCLK(n) (0 << n)
+ #define AUDCFG_FSYN_CFG__PCM_CLK_SEL__VALUE__FSYNTH(n) (1 << n)
+ #endif
+ #if defined(CONFIG_CPU_SUBTYPE_STX7200)
+ #define AUDCFG_FSYN_CFG__PCM_CLK_SEL__VALUE__FSYNTH(n) (0 << n)
+ #define AUDCFG_FSYN_CFG__PCM_CLK_SEL__VALUE__EXTCLK(n) (1 << n)
+ #endif
+ 
+ #if defined(CONFIG_CPU_SUBTYPE_STB7100)
+ #define AUDCFG_FSYN_CFG__FS_EN__SHIFT              6
+ #define AUDCFG_FSYN_CFG__FS_EN__MASK               0x7
+ #define AUDCFG_FSYN_CFG__FS_EN__VALUE__DISABLED(n) (0 << n)
+ #define AUDCFG_FSYN_CFG__FS_EN__VALUE__ENABLED(n)  (1 << n)
+ #endif
+ #if defined(CONFIG_CPU_SUBTYPE_STX7111)
+ #define AUDCFG_FSYN_CFG__FS_EN__SHIFT              6
+ #define AUDCFG_FSYN_CFG__FS_EN__MASK               0xf
+ #define AUDCFG_FSYN_CFG__FS_EN__VALUE__DISABLED(n) (0 << n)
+ #define AUDCFG_FSYN_CFG__FS_EN__VALUE__ENABLED(n)  (1 << n)
+ #endif
+ /* Doesn't exist in 7200 - again, veeery strange... */
+ 
+ #define AUDCFG_FSYN_CFG__NSB__SHIFT             10
+ #define AUDCFG_FSYN_CFG__NSB__MASK              0xf
+ #define AUDCFG_FSYN_CFG__NSB__VALUE__STANDBY(n) (0 << n)
+ #define AUDCFG_FSYN_CFG__NSB__VALUE__ACTIVE(n)  (1 << n)
+ 
+ #define AUDCFG_FSYN_CFG__NPDA__SHIFT             14
+ #define AUDCFG_FSYN_CFG__NPDA__MASK              0x1
+ #define AUDCFG_FSYN_CFG__NPDA__VALUE__POWER_DOWN 0x0
+ #define AUDCFG_FSYN_CFG__NPDA__VALUE__NORMAL     0x1
+ 
+ #define AUDCFG_FSYN_CFG__NDIV__SHIFT            15
+ #define AUDCFG_FSYN_CFG__NDIV__MASK             0x1
+ #define AUDCFG_FSYN_CFG__NDIV__VALUE__27_30_MHZ 0x0
+ #define AUDCFG_FSYN_CFG__NDIV__VALUE__54_60_MHZ 0x1
+ 
+ #define AUDCFG_FSYN_CFG__BW_SEL__SHIFT                      16
+ #define AUDCFG_FSYN_CFG__BW_SEL__MASK                       0x3
+ #define AUDCFG_FSYN_CFG__BW_SEL__VALUE__VERY_GOOD_REFERENCE 0x0
+ #define AUDCFG_FSYN_CFG__BW_SEL__VALUE__GOOD_REFERENCE      0x1
+ #define AUDCFG_FSYN_CFG__BW_SEL__VALUE__BAD_REFERENCE       0x2
+ #define AUDCFG_FSYN_CFG__BW_SEL__VALUE__VERY_BAD_REFERENCE  0x3
+ 
+ #if defined(CONFIG_CPU_SUBTYPE_STB7100)
+ #define AUDCFG_FSYN_CFG__REF_CLK_IN__SHIFT               23
+ #define AUDCFG_FSYN_CFG__REF_CLK_IN__MASK                0x1
+ #define AUDCFG_FSYN_CFG__REF_CLK_IN__VALUE__30_MHZ_CLOCK 0x0
+ #define AUDCFG_FSYN_CFG__REF_CLK_IN__VALUE__SYSBCLKINALT 0x1
+ #endif
+ #if defined(CONFIG_CPU_SUBTYPE_STX7200)
+ #define AUDCFG_FSYN_CFG__REF_CLK_IN__SHIFT               24
+ #define AUDCFG_FSYN_CFG__REF_CLK_IN__MASK                0x1
+ #define AUDCFG_FSYN_CFG__REF_CLK_IN__VALUE__30_MHZ_CLOCK 0x0
+ #define AUDCFG_FSYN_CFG__REF_CLK_IN__VALUE__SYSBCLKINALT 0x1
+ #endif
+ #if defined(CONFIG_CPU_SUBTYPE_STX7111)
+ #define AUDCFG_FSYN_CFG__REF_CLK_IN__SHIFT               23
+ #define AUDCFG_FSYN_CFG__REF_CLK_IN__MASK                0x3
+ #define AUDCFG_FSYN_CFG__REF_CLK_IN__VALUE__FE900_CLOCK  0x0
+ #define AUDCFG_FSYN_CFG__REF_CLK_IN__VALUE__30_MHZ_CLOCK 0x1
+ #define AUDCFG_FSYN_CFG__REF_CLK_IN__VALUE__SYSCLKINALT  0x2
+ #endif
+ 
+ 
+ 
+ #define AUDCFG_FSYN_MD(n) ((n + 1) * 0x10 + 0x00)
+ 
+ #define AUDCFG_FSYN_MD__MD__SHIFT 0
+ #define AUDCFG_FSYN_MD__MD__MASK  0x1f
+ 
+ 
+ 
+ #define AUDCFG_FSYN_PE(n) ((n + 1) * 0x10 + 0x04)
+ 
+ #define AUDCFG_FSYN_PE__PE__SHIFT 0
+ #define AUDCFG_FSYN_PE__PE__MASK  0xffff
+ 
+ 
+ 
+ #define AUDCFG_FSYN_SDIV(n) ((n + 1) * 0x10 + 0x08)
+ 
+ #define AUDCFG_FSYN_SDIV__SDIV__SHIFT 0
+ #define AUDCFG_FSYN_SDIV__SDIV__MASK  0x7
+ 
+ 
+ 
+ #define AUDCFG_FSYN_PROGEN(n) ((n + 1) * 0x10 + 0x0c)
+ 
+ #define AUDCFG_FSYN_PROGEN__PROG_EN__SHIFT                  0
+ #define AUDCFG_FSYN_PROGEN__PROG_EN__MASK                   0x1
+ #define AUDCFG_FSYN_PROGEN__PROG_EN__VALUE__PE0_MD0_IGNORED 0x0
+ #define AUDCFG_FSYN_PROGEN__PROG_EN__VALUE__PE0_MD0_USED    0x1
+ 
+ 
+ 
+ 
+ #endif
diff -rcN linux-sh4-2.6.23.17_stm23_0119-orig/include/linux/stm/registers//audcfg.h linux-sh4/include/linux/stm/registers//audcfg.h
*** linux-sh4-2.6.23.17_stm23_0119-orig/include/linux/stm/registers//audcfg.h	1970-01-01 01:00:00.000000000 +0100
--- linux-sh4/include/linux/stm/registers//audcfg.h	2009-06-10 11:15:48.000000000 +0200
***************
*** 0 ****
--- 1,20 ----
+ #ifndef __STM_REGISTERS_AUDCFG_H
+ #define __STM_REGISTERS_AUDCFG_H
+ 
+ 
+ 
+ #ifdef CONFIG_CPU_SUBTYPE_STB7100
+ #include <linux/stm/registers/stx710x/audcfg.h>
+ #endif
+ 
+ #ifdef CONFIG_CPU_SUBTYPE_STX7111
+ #include <linux/stm/registers/stx7111/audcfg.h>
+ #endif
+ 
+ #ifdef CONFIG_CPU_SUBTYPE_STX7200
+ #include <linux/stm/registers/stx7200/audcfg.h>
+ #endif
+ 
+ 
+ 
+ #endif
diff -rcN linux-sh4-2.6.23.17_stm23_0119-orig/include/linux/stm/registers//aud_pcmin.h linux-sh4/include/linux/stm/registers//aud_pcmin.h
*** linux-sh4-2.6.23.17_stm23_0119-orig/include/linux/stm/registers//aud_pcmin.h	1970-01-01 01:00:00.000000000 +0100
--- linux-sh4/include/linux/stm/registers//aud_pcmin.h	2009-06-10 11:15:48.000000000 +0200
***************
*** 0 ****
--- 1,172 ----
+ #ifndef __STM_REGISTERS_AUD_PCMIN_H
+ #define __STM_REGISTERS_AUD_PCMIN_H
+ 
+ 
+ 
+ #define AUD_PCMIN_RST 0x00
+ 
+ #define AUD_PCMIN_RST__RSTP__SHIFT          0
+ #define AUD_PCMIN_RST__RSTP__MASK           0x1
+ #define AUD_PCMIN_RST__RSTP__VALUE__RUNNING 0x0
+ #define AUD_PCMIN_RST__RSTP__VALUE__RESET   0x1
+ 
+ 
+ 
+ #define AUD_PCMIN_DATA 0x04
+ 
+ #define AUD_PCMIN_DATA__DATA__SHIFT 0
+ #define AUD_PCMIN_DATA__DATA__MASK  0xffffffff
+ 
+ 
+ 
+ #define AUD_PCMIN_ITS 0x08
+ 
+ #define AUD_PCMIN_ITS__OVF__SHIFT          0
+ #define AUD_PCMIN_ITS__OVF__MASK           0x1
+ #define AUD_PCMIN_ITS__OVF__VALUE__PENDING 0x1
+ 
+ #define AUD_PCMIN_ITS__VSYNC__SHIFT          1
+ #define AUD_PCMIN_ITS__VSYNC__MASK           0x1
+ #define AUD_PCMIN_ITS__VSYNC__VALUE__PENDING 0x1
+ 
+ 
+ 
+ #define AUD_PCMIN_ITS_CLR 0x0c
+ 
+ #define AUD_PCMIN_ITS_CLR__OVF__SHIFT        0
+ #define AUD_PCMIN_ITS_CLR__OVF__MASK         0x1
+ #define AUD_PCMIN_ITS_CLR__OVF__VALUE__CLEAR 0x1
+ 
+ #define AUD_PCMIN_ITS_CLR__VSYNC__SHIFT       1
+ #define AUD_PCMIN_ITS_CLR__VSYNC__MASK        0x1
+ #define AUD_PCMIN_ITS_CLR__VSYNC__VALUE_CLEAR 0x1
+ 
+ 
+ 
+ #define AUD_PCMIN_IT_EN 0x10
+ 
+ #define AUD_PCMIN_IT_EN__OVF__SHIFT           0
+ #define AUD_PCMIN_IT_EN__OVF__MASK            0x1
+ #define AUD_PCMIN_IT_EN__OVF__VALUE__DISABLED 0x0
+ #define AUD_PCMIN_IT_EN__OVF__VALUE__ENABLED  0x1
+ 
+ #define AUD_PCMIN_IT_EN__VSYNC__SHIFT           1
+ #define AUD_PCMIN_IT_EN__VSYNC__MASK            0x1
+ #define AUD_PCMIN_IT_EN__VSYNC__VALUE__DISABLED 0x0
+ #define AUD_PCMIN_IT_EN__VSYNC__VALUE__ENABLED  0x1
+ 
+ 
+ 
+ #define AUD_PCMIN_IT_EN_SET 0x14
+ 
+ #define AUD_PCMIN_IT_EN_SET__OVF__SHIFT      0
+ #define AUD_PCMIN_IT_EN_SET__OVF__MASK       0x1
+ #define AUD_PCMIN_IT_EN_SET__OVF__VALUE__SET 0x1
+ 
+ #define AUD_PCMIN_IT_EN_SET__VSYNC__SHIFT      1
+ #define AUD_PCMIN_IT_EN_SET__VSYNC__MASK       0x1
+ #define AUD_PCMIN_IT_EN_SET__VSYNC__VALUE__SET 0x1
+ 
+ 
+ 
+ #define AUD_PCMIN_IT_EN_CLR 0x18
+ 
+ #define AUD_PCMIN_IT_EN_CLR__OVF__SHIFT        0
+ #define AUD_PCMIN_IT_EN_CLR__OVF__MASK         0x1
+ #define AUD_PCMIN_IT_EN_CLR__OVF__VALUE__CLEAR 0x1
+ 
+ #define AUD_PCMIN_IT_EN_CLR__VSYNC__SHIFT        1
+ #define AUD_PCMIN_IT_EN_CLR__VSYNC__MASK         0x1
+ #define AUD_PCMIN_IT_EN_CLR__VSYNC__VALUE__CLEAR 0x1
+ 
+ 
+ 
+ #define AUD_PCMIN_CTRL 0x1c
+ 
+ #define AUD_PCMIN_CTRL__MODE__SHIFT       0
+ #define AUD_PCMIN_CTRL__MODE__MASK        0x3
+ #define AUD_PCMIN_CTRL__MODE__VALUE__OFF  0x0
+ #define AUD_PCMIN_CTRL__MODE__VALUE__PCM  0x2
+ #define AUD_PCMIN_CTRL__MODE__VALUE__CD   0x3
+ 
+ #define AUD_PCMIN_CTRL__MEM_FMT__SHIFT                  2
+ #define AUD_PCMIN_CTRL__MEM_FMT__MASK                   0x1
+ #define AUD_PCMIN_CTRL__MEM_FMT__VALUE__16_BITS_0_BITS  0x0
+ #define AUD_PCMIN_CTRL__MEM_FMT__VALUE__16_BITS_16_BITS 0x1
+ 
+ #define AUD_PCMIN_CTRL__RND__SHIFT                   3
+ #define AUD_PCMIN_CTRL__RND__MASK                    0x1
+ #define AUD_PCMIN_CTRL__RND__VALUE__NO_ROUNDING      0x0
+ #define AUD_PCMIN_CTRL__RND__VALUE__16_BITS_ROUNDING 0x1
+ 
+ #define AUD_PCMIN_CTRL__NUM_FRAMES__SHIFT 4
+ #define AUD_PCMIN_CTRL__NUM_FRAMES__MASK  0xfffffff
+ 
+ 
+ 
+ 
+ #define AUD_PCMIN_STA 0x20
+ 
+ #define AUD_PCMIN_STA__RUN_STOP__SHIFT          0
+ #define AUD_PCMIN_STA__RUN_STOP__MASK           0x1
+ #define AUD_PCMIN_STA__RUN_STOP__VALUE__STOPPED 0x0
+ #define AUD_PCMIN_STA__RUN_STOP__VALUE__RUNNING 0x1
+ 
+ #define AUD_PCMIN_STA__OVF__SHIFT                    1
+ #define AUD_PCMIN_STA__OVF__MASK                     0x1
+ #define AUD_PCMIN_STA__OVF__VALUE__OVERFLOW_DETECTED 0x1
+ 
+ #define AUD_PCMIN_STA__SAMPL_CNT__SHIFT 2
+ #define AUD_PCMIN_STA__SAMPL_CNT__MASK  0xffff
+ 
+ #define AUD_PCMIN_STA__VSYNC__SHIFT 18
+ #define AUD_PCMIN_STA__VSYNC__MASK  0x1
+ 
+ #define AUD_PCMIN_STA__NFRAMES__SHIFT       19
+ #define AUD_PCMIN_STA__NFRAMES__MASK        0x1
+ #define AUD_PCMIN_STA__NFRAMES__VALUE__DONE 0x1
+ 
+ 
+ 
+ #define AUD_PCMIN_FMT 0x24
+ 
+ #define AUD_PCMIN_FMT__NBIT__SHIFT          0
+ #define AUD_PCMIN_FMT__NBIT__MASK           0x1
+ #define AUD_PCMIN_FMT__NBIT__VALUE__32_BITS 0x0
+ #define AUD_PCMIN_FMT__NBIT__VALUE__16_BITS 0x1
+ 
+ #define AUD_PCMIN_FMT__DATA_SIZE__SHIFT          1
+ #define AUD_PCMIN_FMT__DATA_SIZE__MASK           0x3
+ #define AUD_PCMIN_FMT__DATA_SIZE__VALUE__24_BITS 0x0
+ #define AUD_PCMIN_FMT__DATA_SIZE__VALUE__20_BITS 0x1
+ #define AUD_PCMIN_FMT__DATA_SIZE__VALUE__18_BITS 0x2
+ #define AUD_PCMIN_FMT__DATA_SIZE__VALUE__16_BITS 0x3
+ 
+ #define AUD_PCMIN_FMT__LR_POL__SHIFT            3
+ #define AUD_PCMIN_FMT__LR_POL__MASK             0x1
+ #define AUD_PCMIN_FMT__LR_POL__VALUE__LEFT_LOW  0x0
+ #define AUD_PCMIN_FMT__LR_POL__VALUE__LEFT_HIGH 0x1
+ 
+ #define AUD_PCMIN_FMT__SCLK_EDGE__SHIFT          4
+ #define AUD_PCMIN_FMT__SCLK_EDGE__MASK           0x1
+ #define AUD_PCMIN_FMT__SCLK_EDGE__VALUE__RISING  0x0
+ #define AUD_PCMIN_FMT__SCLK_EDGE__VALUE__FALLING 0x1
+ 
+ #define AUD_PCMIN_FMT__PADDING__SHIFT                5
+ #define AUD_PCMIN_FMT__PADDING__MASK                 0x1
+ #define AUD_PCMIN_FMT__PADDING__VALUE__1_CYCLE_DELAY 0x0
+ #define AUD_PCMIN_FMT__PADDING__VALUE__NO_DELAY      0x1
+ 
+ #define AUD_PCMIN_FMT__ALIGN__SHIFT        6
+ #define AUD_PCMIN_FMT__ALIGN__MASK         0x1
+ #define AUD_PCMIN_FMT__ALIGN__VALUE__RIGHT 0x0
+ #define AUD_PCMIN_FMT__ALIGN__VALUE__LEFT  0x1
+ 
+ #define AUD_PCMIN_FMT__ORDER__SHIFT            7
+ #define AUD_PCMIN_FMT__ORDER__MASK             0x1
+ #define AUD_PCMIN_FMT__ORDER__VALUE__LSB_FIRST 0x0
+ #define AUD_PCMIN_FMT__ORDER__VALUE__MSB_FIRST 0x1
+ 
+ 
+ 
+ #endif
diff -rcN linux-sh4-2.6.23.17_stm23_0119-orig/include/linux/stm/registers//aud_pcmout.h linux-sh4/include/linux/stm/registers//aud_pcmout.h
*** linux-sh4-2.6.23.17_stm23_0119-orig/include/linux/stm/registers//aud_pcmout.h	1970-01-01 01:00:00.000000000 +0100
--- linux-sh4/include/linux/stm/registers//aud_pcmout.h	2009-06-10 11:15:48.000000000 +0200
***************
*** 0 ****
--- 1,251 ----
+ #ifndef __STM_REGISTERS_AUD_PCMOUT_H
+ #define __STM_REGISTERS_AUD_PCMOUT_H
+ 
+ 
+ 
+ #define AUD_PCMOUT_RST 0x00
+ 
+ #define AUD_PCMOUT_RST__SRSTP__SHIFT          0
+ #define AUD_PCMOUT_RST__SRSTP__MASK           0x1
+ #define AUD_PCMOUT_RST__SRSTP__VALUE__RUNNING 0x0
+ #define AUD_PCMOUT_RST__SRSTP__VALUE__RESET   0x1
+ 
+ 
+ 
+ #define AUD_PCMOUT_DATA 0x04
+ 
+ #define AUD_PCMOUT_DATA__DATA__SHIFT 0
+ #define AUD_PCMOUT_DATA__DATA__MASK  0xffffffff
+ 
+ 
+ 
+ #define AUD_PCMOUT_ITS 0x08
+ 
+ #define AUD_PCMOUT_ITS__UNF__SHIFT          0
+ #define AUD_PCMOUT_ITS__UNF__MASK           0x1
+ #define AUD_PCMOUT_ITS__UNF__VALUE__PENDING 0x1
+ 
+ #define AUD_PCMOUT_ITS__NSAMPLE__SHIFT          1
+ #define AUD_PCMOUT_ITS__NSAMPLE__MASK           0x1
+ #define AUD_PCMOUT_ITS__NSAMPLE__VALUE__PENDING 0x1
+ 
+ 
+ 
+ #define AUD_PCMOUT_ITS_CLR 0x0c
+ 
+ #define AUD_PCMOUT_ITS_CLR__UNF__SHIFT        0
+ #define AUD_PCMOUT_ITS_CLR__UNF__MASK         0x1
+ #define AUD_PCMOUT_ITS_CLR__UNF__VALUE__CLEAR 0x1
+ 
+ #define AUD_PCMOUT_ITS_CLR__NSAMPLE__SHIFT        1
+ #define AUD_PCMOUT_ITS_CLR__NSAMPLE__MASK         0x1
+ #define AUD_PCMOUT_ITS_CLR__NSAMPLE__VALUE__CLEAR 0x1
+ 
+ 
+ 
+ #define AUD_PCMOUT_IT_EN 0x10
+ 
+ #define AUD_PCMOUT_IT_EN__UNF__SHIFT           0
+ #define AUD_PCMOUT_IT_EN__UNF__MASK            0x1
+ #define AUD_PCMOUT_IT_EN__UNF__VALUE__DISABLED 0x0
+ #define AUD_PCMOUT_IT_EN__UNF__VALUE__ENABLED  0x1
+ 
+ #define AUD_PCMOUT_IT_EN__NSAMPLE__SHIFT           1
+ #define AUD_PCMOUT_IT_EN__NSAMPLE__MASK            0x1
+ #define AUD_PCMOUT_IT_EN__NSAMPLE__VALUE__DISABLED 0x0
+ #define AUD_PCMOUT_IT_EN__NSAMPLE__VALUE__ENABLED  0x1
+ 
+ 
+ 
+ #define AUD_PCMOUT_IT_EN_SET 0x14
+ 
+ #define AUD_PCMOUT_IT_EN_SET__UNF__SHIFT      0
+ #define AUD_PCMOUT_IT_EN_SET__UNF__MASK       0x1
+ #define AUD_PCMOUT_IT_EN_SET__UNF__VALUE__SET 0x1
+ 
+ #define AUD_PCMOUT_IT_EN_SET__NSAMPLE__SHIFT      1
+ #define AUD_PCMOUT_IT_EN_SET__NSAMPLE__MASK       0x1
+ #define AUD_PCMOUT_IT_EN_SET__NSAMPLE__VALUE__SET 0x1
+ 
+ 
+ 
+ #define AUD_PCMOUT_IT_EN_CLR 0x18
+ 
+ #define AUD_PCMOUT_IT_EN_CLR__UNF__SHIFT        0
+ #define AUD_PCMOUT_IT_EN_CLR__UNF__MASK         0x1
+ #define AUD_PCMOUT_IT_EN_CLR__UNF__VALUE__CLEAR 0x1
+ 
+ #define AUD_PCMOUT_IT_EN_CLR__NSAMPLE__SHIFT        1
+ #define AUD_PCMOUT_IT_EN_CLR__NSAMPLE__MASK         0x1
+ #define AUD_PCMOUT_IT_EN_CLR__NSAMPLE__VALUE__CLEAR 0x1
+ 
+ 
+ 
+ #define AUD_PCMOUT_CTRL 0x1c
+ 
+ #define AUD_PCMOUT_CTRL__MODE__SHIFT       0
+ #define AUD_PCMOUT_CTRL__MODE__MASK        0x3
+ #define AUD_PCMOUT_CTRL__MODE__VALUE__OFF  0x0
+ #define AUD_PCMOUT_CTRL__MODE__VALUE__MUTE 0x1
+ #define AUD_PCMOUT_CTRL__MODE__VALUE__PCM  0x2
+ #define AUD_PCMOUT_CTRL__MODE__VALUE__CD   0x3
+ 
+ #define AUD_PCMOUT_CTRL__MEM_FMT__SHIFT                  2
+ #define AUD_PCMOUT_CTRL__MEM_FMT__MASK                   0x1
+ #define AUD_PCMOUT_CTRL__MEM_FMT__VALUE__16_BITS_0_BITS  0x0
+ #define AUD_PCMOUT_CTRL__MEM_FMT__VALUE__16_BITS_16_BITS 0x1
+ 
+ #define AUD_PCMOUT_CTRL__RND__SHIFT                   3
+ #define AUD_PCMOUT_CTRL__RND__MASK                    0x1
+ #define AUD_PCMOUT_CTRL__RND__VALUE__NO_ROUNDING      0x0
+ #define AUD_PCMOUT_CTRL__RND__VALUE__16_BITS_ROUNDING 0x1
+ 
+ #define AUD_PCMOUT_CTRL__CLK_DIV__SHIFT 4
+ #define AUD_PCMOUT_CTRL__CLK_DIV__MASK  0xff
+ 
+ #define AUD_PCMOUT_CTRL__SPDIF_LAT__SHIFT                 12
+ #define AUD_PCMOUT_CTRL__SPDIF_LAT__MASK                  0x1
+ #define AUD_PCMOUT_CTRL__SPDIF_LAT__VALUE__IGNORE_SPDIF   0x0
+ #define AUD_PCMOUT_CTRL__SPDIF_LAT__VALUE__WAIT_FOR_SPDIF 0x1
+ 
+ #define AUD_PCMOUT_CTRL__NSAMPLE__SHIFT 13
+ #define AUD_PCMOUT_CTRL__NSAMPLE__MASK  0x7ffff
+ 
+ 
+ 
+ #define AUD_PCMOUT_STA 0x20
+ 
+ #define AUD_PCMOUT_STA__RUN_STOP__SHIFT          0
+ #define AUD_PCMOUT_STA__RUN_STOP__MASK           0x1
+ #define AUD_PCMOUT_STA__RUN_STOP__VALUE__STOPPED 0x0
+ #define AUD_PCMOUT_STA__RUN_STOP__VALUE__RUNNING 0x1
+ 
+ #define AUD_PCMOUT_STA__UNF__SHIFT           1
+ #define AUD_PCMOUT_STA__UNF__MASK            0x1
+ #define AUD_PCMOUT_STA__UNF__VALUE__DETECTED 0x1
+ 
+ #define AUD_PCMOUT_STA__NSAMPLE__SHIFT       2
+ #define AUD_PCMOUT_STA__NSAMPLE__MASK        0x1
+ #define AUD_PCMOUT_STA__NSAMPLE__VALUE__DONE 0x1
+ 
+ 
+ 
+ #define AUD_PCMOUT_FMT 0x24
+ 
+ #if defined(CONFIG_CPU_SUBTYPE_STX7111)
+ 
+ #define AUD_PCMOUT_FMT__NBIT__SHIFT          0
+ #define AUD_PCMOUT_FMT__NBIT__MASK           0x1
+ #define AUD_PCMOUT_FMT__NBIT__VALUE__32_BITS 0x0
+ #define AUD_PCMOUT_FMT__NBIT__VALUE__16_BITS 0x1
+ 
+ #define AUD_PCMOUT_FMT__DATA_SIZE__SHIFT          1
+ #define AUD_PCMOUT_FMT__DATA_SIZE__MASK           0x7
+ #define AUD_PCMOUT_FMT__DATA_SIZE__VALUE__16_BITS 0x0
+ #define AUD_PCMOUT_FMT__DATA_SIZE__VALUE__18_BITS 0x1
+ #define AUD_PCMOUT_FMT__DATA_SIZE__VALUE__20_BITS 0x2
+ #define AUD_PCMOUT_FMT__DATA_SIZE__VALUE__24_BITS 0x3
+ #define AUD_PCMOUT_FMT__DATA_SIZE__VALUE__28_BITS 0x4
+ #define AUD_PCMOUT_FMT__DATA_SIZE__VALUE__32_BITS 0x5
+ 
+ #define AUD_PCMOUT_FMT__LR_POL__SHIFT            4
+ #define AUD_PCMOUT_FMT__LR_POL__MASK             0x1
+ #define AUD_PCMOUT_FMT__LR_POL__VALUE__LEFT_LOW  0x0
+ #define AUD_PCMOUT_FMT__LR_POL__VALUE__LEFT_HIGH 0x1
+ 
+ #define AUD_PCMOUT_FMT__SCLK_EDGE__SHIFT          5
+ #define AUD_PCMOUT_FMT__SCLK_EDGE__MASK           0x1
+ #define AUD_PCMOUT_FMT__SCLK_EDGE__VALUE__RISING  0x0
+ #define AUD_PCMOUT_FMT__SCLK_EDGE__VALUE__FALLING 0x1
+ 
+ #define AUD_PCMOUT_FMT__PADDING__SHIFT                6
+ #define AUD_PCMOUT_FMT__PADDING__MASK                 0x1
+ #define AUD_PCMOUT_FMT__PADDING__VALUE__1_CYCLE_DELAY 0x0
+ #define AUD_PCMOUT_FMT__PADDING__VALUE__NO_DELAY      0x1
+ 
+ #define AUD_PCMOUT_FMT__ALIGN__SHIFT        7
+ #define AUD_PCMOUT_FMT__ALIGN__MASK         0x1
+ #define AUD_PCMOUT_FMT__ALIGN__VALUE__LEFT  0x0
+ #define AUD_PCMOUT_FMT__ALIGN__VALUE__RIGHT 0x1
+ 
+ #define AUD_PCMOUT_FMT__ORDER__SHIFT            8
+ #define AUD_PCMOUT_FMT__ORDER__MASK             0x1
+ #define AUD_PCMOUT_FMT__ORDER__VALUE__LSB_FIRST 0x0
+ #define AUD_PCMOUT_FMT__ORDER__VALUE__MSB_FIRST 0x1
+ 
+ #define AUD_PCMOUT_FMT__NUM_CH__SHIFT             9
+ #define AUD_PCMOUT_FMT__NUM_CH__MASK              0x7
+ /* "1 channel" means 1 PCM player channel so
+  * 2 audio channels (stereo) */
+ #define AUD_PCMOUT_FMT__NUM_CH__VALUE__1_CHANNEL  0x1
+ #define AUD_PCMOUT_FMT__NUM_CH__VALUE__2_CHANNELS 0x2
+ #define AUD_PCMOUT_FMT__NUM_CH__VALUE__3_CHANNELS 0x3
+ #define AUD_PCMOUT_FMT__NUM_CH__VALUE__4_CHANNELS 0x4
+ #define AUD_PCMOUT_FMT__NUM_CH__VALUE__5_CHANNELS 0x5
+ 
+ #define AUD_PCMOUT_FMT__BACK_STALLING__SHIFT            12
+ #define AUD_PCMOUT_FMT__BACK_STALLING__MASK             0x1
+ #define AUD_PCMOUT_FMT__BACK_STALLING__VALUE__DISABLED  0x0
+ #define AUD_PCMOUT_FMT__BACK_STALLING__VALUE__ENABLED   0x1
+ 
+ #define AUD_PCMOUT_FMT__DMA_REQ_TRIG_LMT__SHIFT 13
+ #define AUD_PCMOUT_FMT__DMA_REQ_TRIG_LMT__MASK  0x3f
+ 
+ #else /* STx710x, STx7200 cut 1.0 */
+ 
+ #define AUD_PCMOUT_FMT__NBIT__SHIFT          0
+ #define AUD_PCMOUT_FMT__NBIT__MASK           0x1
+ #define AUD_PCMOUT_FMT__NBIT__VALUE__32_BITS 0x0
+ #define AUD_PCMOUT_FMT__NBIT__VALUE__16_BITS 0x1
+ 
+ #define AUD_PCMOUT_FMT__DATA_SIZE__SHIFT          1
+ #define AUD_PCMOUT_FMT__DATA_SIZE__MASK           0x3
+ #define AUD_PCMOUT_FMT__DATA_SIZE__VALUE__24_BITS 0x0
+ #define AUD_PCMOUT_FMT__DATA_SIZE__VALUE__20_BITS 0x1
+ #define AUD_PCMOUT_FMT__DATA_SIZE__VALUE__18_BITS 0x2
+ #define AUD_PCMOUT_FMT__DATA_SIZE__VALUE__16_BITS 0x3
+ 
+ #define AUD_PCMOUT_FMT__LR_POL__SHIFT            3
+ #define AUD_PCMOUT_FMT__LR_POL__MASK             0x1
+ #define AUD_PCMOUT_FMT__LR_POL__VALUE__LEFT_LOW  0x0
+ #define AUD_PCMOUT_FMT__LR_POL__VALUE__LEFT_HIGH 0x1
+ 
+ #define AUD_PCMOUT_FMT__SCLK_EDGE__SHIFT          4
+ #define AUD_PCMOUT_FMT__SCLK_EDGE__MASK           0x1
+ /* Beware that in 7100 and some cuts of 7109 there is
+  * a HW bug and these values are inverted; such
+  * situation must be detected in runtime! */
+ #define AUD_PCMOUT_FMT__SCLK_EDGE__VALUE__RISING  0x0
+ #define AUD_PCMOUT_FMT__SCLK_EDGE__VALUE__FALLING 0x1
+ 
+ #define AUD_PCMOUT_FMT__PADDING__SHIFT                5
+ #define AUD_PCMOUT_FMT__PADDING__MASK                 0x1
+ #define AUD_PCMOUT_FMT__PADDING__VALUE__1_CYCLE_DELAY 0x0
+ #define AUD_PCMOUT_FMT__PADDING__VALUE__NO_DELAY      0x1
+ 
+ #define AUD_PCMOUT_FMT__ALIGN__SHIFT        6
+ #define AUD_PCMOUT_FMT__ALIGN__MASK         0x1
+ #define AUD_PCMOUT_FMT__ALIGN__VALUE__LEFT  0x0
+ #define AUD_PCMOUT_FMT__ALIGN__VALUE__RIGHT 0x1
+ 
+ #define AUD_PCMOUT_FMT__ORDER__SHIFT            7
+ #define AUD_PCMOUT_FMT__ORDER__MASK             0x1
+ #define AUD_PCMOUT_FMT__ORDER__VALUE__LSB_FIRST 0x0
+ #define AUD_PCMOUT_FMT__ORDER__VALUE__MSB_FIRST 0x1
+ 
+ #define AUD_PCMOUT_FMT__NUM_CH__SHIFT             8
+ #define AUD_PCMOUT_FMT__NUM_CH__MASK              0x7
+ /* "1 channel" means 1 PCM player channel so
+  * 2 audio channels (stereo) */
+ #define AUD_PCMOUT_FMT__NUM_CH__VALUE__1_CHANNEL  0x1
+ #define AUD_PCMOUT_FMT__NUM_CH__VALUE__2_CHANNELS 0x2
+ #define AUD_PCMOUT_FMT__NUM_CH__VALUE__3_CHANNELS 0x3
+ #define AUD_PCMOUT_FMT__NUM_CH__VALUE__4_CHANNELS 0x4
+ #define AUD_PCMOUT_FMT__NUM_CH__VALUE__5_CHANNELS 0x5
+ 
+ #define AUD_PCMOUT_FMT__DMA_REQ_TRIG_LMT__SHIFT 11
+ #define AUD_PCMOUT_FMT__DMA_REQ_TRIG_LMT__MASK  0x1f
+ 
+ #endif
+ 
+ #endif
diff -rcN linux-sh4-2.6.23.17_stm23_0119-orig/include/linux/stm/registers//aud_spdif.h linux-sh4/include/linux/stm/registers//aud_spdif.h
*** linux-sh4-2.6.23.17_stm23_0119-orig/include/linux/stm/registers//aud_spdif.h	1970-01-01 01:00:00.000000000 +0100
--- linux-sh4/include/linux/stm/registers//aud_spdif.h	2009-06-10 11:15:48.000000000 +0200
***************
*** 0 ****
--- 1,371 ----
+ #ifndef __STM_REGISTERS_AUD_SPDIF_H
+ #define __STM_REGISTERS_AUD_SPDIF_H
+ 
+ 
+ 
+ #define AUD_SPDIF_RST 0x00
+ 
+ #define AUD_SPDIF_RST__SRSTP__SHIFT          0
+ #define AUD_SPDIF_RST__SRSTP__MASK           0x1
+ #define AUD_SPDIF_RST__SRSTP__VALUE__RUNNING 0x0
+ #define AUD_SPDIF_RST__SRSTP__VALUE__RESET   0x1
+ 
+ 
+ 
+ #define AUD_SPDIF_DATA 0x04
+ 
+ #define AUD_SPDIF_DATA__DATA__SHIFT 0
+ #define AUD_SPDIF_DATA__DATA__MASK  0xffffffff
+ 
+ 
+ 
+ #define AUD_SPDIF_ITS 0x08
+ 
+ #define AUD_SPDIF_ITS__UNF__SHIFT          0
+ #define AUD_SPDIF_ITS__UNF__MASK           0x1
+ #define AUD_SPDIF_ITS__UNF__VALUE__PENDING 0x1
+ 
+ #define AUD_SPDIF_ITS__EOBURST__SHIFT          1
+ #define AUD_SPDIF_ITS__EOBURST__MASK           0x1
+ #define AUD_SPDIF_ITS__EOBURST__VALUE__PENDING 0x1
+ 
+ #define AUD_SPDIF_ITS__EOBLOCK__SHIFT          2
+ #define AUD_SPDIF_ITS__EOBLOCK__MASK           0x1
+ #define AUD_SPDIF_ITS__EOBLOCK__VALUE__PENDING 0x1
+ 
+ #define AUD_SPDIF_ITS__EOLATENCY__SHIFT          3
+ #define AUD_SPDIF_ITS__EOLATENCY__MASK           0x1
+ #define AUD_SPDIF_ITS__EOLATENCY__VALUE__PENDING 0x1
+ 
+ #define AUD_SPDIF_ITS__EOPD__SHIFT          4
+ #define AUD_SPDIF_ITS__EOPD__MASK           0x1
+ #define AUD_SPDIF_ITS__EOPD__VALUE__PENDING 0x1
+ 
+ #define AUD_SPDIF_ITS__NSAMPLE__SHIFT          5
+ #define AUD_SPDIF_ITS__NSAMPLE__MASK           0x1
+ #define AUD_SPDIF_ITS__NSAMPLE__VALUE__PENDING 0x1
+ 
+ 
+ 
+ #define AUD_SPDIF_ITS_CLR 0x0c
+ 
+ #define AUD_SPDIF_ITS_CLR__UNF__SHIFT        0
+ #define AUD_SPDIF_ITS_CLR__UNF__MASK         0x1
+ #define AUD_SPDIF_ITS_CLR__UNF__VALUE__CLEAR 0x1
+ 
+ #define AUD_SPDIF_ITS_CLR__EOBURST__SHIFT        1
+ #define AUD_SPDIF_ITS_CLR__EOBURST__MASK         0x1
+ #define AUD_SPDIF_ITS_CLR__EOBURST__VALUE__CLEAR 0x1
+ 
+ #define AUD_SPDIF_ITS_CLR__EOBLOCK__SHIFT        2
+ #define AUD_SPDIF_ITS_CLR__EOBLOCK__MASK         0x1
+ #define AUD_SPDIF_ITS_CLR__EOBLOCK__VALUE__CLEAR 0x1
+ 
+ #define AUD_SPDIF_ITS_CLR__EOLATENCY__SHIFT        3
+ #define AUD_SPDIF_ITS_CLR__EOLATENCY__MASK         0x1
+ #define AUD_SPDIF_ITS_CLR__EOLATENCY__VALUE__CLEAR 0x1
+ 
+ #define AUD_SPDIF_ITS_CLR__EOPD__SHIFT        4
+ #define AUD_SPDIF_ITS_CLR__EOPD__MASK         0x1
+ #define AUD_SPDIF_ITS_CLR__EOPD__VALUE__CLEAR 0x1
+ 
+ #define AUD_SPDIF_ITS_CLR__NSAMPLE__SHIFT        5
+ #define AUD_SPDIF_ITS_CLR__NSAMPLE__MASK         0x1
+ #define AUD_SPDIF_ITS_CLR__NSAMPLE__VALUE__CLEAR 0x1
+ 
+ 
+ 
+ #define AUD_SPDIF_IT_EN 0x10
+ 
+ #define AUD_SPDIF_IT_EN__UNF__SHIFT           0
+ #define AUD_SPDIF_IT_EN__UNF__MASK            0x1
+ #define AUD_SPDIF_IT_EN__UNF__VALUE__DISABLED 0x0
+ #define AUD_SPDIF_IT_EN__UNF__VALUE__ENABLED  0x1
+ 
+ #define AUD_SPDIF_IT_EN__EOBURST__SHIFT           1
+ #define AUD_SPDIF_IT_EN__EOBURST__MASK            0x1
+ #define AUD_SPDIF_IT_EN__EOBURST__VALUE__DISABLED 0x0
+ #define AUD_SPDIF_IT_EN__EOBURST__VALUE__ENABLED  0x1
+ 
+ #define AUD_SPDIF_IT_EN__EOBLOCK__SHIFT           2
+ #define AUD_SPDIF_IT_EN__EOBLOCK__MASK            0x1
+ #define AUD_SPDIF_IT_EN__EOBLOCK__VALUE__DISABLED 0x0
+ #define AUD_SPDIF_IT_EN__EOBLOCK__VALUE__ENABLED  0x1
+ 
+ #define AUD_SPDIF_IT_EN__EOLATENCY__SHIFT           3
+ #define AUD_SPDIF_IT_EN__EOLATENCY__MASK            0x1
+ #define AUD_SPDIF_IT_EN__EOLATENCY__VALUE__DISABLED 0x0
+ #define AUD_SPDIF_IT_EN__EOLATENCY__VALUE__ENABLED 0x1
+ 
+ #define AUD_SPDIF_IT_EN__EOPD__SHIFT           4
+ #define AUD_SPDIF_IT_EN__EOPD__MASK            0x1
+ #define AUD_SPDIF_IT_EN__EOPD__VALUE__DISABLED 0x0
+ #define AUD_SPDIF_IT_EN__EOPD__VALUE__ENABLED  0x1
+ 
+ #define AUD_SPDIF_IT_EN__NSAMPLE__SHIFT           5
+ #define AUD_SPDIF_IT_EN__NSAMPLE__MASK            0x1
+ #define AUD_SPDIF_IT_EN__NSAMPLE__VALUE__DISABLED 0x0
+ #define AUD_SPDIF_IT_EN__NSAMPLE__VALUE__ENABLED  0x1
+ 
+ 
+ 
+ #define AUD_SPDIF_IT_EN_SET 0x14
+ 
+ #define AUD_SPDIF_IT_EN_SET__UNF__SHIFT      0
+ #define AUD_SPDIF_IT_EN_SET__UNF__MASK       0x1
+ #define AUD_SPDIF_IT_EN_SET__UNF__VALUE__SET 0x1
+ 
+ #define AUD_SPDIF_IT_EN_SET__EOBURST__SHIFT      1
+ #define AUD_SPDIF_IT_EN_SET__EOBURST__MASK       0x1
+ #define AUD_SPDIF_IT_EN_SET__EOBURST__VALUE__SET 0x1
+ 
+ #define AUD_SPDIF_IT_EN_SET__EOBLOCK__SHIFT      2
+ #define AUD_SPDIF_IT_EN_SET__EOBLOCK__MASK       0x1
+ #define AUD_SPDIF_IT_EN_SET__EOBLOCK__VALUE__SET 0x1
+ 
+ #define AUD_SPDIF_IT_EN_SET__EOLATENCY__SHIFT      3
+ #define AUD_SPDIF_IT_EN_SET__EOLATENCY__MASK       0x1
+ #define AUD_SPDIF_IT_EN_SET__EOLATENCY__VALUE__SET 0x1
+ 
+ #define AUD_SPDIF_IT_EN_SET__EOPD__SHIFT      4
+ #define AUD_SPDIF_IT_EN_SET__EOPD__MASK       0x1
+ #define AUD_SPDIF_IT_EN_SET__EOPD__VALUE__SET 0x1
+ 
+ #define AUD_SPDIF_IT_EN_SET__NSAMPLE__SHIFT      5
+ #define AUD_SPDIF_IT_EN_SET__NSAMPLE__MASK       0x1
+ #define AUD_SPDIF_IT_EN_SET__NSAMPLE__VALUE__SET 0x1
+ 
+ 
+ 
+ #define AUD_SPDIF_IT_EN_CLR 0x18
+ 
+ #define AUD_SPDIF_IT_EN_CLR__UNF__SHIFT        0
+ #define AUD_SPDIF_IT_EN_CLR__UNF__MASK         0x1
+ #define AUD_SPDIF_IT_EN_CLR__UNF__VALUE__CLEAR 0x1
+ 
+ #define AUD_SPDIF_IT_EN_CLR__EOBURST__SHIFT        1
+ #define AUD_SPDIF_IT_EN_CLR__EOBURST__MASK         0x1
+ #define AUD_SPDIF_IT_EN_CLR__EOBURST__VALUE__CLEAR 0x1
+ 
+ #define AUD_SPDIF_IT_EN_CLR__EOBLOCK__SHIFT        2
+ #define AUD_SPDIF_IT_EN_CLR__EOBLOCK__MASK         0x1
+ #define AUD_SPDIF_IT_EN_CLR__EOBLOCK__VALUE__CLEAR 0x1
+ 
+ #define AUD_SPDIF_IT_EN_CLR__EOLATENCY__SHIFT        3
+ #define AUD_SPDIF_IT_EN_CLR__EOLATENCY__MASK         0x1
+ #define AUD_SPDIF_IT_EN_CLR__EOLATENCY__VALUE__CLEAR 0x1
+ 
+ #define AUD_SPDIF_IT_EN_CLR__EOPD__SHIFT        4
+ #define AUD_SPDIF_IT_EN_CLR__EOPD__MASK         0x1
+ #define AUD_SPDIF_IT_EN_CLR__EOPD__VALUE__CLEAR 0x1
+ 
+ #define AUD_SPDIF_IT_EN_CLR__NSAMPLE__SHIFT        5
+ #define AUD_SPDIF_IT_EN_CLR__NSAMPLE__MASK         0x1
+ #define AUD_SPDIF_IT_EN_CLR__NSAMPLE__VALUE__CLEAR 0x1
+ 
+ 
+ 
+ #define AUD_SPDIF_CTRL 0x1c
+ 
+ #define AUD_SPDIF_CTRL__MODE__SHIFT                    0
+ #define AUD_SPDIF_CTRL__MODE__MASK                     0x7
+ #define AUD_SPDIF_CTRL__MODE__VALUE__OFF               0x0
+ #define AUD_SPDIF_CTRL__MODE__VALUE__MUTE_PCM_NULL     0x1
+ #define AUD_SPDIF_CTRL__MODE__VALUE__MUTE_PAUSE_BURSTS 0x2
+ #define AUD_SPDIF_CTRL__MODE__VALUE__PCM               0x3
+ #define AUD_SPDIF_CTRL__MODE__VALUE__ENCODED           0x4
+ 
+ #define AUD_SPDIF_CTRL__IDLE__SHIFT         3
+ #define AUD_SPDIF_CTRL__IDLE__MASK          0x1
+ #define AUD_SPDIF_CTRL__IDLE__VALUE__NORMAL 0x0
+ #define AUD_SPDIF_CTRL__IDLE__VALUE__IDLE   0x1
+ 
+ #define AUD_SPDIF_CTRL__RND__SHIFT                   4
+ #define AUD_SPDIF_CTRL__RND__MASK                    0x1
+ #define AUD_SPDIF_CTRL__RND__VALUE__NO_ROUNDING      0x0
+ #define AUD_SPDIF_CTRL__RND__VALUE__16_BITS_ROUNDING 0x1
+ 
+ #define AUD_SPDIF_CTRL__CLK_DIV__SHIFT 5
+ #define AUD_SPDIF_CTRL__CLK_DIV__MASK  0xff
+ 
+ #define AUD_SPDIF_CTRL__STUFFING__SHIFT           14
+ #define AUD_SPDIF_CTRL__STUFFING__MASK            0x1
+ #define AUD_SPDIF_CTRL__STUFFING__VALUE__SOFTWARE 0x0
+ #define AUD_SPDIF_CTRL__STUFFING__VALUE__HARDWARE 0x1
+ 
+ #define AUD_SPDIF_CTRL__MEMREAD__SHIFT 15
+ #define AUD_SPDIF_CTRL__MEMREAD__MASK  0x1ffff
+ 
+ 
+ 
+ #define AUD_SPDIF_STA 0x20
+ 
+ #define AUD_SPDIF_STA__RUN_STOP__SHIFT          0
+ #define AUD_SPDIF_STA__RUN_STOP__MASK           0x1
+ #define AUD_SPDIF_STA__RUN_STOP__VALUE__STOPPED 0x0
+ #define AUD_SPDIF_STA__RUN_STOP__VALUE__RUNNING 0x1
+ 
+ #define AUD_SPDIF_STA__UNF__SHIFT           1
+ #define AUD_SPDIF_STA__UNF__MASK            0x1
+ #define AUD_SPDIF_STA__UNF__VALUE__DETECTED 0x1
+ 
+ #define AUD_SPDIF_STA__EOBURST__SHIFT      2
+ #define AUD_SPDIF_STA__EOBURST__MASK       0x1
+ #define AUD_SPDIF_STA__EOBURST__VALUE__END 0x1
+ 
+ #define AUD_SPDIF_STA__EOBLOCK__SHIFT      3
+ #define AUD_SPDIF_STA__EOBLOCK__MASK       0x1
+ #define AUD_SPDIF_STA__EOBLOCK__VALUE__END 0x1
+ 
+ #define AUD_SPDIF_STA__EOLATENCY__SHIFT                         4
+ #define AUD_SPDIF_STA__EOLATENCY__MASK                          0x1
+ #define AUD_SPDIF_STA__EOLATENCY__VALUE__END_OF_LATENCY_COUNTER 0x1
+ 
+ #define AUD_SPDIF_STA__PDDATA__SHIFT       5
+ #define AUD_SPDIF_STA__PDDATA__MASK        0x1
+ #define AUD_SPDIF_STA__PDDATA__VALUE__SENT 0x1
+ 
+ #define AUD_SPDIF_STA__NSAMPLE__SHIFT       6
+ #define AUD_SPDIF_STA__NSAMPLE__MASK        0x1
+ #define AUD_SPDIF_STA__NSAMPLE__VALUE__DONE 0x1
+ 
+ #define AUD_SPDIF_STA__PABIT__SHIFT       7
+ #define AUD_SPDIF_STA__PABIT__MASK        0xff
+ 
+ #define AUD_SPDIF_STA__PDPAUSE__SHIFT       15
+ #define AUD_SPDIF_STA__PDPAUSE__MASK        0x1
+ #define AUD_SPDIF_STA__PDPAUSE__VALUE__SENT 0x1
+ 
+ #if defined(CONFIG_CPU_SUBTYPE_STX7111)
+ #define AUD_SPDIF_STA__SAMPLES_IN_FIFO__SHIFT 16
+ #define AUD_SPDIF_STA__SAMPLES_IN_FIFO__MASK  0x1f
+ #endif
+ 
+ 
+ 
+ #define AUD_SPDIF_PA_PB 0x24
+ 
+ #define AUD_SPDIF_PA_PB__PB__SHIFT 0
+ #define AUD_SPDIF_PA_PB__PB__MASK  0xffff
+ 
+ #define AUD_SPDIF_PA_PB__PA__SHIFT 16
+ #define AUD_SPDIF_PA_PB__PA__MASK  0xffff
+ 
+ 
+ 
+ #define AUD_SPDIF_PC_PD 0x28
+ 
+ #define AUD_SPDIF_PC_PD__PD__SHIFT 0
+ #define AUD_SPDIF_PC_PD__PD__MASK  0xffff
+ 
+ #define AUD_SPDIF_PC_PD__PC__SHIFT 16
+ #define AUD_SPDIF_PC_PD__PC__MASK  0xffff
+ 
+ 
+ 
+ 
+ #define AUD_SPDIF_CL1 0x2c
+ 
+ #define AUD_SPDIF_CL1__CL1__SHIFT 0
+ #define AUD_SPDIF_CL1__CL1__MASK  0xffffffff
+ 
+ 
+ 
+ #define AUD_SPDIF_CR1 0x30
+ 
+ #define AUD_SPDIF_CR1__CR1__SHIFT 0
+ #define AUD_SPDIF_CR1__CR1__MASK  0xffffffff
+ 
+ 
+ /* LU, RU, LV & RV bits are described wrong in datasheet... */
+ #define AUD_SPDIF_CL2_CR2_UV 0x34
+ 
+ #define AUD_SPDIF_CL2_CR2_UV__CL2__SHIFT 0
+ #define AUD_SPDIF_CL2_CR2_UV__CL2__MASK  0xf
+ 
+ #define AUD_SPDIF_CL2_CR2_UV__CR2__SHIFT 8
+ #define AUD_SPDIF_CL2_CR2_UV__CR2__MASK  0xf
+ 
+ #define AUD_SPDIF_CL2_CR2_UV__LU__SHIFT  16
+ #define AUD_SPDIF_CL2_CR2_UV__LU__MASK   0x1
+ 
+ #define AUD_SPDIF_CL2_CR2_UV__RU__SHIFT  17
+ #define AUD_SPDIF_CL2_CR2_UV__RU__MASK   0x1
+ 
+ #define AUD_SPDIF_CL2_CR2_UV__LV__SHIFT  18
+ #define AUD_SPDIF_CL2_CR2_UV__LV__MASK   0x1
+ 
+ #define AUD_SPDIF_CL2_CR2_UV__RV__SHIFT  19
+ #define AUD_SPDIF_CL2_CR2_UV__RV__MASK   0x1
+ 
+ 
+ 
+ #define AUD_SPDIF_PAU_LAT 0x38
+ 
+ #define AUD_SPDIF_PAU_LAT__LAT__SHIFT 0
+ #define AUD_SPDIF_PAU_LAT__LAT__MASK  0xffff
+ 
+ #define AUD_SPDIF_PAU_LAT__NPD_BURST__SHIFT 16
+ #define AUD_SPDIF_PAU_LAT__NPD_BURST__MASK  0xffff
+ 
+ 
+ 
+ #define AUD_SPDIF_BST_FL 0x3c
+ 
+ #define AUD_SPDIF_BST_FL__PDBURST__SHIFT 0
+ #define AUD_SPDIF_BST_FL__PDBURST__MASK  0xffff
+ 
+ #define AUD_SPDIF_BST_FL__DBURST__SHIFT 16
+ #define AUD_SPDIF_BST_FL__DBURST__MASK  0xffff
+ 
+ #if defined(CONFIG_CPU_SUBTYPE_STX7111)
+ 
+ #define AUD_SPDIF_CONFIG 0x40
+ 
+ #define AUD_SPDIF_CONFIG__P_BIT__SHIFT       0
+ #define AUD_SPDIF_CONFIG__P_BIT__SHIFT__MASK 0x1
+ #define AUD_SPDIF_CONFIG__P_BIT__VALUE__HW   0x0
+ #define AUD_SPDIF_CONFIG__P_BIT__VALUE__FDMA 0x1
+ 
+ #define AUD_SPDIF_CONFIG__C_BIT__SHIFT       1
+ #define AUD_SPDIF_CONFIG__C_BIT__SHIFT__MASK 0x1
+ #define AUD_SPDIF_CONFIG__C_BIT__VALUE__FDMA 0x0
+ #define AUD_SPDIF_CONFIG__C_BIT__VALUE__HW   0x1
+ 
+ #define AUD_SPDIF_CONFIG__U_BIT__SHIFT       2
+ #define AUD_SPDIF_CONFIG__U_BIT__SHIFT__MASK 0x1
+ #define AUD_SPDIF_CONFIG__U_BIT__VALUE__FDMA 0x0
+ #define AUD_SPDIF_CONFIG__U_BIT__VALUE__HW   0x1
+ 
+ #define AUD_SPDIF_CONFIG__V_BIT__SHIFT       2
+ #define AUD_SPDIF_CONFIG__V_BIT__SHIFT__MASK 0x1
+ #define AUD_SPDIF_CONFIG__V_BIT__VALUE__FDMA 0x0
+ #define AUD_SPDIF_CONFIG__V_BIT__VALUE__HW   0x1
+ 
+ #define AUD_SPDIF_CONFIG__ONE_BIT_AUDIO__SHIFT           4
+ #define AUD_SPDIF_CONFIG__ONE_BIT_AUDIO__MASK            0x1
+ #define AUD_SPDIF_CONFIG__ONE_BIT_AUDIO__VALUE__DISABLED 0x0
+ #define AUD_SPDIF_CONFIG__ONE_BIT_AUDIO__VALUE__ENABLED  0x1
+ 
+ #define AUD_SPDIF_CONFIG__MEM_FMT__SHIFT                  5
+ #define AUD_SPDIF_CONFIG__MEM_FMT__MASK                   0x1
+ #define AUD_SPDIF_CONFIG__MEM_FMT__VALUE__16_BITS_0_BITS  0x0
+ #define AUD_SPDIF_CONFIG__MEM_FMT__VALUE__16_BITS_16_BITS 0x1
+ 
+ #define AUD_SPDIF_CONFIG__DTS_HD__SHIFT           6
+ #define AUD_SPDIF_CONFIG__DTS_HD__MASK            0x1
+ #define AUD_SPDIF_CONFIG__DTS_HD__VALUE__DISABLED 0x0
+ #define AUD_SPDIF_CONFIG__DTS_HD__VALUE__ENABLED  0x1
+ 
+ #define AUD_SPDIF_CONFIG__BACK_STALLING__SHIFT           7
+ #define AUD_SPDIF_CONFIG__BACK_STALLING__MASK            0x1
+ #define AUD_SPDIF_CONFIG__BACK_STALLING__VALUE__DISABLED 0x0
+ #define AUD_SPDIF_CONFIG__BACK_STALLING__VALUE__ENABLED  0x1
+ 
+ #define AUD_SPDIF_CONFIG__DMA_REQ_TRIG_LMT__SHIFT 8
+ #define AUD_SPDIF_CONFIG__DMA_REQ_TRIG_LMT__MASK  0x1f
+ 
+ 
+ #endif
+ 
+ #endif
diff -rcN linux-sh4-2.6.23.17_stm23_0119-orig/include/linux/stm/registers//aud_spdifpc.h linux-sh4/include/linux/stm/registers//aud_spdifpc.h
*** linux-sh4-2.6.23.17_stm23_0119-orig/include/linux/stm/registers//aud_spdifpc.h	1970-01-01 01:00:00.000000000 +0100
--- linux-sh4/include/linux/stm/registers//aud_spdifpc.h	2009-06-10 11:15:48.000000000 +0200
***************
*** 0 ****
--- 1,483 ----
+ #ifndef __STM_REGISTERS_AUD_SPDIFPC_H
+ #define __STM_REGISTERS_AUD_SPDIFPC_H
+ 
+ 
+ 
+ #define AUD_SPDIFPC_CFG 0x000
+ 
+ #define AUD_SPDIFPC_CFG__DEVICE_EN__SHIFT           0
+ #define AUD_SPDIFPC_CFG__DEVICE_EN__MASK            0x1
+ #define AUD_SPDIFPC_CFG__DEVICE_EN__VALUE__DISABLED 0x0
+ #define AUD_SPDIFPC_CFG__DEVICE_EN__VALUE__ENABLED  0x1
+ 
+ #define AUD_SPDIFPC_CFG__SW_RESET__SHIFT          1
+ #define AUD_SPDIFPC_CFG__SW_RESET__MASK           0x1
+ #define AUD_SPDIFPC_CFG__SW_RESET__VALUE__RUNNING 0x0
+ #define AUD_SPDIFPC_CFG__SW_RESET__VALUE__RESET   0x1
+ 
+ #define AUD_SPDIFPC_CFG__FIFO_EN__SHIFT           2
+ #define AUD_SPDIFPC_CFG__FIFO_EN__MASK            0x1
+ #define AUD_SPDIFPC_CFG__FIFO_EN__VALUE__DISABLED 0x0
+ #define AUD_SPDIFPC_CFG__FIFO_EN__VALUE__ENABLED  0x1
+ 
+ #define AUD_SPDIFPC_CFG__AUDIO_WORD_SIZE__SHIFT          3
+ #define AUD_SPDIFPC_CFG__AUDIO_WORD_SIZE__MASK           0x3
+ #define AUD_SPDIFPC_CFG__AUDIO_WORD_SIZE__VALUE__16_BITS 0x0
+ #define AUD_SPDIFPC_CFG__AUDIO_WORD_SIZE__VALUE__20_BITS 0x1
+ #define AUD_SPDIFPC_CFG__AUDIO_WORD_SIZE__VALUE__24_BITS 0x2
+ 
+ #define AUD_SPDIFPC_CFG__REQ_ACK_EN__SHIFT           5
+ #define AUD_SPDIFPC_CFG__REQ_ACK_EN__MASK            0x1
+ #define AUD_SPDIFPC_CFG__REQ_ACK_EN__VALUE__DISABLED 0x0
+ #define AUD_SPDIFPC_CFG__REQ_ACK_EN__VALUE__ENABLED  0x1
+ 
+ /* Undocumented configuration bit, which exists in some hardware... */
+ #define AUD_SPDIFPC_CFG__CHA_STA_BITS__SHIFT           6
+ #define AUD_SPDIFPC_CFG__CHA_STA_BITS__MASK            0x1
+ #define AUD_SPDIFPC_CFG__CHA_STA_BITS__VALUE__SUBFRAME 0x0
+ #define AUD_SPDIFPC_CFG__CHA_STA_BITS__VALUE__FRAME    0x1
+ 
+ 
+ 
+ #define AUD_SPDIFPC_STA 0x004
+ 
+ #define AUD_SPDIFPC_STA__SOFT_RESET__SHIFT         1
+ #define AUD_SPDIFPC_STA__SOFT_RESET__MASK          0x1
+ #define AUD_SPDIFPC_STA__SOFT_RESET__VALUE__ACTIVE 0x1
+ 
+ #define AUD_SPDIFPC_STA__VALIDITY_REG_EMPTY__SHIFT        2
+ #define AUD_SPDIFPC_STA__VALIDITY_REG_EMPTY__MASK         0x1
+ #define AUD_SPDIFPC_STA__VALIDITY_REG_EMPTY__VALUE__EMPTY 0x1
+ 
+ #define AUD_SPDIFPC_STA__VALIDITY_REG_UNDERRUN__SHIFT           3
+ #define AUD_SPDIFPC_STA__VALIDITY_REG_UNDERRUN__MASK            0x1
+ #define AUD_SPDIFPC_STA__VALIDITY_REG_UNDERRUN__VALUE__DETECTED 0x1
+ 
+ #define AUD_SPDIFPC_STA__USER_DATA_REG_STATUS__SHIFT        4
+ #define AUD_SPDIFPC_STA__USER_DATA_REG_STATUS__MASK         0x1
+ #define AUD_SPDIFPC_STA__USER_DATA_REG_STATUS__VALUE__EMPTY 0x1
+ 
+ #define AUD_SPDIFPC_STA__USER_DATA_REG_UNDERRUN__SHIFT           5
+ #define AUD_SPDIFPC_STA__USER_DATA_REG_UNDERRUN__MASK            0x1
+ #define AUD_SPDIFPC_STA__USER_DATA_REG_UNDERRUN__VALUE__DETECTED 0x1
+ 
+ #define AUD_SPDIFPC_STA__CHL_STS_BUFF_EMPTY__SHIFT        6
+ #define AUD_SPDIFPC_STA__CHL_STS_BUFF_EMPTY__MASK         0x1
+ #define AUD_SPDIFPC_STA__CHL_STS_BUFF_EMPTY__VALUE__EMPTY 0x1
+ 
+ #define AUD_SPDIFPC_STA__CHL_STS_BUFF_UNDERRUN__SHIFT           7
+ #define AUD_SPDIFPC_STA__CHL_STS_BUFF_UNDERRUN__MASK            0x1
+ #define AUD_SPDIFPC_STA__CHL_STS_BUFF_UNDERRUN__VALUE__DETECTED 0x1
+ 
+ #define AUD_SPDIFPC_STA__I2S_FIFO_OVERRUN__SHIFT           8
+ #define AUD_SPDIFPC_STA__I2S_FIFO_OVERRUN__MASK            0x1
+ #define AUD_SPDIFPC_STA__I2S_FIFO_OVERRUN__VALUE__DETECTED 0x1
+ 
+ #define AUD_SPDIFPC_STA__CURR_CHL_STS_BUFFER__SHIFT       16
+ #define AUD_SPDIFPC_STA__CURR_CHL_STS_BUFFER__SHIFT__MASK 0x7
+ 
+ 
+ 
+ #define AUD_SPDIFPC_IT_EN 0x008
+ 
+ #define AUD_SPDIFPC_IT_EN__INTERRUPT_EN__SHIFT           0
+ #define AUD_SPDIFPC_IT_EN__INTERRUPT_EN__MASK            0x1
+ #define AUD_SPDIFPC_IT_EN__INTERRUPT_EN__VALUE__DISABLED 0x0
+ #define AUD_SPDIFPC_IT_EN__INTERRUPT_EN__VALUE__ENABLED  0x1
+ 
+ #define AUD_SPDIFPC_IT_EN__SOFT_RESET_INT_EN__SHIFT           1
+ #define AUD_SPDIFPC_IT_EN__SOFT_RESET_INT_EN__MASK            0x1
+ #define AUD_SPDIFPC_IT_EN__SOFT_RESET_INT_EN__VALUE__DISABLED 0x0
+ #define AUD_SPDIFPC_IT_EN__SOFT_RESET_INT_EN__VALUE__ENABLED  0x1
+ 
+ #define AUD_SPDIFPC_IT_EN__VALIDITY_EMPTY_INT_EN__SHIFT           2
+ #define AUD_SPDIFPC_IT_EN__VALIDITY_EMPTY_INT_EN__MASK            0x1
+ #define AUD_SPDIFPC_IT_EN__VALIDITY_EMPTY_INT_EN__VALUE__DISABLED 0x0
+ #define AUD_SPDIFPC_IT_EN__VALIDITY_EMPTY_INT_EN__VALUE__ENABLED  0x1
+ 
+ #define AUD_SPDIFPC_IT_EN__VALIDITY_UNDERRUN_INT_EN__SHIFT           3
+ #define AUD_SPDIFPC_IT_EN__VALIDITY_UNDERRUN_INT_EN__MASK            0x1
+ #define AUD_SPDIFPC_IT_EN__VALIDITY_UNDERRUN_INT_EN__VALUE__DISABLED 0x0
+ #define AUD_SPDIFPC_IT_EN__VALIDITY_UNDERRUN_INT_EN__VALUE__ENABLED  0x1
+ 
+ #define AUD_SPDIFPC_IT_EN__USER_DATA_EMPTY_INT_EN__SHIFT           4
+ #define AUD_SPDIFPC_IT_EN__USER_DATA_EMPTY_INT_EN__MASK            0x1
+ #define AUD_SPDIFPC_IT_EN__USER_DATA_EMPTY_INT_EN__VALUE__DISABLED 0x0
+ #define AUD_SPDIFPC_IT_EN__USER_DATA_EMPTY_INT_EN__VALUE__ENABLED  0x1
+ 
+ #define AUD_SPDIFPC_IT_EN__USER_DATA_UNDERRUN_INT_EN__SHIFT           5
+ #define AUD_SPDIFPC_IT_EN__USER_DATA_UNDERRUN_INT_EN__MASK            0x1
+ #define AUD_SPDIFPC_IT_EN__USER_DATA_UNDERRUN_INT_EN__VALUE__DISABLED 0x0
+ #define AUD_SPDIFPC_IT_EN__USER_DATA_UNDERRUN_INT_EN__VALUE__ENABLED  0x1
+ 
+ #define AUD_SPDIFPC_IT_EN__CHL_STS_EMPTY_INT_EN__SHIFT           6
+ #define AUD_SPDIFPC_IT_EN__CHL_STS_EMPTY_INT_EN__MASK            0x1
+ #define AUD_SPDIFPC_IT_EN__CHL_STS_EMPTY_INT_EN__VALUE__DISABLED 0x0
+ #define AUD_SPDIFPC_IT_EN__CHL_STS_EMPTY_INT_EN__VALUE__ENABLED  0x1
+ 
+ #define AUD_SPDIFPC_IT_EN__CHL_STS_UNDERRUN_INT_EN__SHIFT           7
+ #define AUD_SPDIFPC_IT_EN__CHL_STS_UNDERRUN_INT_EN__MASK            0x1
+ #define AUD_SPDIFPC_IT_EN__CHL_STS_UNDERRUN_INT_EN__VALUE__DISABLED 0x0
+ #define AUD_SPDIFPC_IT_EN__CHL_STS_UNDERRUN_INT_EN__VALUE__ENABLED  0x1
+ 
+ #define AUD_SPDIFPC_IT_EN__I2S_FIFO_OVERRUN_INT_EN__SHIFT           8
+ #define AUD_SPDIFPC_IT_EN__I2S_FIFO_OVERRUN_INT_EN__MASK            0x1
+ #define AUD_SPDIFPC_IT_EN__I2S_FIFO_OVERRUN_INT_EN__VALUE__DISABLED 0x0
+ #define AUD_SPDIFPC_IT_EN__I2S_FIFO_OVERRUN_INT_EN__VALUE__ENABLED  0x1
+ 
+ #define AUD_SPDIFPC_IT_EN__RUN_STOP_INT_EN__SHIFT           16
+ #define AUD_SPDIFPC_IT_EN__RUN_STOP_INT_EN__MASK            0x1
+ #define AUD_SPDIFPC_IT_EN__RUN_STOP_INT_EN__VALUE__DISABLED 0x0
+ #define AUD_SPDIFPC_IT_EN__RUN_STOP_INT_EN__VALUE__ENABLED  0x1
+ 
+ #define AUD_SPDIFPC_IT_EN__UNDERFLOW_INT_EN__SHIFT           17
+ #define AUD_SPDIFPC_IT_EN__UNDERFLOW_INT_EN__MASK            0x1
+ #define AUD_SPDIFPC_IT_EN__UNDERFLOW_INT_EN__VALUE__DISABLED 0x0
+ #define AUD_SPDIFPC_IT_EN__UNDERFLOW_INT_EN__VALUE__ENABLED  0x1
+ 
+ #define AUD_SPDIFPC_IT_EN__EODATABURST_INT_EN__SHIFT           18
+ #define AUD_SPDIFPC_IT_EN__EODATABURST_INT_EN__MASK            0x1
+ #define AUD_SPDIFPC_IT_EN__EODATABURST_INT_EN__VALUE__DISABLED 0x0
+ #define AUD_SPDIFPC_IT_EN__EODATABURST_INT_EN__VALUE__ENABLED  0x1
+ 
+ #define AUD_SPDIFPC_IT_EN__EOBLOCK_INT_EN__SHIFT           19
+ #define AUD_SPDIFPC_IT_EN__EOBLOCK_INT_EN__MASK            0x1
+ #define AUD_SPDIFPC_IT_EN__EOBLOCK_INT_EN__VALUE__DISABLED 0x0
+ #define AUD_SPDIFPC_IT_EN__EOBLOCK_INT_EN__VALUE__ENABLED  0x1
+ 
+ #define AUD_SPDIFPC_IT_EN__LATENCY_INT_EN__SHIFT           20
+ #define AUD_SPDIFPC_IT_EN__LATENCY_INT_EN__MASK            0x1
+ #define AUD_SPDIFPC_IT_EN__LATENCY_INT_EN__VALUE__DISABLED 0x0
+ #define AUD_SPDIFPC_IT_EN__LATENCY_INT_EN__VALUE__ENABLED  0x1
+ 
+ #define AUD_SPDIFPC_IT_EN__PD_DATA_BURST__SHIFT           21
+ #define AUD_SPDIFPC_IT_EN__PD_DATA_BURST__MASK            0x1
+ #define AUD_SPDIFPC_IT_EN__PD_DATA_BURST__VALUE__DISABLED 0x0
+ #define AUD_SPDIFPC_IT_EN__PD_DATA_BURST__VALUE__ENABLED  0x1
+ 
+ #define AUD_SPDIFPC_IT_EN__SAMPLES_READ_INT_EN__SHIFT           22
+ #define AUD_SPDIFPC_IT_EN__SAMPLES_READ_INT_EN__MASK            0x1
+ #define AUD_SPDIFPC_IT_EN__SAMPLES_READ_INT_EN__VALUE__DISABLED 0x0
+ #define AUD_SPDIFPC_IT_EN__SAMPLES_READ_INT_EN__VALUE__ENABLED  0x1
+ 
+ #define AUD_SPDIFPC_IT_EN__PD_PAUSE_BURST_INT_EN__SHIFT           31
+ #define AUD_SPDIFPC_IT_EN__PD_PAUSE_BURST_INT_EN__MASK            0x1
+ #define AUD_SPDIFPC_IT_EN__PD_PAUSE_BURST_INT_EN__VALUE__DISABLED 0x0
+ #define AUD_SPDIFPC_IT_EN__PD_PAUSE_BURST_INT_EN__VALUE__ENABLED  0x1
+ 
+ 
+ 
+ #define AUD_SPDIFPC_ITS 0x00c
+ 
+ #define AUD_SPDIFPC_ITS__INTERRUPT__SHIFT          0
+ #define AUD_SPDIFPC_ITS__INTERRUPT__MASK           0x1
+ #define AUD_SPDIFPC_ITS__INTERRUPT__VALUE__PENDING 0x1
+ 
+ #define AUD_SPDIFPC_ITS__SOFT_RESET_INT__SHIFT          1
+ #define AUD_SPDIFPC_ITS__SOFT_RESET_INT__MASK           0x1
+ #define AUD_SPDIFPC_ITS__SOFT_RESET_INT__VALUE__PENDING 0x1
+ 
+ #define AUD_SPDIFPC_ITS__VALIDITY_EMPTY_INT__SHIFT          2
+ #define AUD_SPDIFPC_ITS__VALIDITY_EMPTY_INT__MASK           0x1
+ #define AUD_SPDIFPC_ITS__VALIDITY_EMPTY_INT__VALUE__PENDING 0x1
+ 
+ #define AUD_SPDIFPC_ITS__VALIDITY_UNDERRUN_INT__SHIFT          3
+ #define AUD_SPDIFPC_ITS__VALIDITY_UNDERRUN_INT__MASK           0x1
+ #define AUD_SPDIFPC_ITS__VALIDITY_UNDERRUN_INT__VALUE__PENDING 0x1
+ 
+ #define AUD_SPDIFPC_ITS__USER_DATA_EMPTY_INT__SHIFT          4
+ #define AUD_SPDIFPC_ITS__USER_DATA_EMPTY_INT__MASK           0x1
+ #define AUD_SPDIFPC_ITS__USER_DATA_EMPTY_INT__VALUE__PENDING 0x1
+ 
+ #define AUD_SPDIFPC_ITS__USER_DATA_UNDERRUN_INT__SHIFT          5
+ #define AUD_SPDIFPC_ITS__USER_DATA_UNDERRUN_INT__MASK           0x1
+ #define AUD_SPDIFPC_ITS__USER_DATA_UNDERRUN_INT__VALUE__PENDING 0x1
+ 
+ #define AUD_SPDIFPC_ITS__CHL_STS_EMPTY_INT__SHIFT          6
+ #define AUD_SPDIFPC_ITS__CHL_STS_EMPTY_INT__MASK           0x1
+ #define AUD_SPDIFPC_ITS__CHL_STS_EMPTY_INT__VALUE__PENDING 0x1
+ 
+ #define AUD_SPDIFPC_ITS__CHL_STS_UNDERRUN_INT__SHIFT          7
+ #define AUD_SPDIFPC_ITS__CHL_STS_UNDERRUN_INT__MASK           0x1
+ #define AUD_SPDIFPC_ITS__CHL_STS_UNDERRUN_INT__VALUE__PENDING 0x1
+ 
+ #define AUD_SPDIFPC_ITS__I2S_FIFO_OVERRUN_INT__SHIFT          8
+ #define AUD_SPDIFPC_ITS__I2S_FIFO_OVERRUN_INT__MASK           0x1
+ #define AUD_SPDIFPC_ITS__I2S_FIFO_OVERRUN_INT__VALUE__PENDING 0x1
+ 
+ #define AUD_SPDIFPC_ITS__RUN_STOP_INT__SHIFT          16
+ #define AUD_SPDIFPC_ITS__RUN_STOP_INT__MASK           0x1
+ #define AUD_SPDIFPC_ITS__RUN_STOP_INT__VALUE__PENDING 0x1
+ 
+ #define AUD_SPDIFPC_ITS__UNDERFLOW_INT__SHIFT          17
+ #define AUD_SPDIFPC_ITS__UNDERFLOW_INT__MASK           0x1
+ #define AUD_SPDIFPC_ITS__UNDERFLOW_INT__VALUE__PENDING 0x1
+ 
+ #define AUD_SPDIFPC_ITS__EODATABURST_INT__SHIFT          18
+ #define AUD_SPDIFPC_ITS__EODATABURST_INT__MASK           0x1
+ #define AUD_SPDIFPC_ITS__EODATABURST_INT__VALUE__PENDING 0x1
+ 
+ #define AUD_SPDIFPC_ITS__EOBLOCK_INT__SHIFT          19
+ #define AUD_SPDIFPC_ITS__EOBLOCK_INT__MASK           0x1
+ #define AUD_SPDIFPC_ITS__EOBLOCK_INT__VALUE__PENDING 0x1
+ 
+ #define AUD_SPDIFPC_ITS__LATENCY_INT__SHIFT          20
+ #define AUD_SPDIFPC_ITS__LATENCY_INT__MASK           0x1
+ #define AUD_SPDIFPC_ITS__LATENCY_INT__VALUE__PENDING 0x1
+ 
+ #define AUD_SPDIFPC_ITS__PD_DATA_BURST__SHIFT          21
+ #define AUD_SPDIFPC_ITS__PD_DATA_BURST__MASK           0x1
+ #define AUD_SPDIFPC_ITS__PD_DATA_BURST__VALUE__PENDING 0x1
+ 
+ #define AUD_SPDIFPC_ITS__SAMPLES_READ_INT__SHIFT          22
+ #define AUD_SPDIFPC_ITS__SAMPLES_READ_INT__MASK           0x1
+ #define AUD_SPDIFPC_ITS__SAMPLES_READ_INT__VALUE__PENDING 0x1
+ 
+ #define AUD_SPDIFPC_ITS__PD_PAUSE_BURST_INT__SHIFT          31
+ #define AUD_SPDIFPC_ITS__PD_PAUSE_BURST_INT__MASK           0x1
+ #define AUD_SPDIFPC_ITS__PD_PAUSE_BURST_INT__VALUE__PENDING 0x1
+ 
+ 
+ 
+ #define AUD_SPDIFPC_IT_CLR 0x010
+ 
+ #define AUD_SPDIFPC_IT_CLR__INTERRUPT_EN__SHIFT        0
+ #define AUD_SPDIFPC_IT_CLR__INTERRUPT_EN__MASK         0x1
+ #define AUD_SPDIFPC_IT_CLR__INTERRUPT_EN__VALUE__CLEAR 0x1
+ 
+ #define AUD_SPDIFPC_IT_CLR__SOFT_RESET_INT_EN__SHIFT        1
+ #define AUD_SPDIFPC_IT_CLR__SOFT_RESET_INT_EN__MASK         0x1
+ #define AUD_SPDIFPC_IT_CLR__SOFT_RESET_INT_EN__VALUE__CLEAR 0x1
+ 
+ #define AUD_SPDIFPC_IT_CLR__VALIDITY_EMPTY_INT_EN__SHIFT        2
+ #define AUD_SPDIFPC_IT_CLR__VALIDITY_EMPTY_INT_EN__MASK         0x1
+ #define AUD_SPDIFPC_IT_CLR__VALIDITY_EMPTY_INT_EN__VALUE__CLEAR 0x1
+ 
+ #define AUD_SPDIFPC_IT_CLR__VALIDITY_UNDERRUN_INT_EN__SHIFT        3
+ #define AUD_SPDIFPC_IT_CLR__VALIDITY_UNDERRUN_INT_EN__MASK         0x1
+ #define AUD_SPDIFPC_IT_CLR__VALIDITY_UNDERRUN_INT_EN__VALUE__CLEAR 0x1
+ 
+ #define AUD_SPDIFPC_IT_CLR__USER_DATA_EMPTY_INT_EN__SHIFT        4
+ #define AUD_SPDIFPC_IT_CLR__USER_DATA_EMPTY_INT_EN__MASK         0x1
+ #define AUD_SPDIFPC_IT_CLR__USER_DATA_EMPTY_INT_EN__VALUE__CLEAR 0x1
+ 
+ #define AUD_SPDIFPC_IT_CLR__USER_DATA_UNDERRUN_INT_EN__SHIFT        5
+ #define AUD_SPDIFPC_IT_CLR__USER_DATA_UNDERRUN_INT_EN__MASK         0x1
+ #define AUD_SPDIFPC_IT_CLR__USER_DATA_UNDERRUN_INT_EN__VALUE__CLEAR 0x1
+ 
+ #define AUD_SPDIFPC_IT_CLR__CHL_STS_EMPTY_INT_EN__SHIFT        6
+ #define AUD_SPDIFPC_IT_CLR__CHL_STS_EMPTY_INT_EN__MASK         0x1
+ #define AUD_SPDIFPC_IT_CLR__CHL_STS_EMPTY_INT_EN__VALUE__CLEAR 0x1
+ 
+ #define AUD_SPDIFPC_IT_CLR__CHL_STS_UNDERRUN_INT_EN__SHIFT        7
+ #define AUD_SPDIFPC_IT_CLR__CHL_STS_UNDERRUN_INT_EN__MASK         0x1
+ #define AUD_SPDIFPC_IT_CLR__CHL_STS_UNDERRUN_INT_EN__VALUE__CLEAR 0x1
+ 
+ #define AUD_SPDIFPC_IT_CLR__I2S_FIFO_OVERRUN_INT_EN__SHIFT        8
+ #define AUD_SPDIFPC_IT_CLR__I2S_FIFO_OVERRUN_INT_EN__MASK         0x1
+ #define AUD_SPDIFPC_IT_CLR__I2S_FIFO_OVERRUN_INT_EN__VALUE__CLEAR 0x1
+ 
+ #define AUD_SPDIFPC_IT_CLR__RUN_STOP_INT_EN__SHIFT        16
+ #define AUD_SPDIFPC_IT_CLR__RUN_STOP_INT_EN__MASK         0x1
+ #define AUD_SPDIFPC_IT_CLR__RUN_STOP_INT_EN__VALUE__CLEAR 0x1
+ 
+ #define AUD_SPDIFPC_IT_CLR__UNDERFLOW_INT_EN__SHIFT        17
+ #define AUD_SPDIFPC_IT_CLR__UNDERFLOW_INT_EN__MASK         0x1
+ #define AUD_SPDIFPC_IT_CLR__UNDERFLOW_INT_EN__VALUE__CLEAR 0x1
+ 
+ #define AUD_SPDIFPC_IT_CLR__EODATABURST_INT_EN__SHIFT        18
+ #define AUD_SPDIFPC_IT_CLR__EODATABURST_INT_EN__MASK         0x1
+ #define AUD_SPDIFPC_IT_CLR__EODATABURST_INT_EN__VALUE__CLEAR 0x1
+ 
+ #define AUD_SPDIFPC_IT_CLR__EOBLOCK_INT_EN__SHIFT        19
+ #define AUD_SPDIFPC_IT_CLR__EOBLOCK_INT_EN__MASK         0x1
+ #define AUD_SPDIFPC_IT_CLR__EOBLOCK_INT_EN__VALUE__CLEAR 0x1
+ 
+ #define AUD_SPDIFPC_IT_CLR__LATENCY_INT_EN__SHIFT        20
+ #define AUD_SPDIFPC_IT_CLR__LATENCY_INT_EN__MASK         0x1
+ #define AUD_SPDIFPC_IT_CLR__LATENCY_INT_EN__VALUE__CLEAR 0x1
+ 
+ #define AUD_SPDIFPC_IT_CLR__PD_DATA_BURST__SHIFT        21
+ #define AUD_SPDIFPC_IT_CLR__PD_DATA_BURST__MASK         0x1
+ #define AUD_SPDIFPC_IT_CLR__PD_DATA_BURST__VALUE__CLEAR 0x1
+ 
+ #define AUD_SPDIFPC_IT_CLR__SAMPLES_READ_INT_EN__SHIFT        22
+ #define AUD_SPDIFPC_IT_CLR__SAMPLES_READ_INT_EN__MASK         0x1
+ #define AUD_SPDIFPC_IT_CLR__SAMPLES_READ_INT_EN__VALUE__CLEAR 0x1
+ 
+ #define AUD_SPDIFPC_IT_CLR__PD_PAUSE_BURST_INT_EN__SHIFT        31
+ #define AUD_SPDIFPC_IT_CLR__PD_PAUSE_BURST_INT_EN__MASK         0x1
+ #define AUD_SPDIFPC_IT_CLR__PD_PAUSE_BURST_INT_EN__VALUE__CLEAR 0x1
+ 
+ 
+ 
+ #define AUD_SPDIFPC_VAL 0x100
+ 
+ #define AUD_SPDIFPC_VAL__VALIDITY_BITS__SHIFT 0
+ #define AUD_SPDIFPC_VAL__VALIDITY_BITS__MASK  0xffffffff
+ 
+ 
+ 
+ #define AUD_SPDIFPC_DATA 0x104
+ 
+ #define AUD_SPDIFPC_DATA__USER_DATA_BITS__SHIFT 0
+ #define AUD_SPDIFPC_DATA__USER_DATA_BITS__MASK  0xffffffff
+ 
+ 
+ 
+ #define AUD_SPDIFPC_CHA_STA(n) (0x108 + (n) * 4)
+ 
+ #define AUD_SPDIFPC_CHA_STA__CHA_STA__SHIFT 0
+ #define AUD_SPDIFPC_CHA_STA__CHA_STA__MASK  0xffffffff
+ 
+ 
+ 
+ #define AUD_SPDIFPC_CTRL 0x200
+ 
+ #define AUD_SPDIFPC_CTRL__OPERATION__SHIFT                    0
+ #define AUD_SPDIFPC_CTRL__OPERATION__MASK                     0x7
+ #define AUD_SPDIFPC_CTRL__OPERATION__VALUE__OFF               0x0
+ #define AUD_SPDIFPC_CTRL__OPERATION__VALUE__MUTE_PCM_NULL     0x1
+ #define AUD_SPDIFPC_CTRL__OPERATION__VALUE__MUTE_PAUSE_BURSTS 0x2
+ #define AUD_SPDIFPC_CTRL__OPERATION__VALUE__PCM               0x3
+ #define AUD_SPDIFPC_CTRL__OPERATION__VALUE__ENCODED           0x4
+ 
+ #define AUD_SPDIFPC_CTRL__IDLE_STATE__SHIFT         3
+ #define AUD_SPDIFPC_CTRL__IDLE_STATE__MASK          0x1
+ #define AUD_SPDIFPC_CTRL__IDLE_STATE__VALUE__NORMAL 0x0
+ #define AUD_SPDIFPC_CTRL__IDLE_STATE__VALUE__IDLE   0x1
+ 
+ #define AUD_SPDIFPC_CTRL__ROUNDING__SHIFT                   4
+ #define AUD_SPDIFPC_CTRL__ROUNDING__MASK                    0x1
+ #define AUD_SPDIFPC_CTRL__ROUNDING__VALUE__NO_ROUNDING      0x0
+ #define AUD_SPDIFPC_CTRL__ROUNDING__VALUE__16_BITS_ROUNDING 0x1
+ 
+ #define AUD_SPDIFPC_CTRL__DIVIDER__SHIFT 5
+ #define AUD_SPDIFPC_CTRL__DIVIDER__MASK  0xff
+ 
+ #define AUD_SPDIFPC_CTRL__STUFFING__SHIFT           14
+ #define AUD_SPDIFPC_CTRL__STUFFING__MASK            0x1
+ #define AUD_SPDIFPC_CTRL__STUFFING__VALUE__SOFTWARE 0x0
+ #define AUD_SPDIFPC_CTRL__STUFFING__VALUE__HARDWARE 0x1
+ 
+ #define AUD_SPDIFPC_CTRL__NO_SAMPLES__SHIFT 15
+ #define AUD_SPDIFPC_CTRL__NO_SAMPLES__MASK  0x1ffff
+ 
+ 
+ 
+ #define AUD_SPDIFPC_SPDIFSTA 0x204
+ 
+ #define AUD_SPDIFPC_SPDIFSTA__RUN_STOP__SHIFT          0
+ #define AUD_SPDIFPC_SPDIFSTA__RUN_STOP__MASK           0x1
+ #define AUD_SPDIFPC_SPDIFSTA__RUN_STOP__VALUE__STOPPED 0x0
+ #define AUD_SPDIFPC_SPDIFSTA__RUN_STOP__VALUE__RUNNING 0x1
+ 
+ #define AUD_SPDIFPC_SPDIFSTA__UNDERFLOW__SHIFT           1
+ #define AUD_SPDIFPC_SPDIFSTA__UNDERFLOW__MASK            0x1
+ #define AUD_SPDIFPC_SPDIFSTA__UNDERFLOW__VALUE__DETECTED 0x1
+ 
+ #define AUD_SPDIFPC_SPDIFSTA__EODATABURST__SHIFT      2
+ #define AUD_SPDIFPC_SPDIFSTA__EODATABURST__MASK       0x1
+ #define AUD_SPDIFPC_SPDIFSTA__EODATABURST__VALUE__END 0x1
+ 
+ #define AUD_SPDIFPC_SPDIFSTA__EOBLOCK__SHIFT      3
+ #define AUD_SPDIFPC_SPDIFSTA__EOBLOCK__MASK       0x1
+ #define AUD_SPDIFPC_SPDIFSTA__EOBLOCK__VALUE__END 0x1
+ 
+ #define AUD_SPDIFPC_SPDIFSTA__LATENCY__SHIFT                         4
+ #define AUD_SPDIFPC_SPDIFSTA__LATENCY__MASK                          0x1
+ #define AUD_SPDIFPC_SPDIFSTA__LATENCY__VALUE__END_OF_LATENCY_COUNTER 0x1
+ 
+ #define AUD_SPDIFPC_SPDIFSTA__PD_DATABURST__SHIFT       5
+ #define AUD_SPDIFPC_SPDIFSTA__PD_DATABURST__MASK        0x1
+ #define AUD_SPDIFPC_SPDIFSTA__PD_DATABURST__VALUE__SENT 0x1
+ 
+ #define AUD_SPDIFPC_SPDIFSTA__AUDIO_READ__SHIFT       6
+ #define AUD_SPDIFPC_SPDIFSTA__AUDIO_READ__MASK        0x1
+ #define AUD_SPDIFPC_SPDIFSTA__AUDIO_READ__VALUE__DONE 0x1
+ 
+ #define AUD_SPDIFPC_SPDIFSTA__PA_C_BIT_NUMBER__SHIFT       7
+ #define AUD_SPDIFPC_SPDIFSTA__PA_C_BIT_NUMBER__MASK        0xff
+ 
+ #define AUD_SPDIFPC_SPDIFSTA__PD_PAUSEBURST__SHIFT       5
+ #define AUD_SPDIFPC_SPDIFSTA__PD_PAUSEBURST__MASK        0x1
+ #define AUD_SPDIFPC_SPDIFSTA__PD_PAUSEBURST__VALUE__SENT 0x1
+ 
+ 
+ 
+ #define AUD_SPDIFPC_PAUSE 0x208
+ 
+ #define AUD_SPDIFPC_PAUSE__PAUSE_LENGTH__SHIFT 0
+ #define AUD_SPDIFPC_PAUSE__PAUSE_LENGTH__MASK  0xffff
+ 
+ #define AUD_SPDIFPC_PAUSE__PAUSE_LAT__SHIFT 16
+ #define AUD_SPDIFPC_PAUSE__PAUSE_LAT__MASK  0xffff
+ 
+ 
+ 
+ #define AUD_SPDIFPC_DATA_BURST 0x20c
+ 
+ #define AUD_SPDIFPC_DATA_BURST__DATA_BURST__SHIFT 0
+ #define AUD_SPDIFPC_DATA_BURST__DATA_BURST__MASK  0xffff
+ 
+ #define AUD_SPDIFPC_DATA_BURST__PAUSE_BURST__SHIFT 16
+ #define AUD_SPDIFPC_DATA_BURST__PAUSE_BURST__MASK  0xffff
+ 
+ 
+ 
+ #define AUD_SPDIFPC_PA_PB 0x210
+ 
+ #define AUD_SPDIFPC_PA_PB__PB__SHIFT 0
+ #define AUD_SPDIFPC_PA_PB__PB__MASK  0xffff
+ 
+ #define AUD_SPDIFPC_PA_PB__PA__SHIFT 16
+ #define AUD_SPDIFPC_PA_PB__PA__MASK  0xffff
+ 
+ 
+ 
+ #define AUD_SPDIFPC_PC_PD 0x214
+ 
+ #define AUD_SPDIFPC_PC_PD__PD__SHIFT 0
+ #define AUD_SPDIFPC_PC_PD__PD__MASK  0xffff
+ 
+ #define AUD_SPDIFPC_PC_PD__PC__SHIFT 16
+ #define AUD_SPDIFPC_PC_PD__PC__MASK  0xffff
+ 
+ 
+ 
+ 
+ #define AUD_SPDIFPC_CL1 0x218
+ 
+ #define AUD_SPDIFPC_CL1__CHANNEL_STATUS__SHIFT 0
+ #define AUD_SPDIFPC_CL1__CHANNEL_STATUS__MASK  0xffffffff
+ 
+ 
+ 
+ #define AUD_SPDIFPC_CR1 0x21c
+ 
+ #define AUD_SPDIFPC_CR1__CH_STA__SHIFT 0
+ #define AUD_SPDIFPC_CR1__CH_STA__MASK  0xffffffff
+ 
+ 
+ 
+ #define AUD_SPDIFPC_SUV 0x220
+ 
+ #define AUD_SPDIFPC_SUV__CH_STA_LEFT__SHIFT 0
+ #define AUD_SPDIFPC_SUV__CH_STA_LEFT__MASK  0xf
+ 
+ #define AUD_SPDIFPC_SUV__CH_STA_RIGHT__SHIFT 8
+ #define AUD_SPDIFPC_SUV__CH_STA_RIGHT__MASK  0xf
+ 
+ #define AUD_SPDIFPC_SUV__DATA_LEFT__SHIFT  16
+ #define AUD_SPDIFPC_SUV__DATA_LEFT__MASK   0x1
+ 
+ #define AUD_SPDIFPC_SUV__DATA_RIGHT__SHIFT  17
+ #define AUD_SPDIFPC_SUV__DATA_RIGHT__MASK   0x1
+ 
+ #define AUD_SPDIFPC_SUV__VAL_LEFT__SHIFT  18
+ #define AUD_SPDIFPC_SUV__VAL_LEFT__MASK   0x1
+ 
+ #define AUD_SPDIFPC_SUV__VAL_RIGHT__SHIFT  19
+ #define AUD_SPDIFPC_SUV__VAL_RIGHT__MASK   0x1
+ 
+ #endif
diff -rcN linux-sh4-2.6.23.17_stm23_0119-orig/include/linux/stm/registers//pwm.h linux-sh4/include/linux/stm/registers//pwm.h
*** linux-sh4-2.6.23.17_stm23_0119-orig/include/linux/stm/registers//pwm.h	1970-01-01 01:00:00.000000000 +0100
--- linux-sh4/include/linux/stm/registers//pwm.h	2009-06-10 11:15:48.000000000 +0200
***************
*** 0 ****
--- 1,131 ----
+ #ifndef __STM_REGISTERS_PWM_H
+ #define __STM_REGISTERS_PWM_H
+ 
+ 
+ 
+ #define PWM_VAL(n) (0x00 + n * 0x04) /* R/W */
+ 
+ #define PWM_VAL__PWM_VAL__SHIFT 0
+ #define PWM_VAL__PWM_VAL__MASK  0xff
+ 
+ 
+ 
+ #define PWM_CPT_VAL(n) (0x10 + (n * 0x04)) /* RO */
+ 
+ #define PWM_CPT_VAL__CPT_VAL__SHIFT 0
+ #define PWM_CPT_VAL__CPT_VAL__MASK  0xffffffff
+ 
+ 
+ 
+ #define PWM_CMP_VAL(n) (0x20 + (n * 0x04)) /* R/W */
+ 
+ #define PWM_CMP_VAL__CMP_VAL__SHIFT 0
+ #define PWM_CMP_VAL__CMP_VAL__MASK  0xffffffff
+ 
+ 
+ 
+ #define PWM_CPT_EDGE(n) (0x30 + (n * 0x04)) /* R/W */
+ 
+ #define PWM_CPT_EDGE__CE__SHIFT 0
+ #define PWM_CPT_EDGE__CE__MASK  0x3
+ 
+ 
+ 
+ #define PWM_CMP_OUT_VAL(n) (0x40 + (n * 0x04)) /* R/W */
+ 
+ #define PWM_CMP_OUT_VAL__CO__SHIFT 0
+ #define PWM_CMP_OUT_VAL__CO__MASK  0x1
+ 
+ 
+ 
+ #define PWM_CTRL 0x50 /* R/W */
+ 
+ #define PWM_CTRL__PWM_CLK_VAL_3_0__SHIFT 0
+ #define PWM_CTRL__PWM_CLK_VAL_3_0__MASK  0xf
+ 
+ #define PWM_CTRL__CPT_CLK_VAL_4_0__SHIFT 4
+ #define PWM_CTRL__CPT_CLK_VAL_4_0__MASK  0x1f
+ 
+ #define PWM_CTRL__PWM_EN__SHIFT 9
+ #define PWM_CTRL__PWM_EN__MASK  0x1
+ 
+ #define PWM_CTRL__CPT_EN__SHIFT 10
+ #define PWM_CTRL__CPT_EN__MASK  0x1
+ 
+ #define PWM_CTRL__PWM_CLK_VAL_7_4__SHIFT 11
+ #define PWM_CTRL__PWM_CLK_VAL_7_4__MASK	 0xf
+ 
+ 
+ 
+ #define PWM_INT_EN 0x54 /* R/W */
+ 
+ #define PWM_INT_EN__EN__SHIFT 0
+ #define PWM_INT_EN__EN__MASK  0x1
+ 
+ #define PWM_INT_EN__CPT0_INT_EN__SHIFT 1
+ #define PWM_INT_EN__CPT0_INT_EN__MASK  0x1
+ 
+ #define PWM_INT_EN__CPT1_INT_EN__SHIFT 2
+ #define PWM_INT_EN__CPT1_INT_EN__MASK  0x1
+ 
+ #define PWM_INT_EN__CMP0_INT_EN__SHIFT 5
+ #define PWM_INT_EN__CMP0_INT_EN__MASK  0x1
+ 
+ #define PWM_INT_EN__CMP1_INT_EN__SHIFT 6
+ #define PWM_INT_EN__CMP1_INT_EN__MASK  0x1
+ 
+ 
+ 
+ #define PWM_INT_STA 0x58 /* RO */
+ 
+ #define PWM_INT_STA__PWM_INT__SHIFT  0
+ #define PWM_INT_STA__PWM_INT__MASK   0x1
+ 
+ #define PWM_INT_STA__CPT0_INT__SHIFT 1
+ #define PWM_INT_STA__CPT0_INT__MASK  0x1
+ 
+ #define PWM_INT_STA__CPT1_INT__SHIFT 2
+ #define PWM_INT_STA__CPT1_INT__MASK  0x1
+ 
+ #define PWM_INT_STA__CMP0_INT__SHIFT 5
+ #define PWM_INT_STA__CMP0_INT__MASK  0x1
+ 
+ #define PWM_INT_STA__CMP1_INT__SHIFT 6
+ #define PWM_INT_STA__CMP1_INT__MASK  0x1
+ 
+ 
+ 
+ #define PWM_INT_ACK 0x5c /* WO */
+ 
+ #define PWM_INT_ACK__PWM_INT__SHIFT 0
+ #define PWM_INT_ACK__PWM_INT__MASK  0x1
+ 
+ #define PWM_INT_ACK__CPT0_INT__SHIFT 1
+ #define PWM_INT_ACK__CPT0_INT__MASK  0x1
+ 
+ #define PWM_INT_ACK__CPT1_INT__SHIFT 2
+ #define PWM_INT_ACK__CPT1_INT__MASK  0x1
+ 
+ #define PWM_INT_ACK__CMP0_INT__SHIFT 5
+ #define PWM_INT_ACK__CMP0_INT__MASK  0x1
+ 
+ #define PWM_INT_ACK__CMP1_INT__SHIFT 6
+ #define PWM_INT_ACK__CMP1_INT__MASK  0x1
+ 
+ 
+ 
+ #define PWM_CNT 0x60 /* R, W only when PWM timer is disabled */
+ 
+ #define PWM_CNT__PWM_CNT__SHIFT 0
+ #define PWM_CNT__PWM_CNT__MASK  0xff
+ 
+ 
+ 
+ #define PWM_CPT_CMP_CNT 0x64 /* R/W */
+ 
+ #define PWM_CPT_CMP_CNT__CPT_CMP_CNT__SHIFT 0
+ #define PWM_CPT_CMP_CNT__CPT_CMP_CNT__MASK  0xffffffff
+ 
+ 
+ 
+ #endif
diff -rcN linux-sh4-2.6.23.17_stm23_0119-orig/include/linux/stm/registers//stx710x/audcfg.h linux-sh4/include/linux/stm/registers//stx710x/audcfg.h
*** linux-sh4-2.6.23.17_stm23_0119-orig/include/linux/stm/registers//stx710x/audcfg.h	1970-01-01 01:00:00.000000000 +0100
--- linux-sh4/include/linux/stm/registers//stx710x/audcfg.h	2009-06-10 11:15:48.000000000 +0200
***************
*** 0 ****
--- 1,36 ----
+ #ifndef __STM_REGISTERS_STX710x_AUDCFG_H
+ #define __STM_REGISTERS_STX710x_AUDCFG_H
+ 
+ 
+ 
+ #define AUDCFG_IO_CTRL 0x00
+ 
+ #define AUDCFG_IO_CTRL__PCM_CLK_EN__SHIFT         0
+ #define AUDCFG_IO_CTRL__PCM_CLK_EN__MASK          0x1
+ #define AUDCFG_IO_CTRL__PCM_CLK_EN__VALUE__INPUT  0x0
+ #define AUDCFG_IO_CTRL__PCM_CLK_EN__VALUE__OUTPUT 0x1
+ 
+ #define AUDCFG_IO_CTRL__DATA0_EN__SHIFT         1
+ #define AUDCFG_IO_CTRL__DATA0_EN__MASK          0x1
+ #define AUDCFG_IO_CTRL__DATA0_EN__VALUE__INPUT  0x0
+ #define AUDCFG_IO_CTRL__DATA0_EN__VALUE__OUTPUT 0x1
+ 
+ #define AUDCFG_IO_CTRL__DATA1_EN__SHIFT         2
+ #define AUDCFG_IO_CTRL__DATA1_EN__MASK          0x1
+ #define AUDCFG_IO_CTRL__DATA1_EN__VALUE__INPUT  0x0
+ #define AUDCFG_IO_CTRL__DATA1_EN__VALUE__OUTPUT 0x1
+ 
+ #define AUDCFG_IO_CTRL__SPDIF_EN__SHIFT          3
+ #define AUDCFG_IO_CTRL__SPDIF_EN__MASK           0x1
+ #define AUDCFG_IO_CTRL__SPDIF_EN__VALUE__DISABLE 0x0
+ #define AUDCFG_IO_CTRL__SPDIF_EN__VALUE__ENABLE  0x1
+ 
+ #define AUDCFG_IO_CTRL__HDMI_AUD_SRC__SHIFT               4
+ #define AUDCFG_IO_CTRL__HDMI_AUD_SRC__MASK                0x1
+ #define AUDCFG_IO_CTRL__HDMI_AUD_SRC__VALUE__PCM_PLAYER   0x0
+ #define AUDCFG_IO_CTRL__HDMI_AUD_SRC__VALUE__SPDIF_PLAYER 0x1
+ /* Actually, in 7109 it seems to be a separate register (offset 0x04...) */
+ 
+ 
+ 
+ #endif
diff -rcN linux-sh4-2.6.23.17_stm23_0119-orig/include/linux/stm/registers//stx7111/audcfg.h linux-sh4/include/linux/stm/registers//stx7111/audcfg.h
*** linux-sh4-2.6.23.17_stm23_0119-orig/include/linux/stm/registers//stx7111/audcfg.h	1970-01-01 01:00:00.000000000 +0100
--- linux-sh4/include/linux/stm/registers//stx7111/audcfg.h	2009-06-10 11:15:48.000000000 +0200
***************
*** 0 ****
--- 1,29 ----
+ #ifndef __STM_REGISTERS_STX7111_AUDCFG_H
+ #define __STM_REGISTERS_STX7111_AUDCFG_H
+ 
+ 
+ 
+ #define AUDCFG_IO_CTRL 0x00
+ 
+ #define AUDCFG_IO_CTRL__PCM_CLK_EN__SHIFT         0
+ #define AUDCFG_IO_CTRL__PCM_CLK_EN__MASK          0x1
+ #define AUDCFG_IO_CTRL__PCM_CLK_EN__VALUE__INPUT  0x0
+ #define AUDCFG_IO_CTRL__PCM_CLK_EN__VALUE__OUTPUT 0x1
+ 
+ #define AUDCFG_IO_CTRL__SPDIFHDMI_EN__SHIFT         3
+ #define AUDCFG_IO_CTRL__SPDIFHDMI_EN__MASK          0x1
+ #define AUDCFG_IO_CTRL__SPDIFHDMI_EN__VALUE__INPUT  0x0
+ #define AUDCFG_IO_CTRL__SPDIFHDMI_EN__VALUE__OUTPUT 0x1
+ 
+ #define AUDCFG_IO_CTRL__PCMPLHDMI_EN__SHIFT         5
+ #define AUDCFG_IO_CTRL__PCMPLHDMI_EN__MASK          0x1
+ #define AUDCFG_IO_CTRL__PCMPLHDMI_EN__VALUE__INPUT  0x0
+ #define AUDCFG_IO_CTRL__PCMPLHDMI_EN__VALUE__OUTPUT 0x1
+ 
+ #define AUDCFG_IO_CTRL__CLKREC_SEL__SHIFT            9
+ #define AUDCFG_IO_CTRL__CLKREC_SEL__MASK             0x3
+ #define AUDCFG_IO_CTRL__CLKREC_SEL__VALUE__PCMPLHDMI 0x0
+ #define AUDCFG_IO_CTRL__CLKREC_SEL__VALUE__SPDIFHDMI 0x1
+ #define AUDCFG_IO_CTRL__CLKREC_SEL__VALUE__PCMPL1    0x2
+ 
+ #endif
diff -rcN linux-sh4-2.6.23.17_stm23_0119-orig/include/linux/stm/registers//stx7200/audcfg.h linux-sh4/include/linux/stm/registers//stx7200/audcfg.h
*** linux-sh4-2.6.23.17_stm23_0119-orig/include/linux/stm/registers//stx7200/audcfg.h	1970-01-01 01:00:00.000000000 +0100
--- linux-sh4/include/linux/stm/registers//stx7200/audcfg.h	2009-06-10 11:15:48.000000000 +0200
***************
*** 0 ****
--- 1,79 ----
+ #ifndef __STM_REGISTERS_STX7200_AUDCFG_H
+ #define __STM_REGISTERS_STX7200_AUDCFG_H
+ 
+ 
+ 
+ #define AUDCFG_IOMUX_CTRL 0x00
+ 
+ #define AUDCFG_IOMUX_CTRL__PCM_CLK_EN__SHIFT         0
+ #define AUDCFG_IOMUX_CTRL__PCM_CLK_EN__MASK          0x1
+ #define AUDCFG_IOMUX_CTRL__PCM_CLK_EN__VALUE__INPUT  0x0
+ #define AUDCFG_IOMUX_CTRL__PCM_CLK_EN__VALUE__OUTPUT 0x1
+ 
+ #define AUDCFG_IOMUX_CTRL__DATA0_EN__SHIFT         1
+ #define AUDCFG_IOMUX_CTRL__DATA0_EN__MASK          0x1
+ #define AUDCFG_IOMUX_CTRL__DATA0_EN__VALUE__INPUT  0x0
+ #define AUDCFG_IOMUX_CTRL__DATA0_EN__VALUE__OUTPUT 0x1
+ 
+ #define AUDCFG_IOMUX_CTRL__DATA1_EN__SHIFT         2
+ #define AUDCFG_IOMUX_CTRL__DATA1_EN__MASK          0x1
+ #define AUDCFG_IOMUX_CTRL__DATA1_EN__VALUE__INPUT  0x0
+ #define AUDCFG_IOMUX_CTRL__DATA1_EN__VALUE__OUTPUT 0x1
+ 
+ #define AUDCFG_IOMUX_CTRL__DATA2_EN__SHIFT         3
+ #define AUDCFG_IOMUX_CTRL__DATA2_EN__MASK          0x1
+ #define AUDCFG_IOMUX_CTRL__DATA2_EN__VALUE__INPUT  0x0
+ #define AUDCFG_IOMUX_CTRL__DATA2_EN__VALUE__OUTPUT 0x1
+ 
+ #define AUDCFG_IOMUX_CTRL__SPDIF_EN__SHIFT          4
+ #define AUDCFG_IOMUX_CTRL__SPDIF_EN__MASK           0x1
+ #define AUDCFG_IOMUX_CTRL__SPDIF_EN__VALUE__DISABLE 0x0
+ #define AUDCFG_IOMUX_CTRL__SPDIF_EN__VALUE__ENABLE  0x1
+ 
+ 
+ 
+ #define AUDCFG_HDMI_CTRL 0x04
+ 
+ #define AUDCFG_HDMI_CTRL__HDMI_DEBUG__SHIFT              0
+ #define AUDCFG_HDMI_CTRL__HDMI_DEBUG__MASK               0x1
+ #define AUDCFG_HDMI_CTRL__HDMI_DEBUG__VALUE__PCM_PLAYERS 0x0
+ #define AUDCFG_HDMI_CTRL__HDMI_DEBUG__VALUE__HDMI        0x1
+ 
+ #define AUDCFG_HDMI_CTRL__HDMI_SPDIF__SHIFT              1
+ #define AUDCFG_HDMI_CTRL__HDMI_SPDIF__MASK               0x1
+ #define AUDCFG_HDMI_CTRL__HDMI_SPDIF__VALUE_PCM_PLAYER   0x0
+ #define AUDCFG_HDMI_CTRL__HDMI_SPDIF__VALUE_SPDIF_PLAYER 0x1
+ 
+ 
+ 
+ #define AUDCFG_RECOVERY_CTRL 0x08
+ 
+ #define AUDCFG_RECOVERY_CTRL__RECO_EN0__SHIFT 0
+ #define AUDCFG_RECOVERY_CTRL__RECO_EN0__MASK  0x1
+ 
+ #define AUDCFG_RECOVERY_CTRL__RECO_SEL0__SHIFT       1
+ #define AUDCFG_RECOVERY_CTRL__RECO_SEL0__MASK        0x3
+ #define AUDCFG_RECOVERY_CTRL__RECO_SEL0__VALUE__CLK0 0x0
+ #define AUDCFG_RECOVERY_CTRL__RECO_SEL0__VALUE__CLK1 0x1
+ #define AUDCFG_RECOVERY_CTRL__RECO_SEL0__VALUE__CLK2 0x2
+ #define AUDCFG_RECOVERY_CTRL__RECO_SEL0__VALUE__CLK3 0x3
+ 
+ #define AUDCFG_RECOVERY_CTRL__RECO_EXT0__SHIFT 3
+ #define AUDCFG_RECOVERY_CTRL__RECO_EXT0__MASK  0x1
+ 
+ #define AUDCFG_RECOVERY_CTRL__RECO_EN1__SHIFT 4
+ #define AUDCFG_RECOVERY_CTRL__RECO_EN1__MASK  0x1
+ 
+ #define AUDCFG_RECOVERY_CTRL__RECO_SEL1__SHIFT       5
+ #define AUDCFG_RECOVERY_CTRL__RECO_SEL1__MASK        0x3
+ #define AUDCFG_RECOVERY_CTRL__RECO_SEL1__VALUE__CLK0 0x0
+ #define AUDCFG_RECOVERY_CTRL__RECO_SEL1__VALUE__CLK1 0x1
+ #define AUDCFG_RECOVERY_CTRL__RECO_SEL1__VALUE__CLK2 0x2
+ #define AUDCFG_RECOVERY_CTRL__RECO_SEL1__VALUE__CLK3 0x3
+ 
+ #define AUDCFG_RECOVERY_CTRL__RECO_EXT1__SHIFT 7
+ #define AUDCFG_RECOVERY_CTRL__RECO_EXT1__MASK  0x1
+ 
+ 
+ 
+ #endif
*** linux-sh4-2.6.23.17_stm23_0119-orig/include/linux/stm/registers.h	1970-01-01 01:00:00.000000000 +0100
--- linux-sh4/include/linux/stm/registers.h	2009-07-18 22:20:33.000000000 +0200
***************
*** 0 ****
--- 1,100 ----
+ #ifndef __LINUX_STM_REGISTERS_H
+ #define __LINUX_STM_REGISTERS_H
+ 
+ #include <asm/io.h>
+ 
+ 
+ 
+ /* Register access macros */
+ 
+ #define REGISTER_PEEK(base, reg) \
+ 		readl(base + reg)
+ 
+ #define REGISTER_PEEK_N(base, reg, n) \
+ 		readl(base + reg(n))
+ 
+ #define REGISTER_POKE(base, reg, u32value) \
+ 		writel(u32value, base + reg)
+ 
+ #define REGISTER_POKE_N(base, reg, n, u32value) \
+ 		writel(u32value, base + reg(n))
+ 
+ 
+ 
+ /* Field raw access macros */
+ 
+ #define REGFIELD_PEEK(base, reg, field) \
+ 		regfield_peek(base, reg, reg##__##field##__SHIFT, \
+ 				reg##__##field##__MASK)
+ 
+ #define REGFIELD_PEEK_N(base, reg, n, field) \
+ 		regfield_peek(base, reg(n), reg##__##field##__SHIFT, \
+ 				reg##__##field##__MASK)
+ 
+ #define REGFIELD_POKE(base, reg, field, u32value) \
+ 		regfield_poke(base, reg, reg##__##field##__SHIFT, \
+ 				reg##__##field##__MASK, u32value)
+ 
+ #define REGFIELD_POKE_N(base, reg, n, field, u32value) \
+ 		regfield_poke(base, reg(n), reg##__##field##__SHIFT, \
+ 				reg##__##field##__MASK, u32value)
+ 
+ 
+ 
+ /* Field named values access macro */
+ 
+ #define REGFIELD_SET(base, reg, field, valuename) \
+ 		regfield_poke(base, reg, reg##__##field##__SHIFT, \
+ 				reg##__##field##__MASK, reg##__##field##__VALUE__##valuename)
+ 
+ #define REGFIELD_SET_N(base, reg, n, field, valuename) \
+ 		regfield_poke(base, reg(n), reg##__##field##__SHIFT, \
+ 				reg##__##field##__MASK, reg##__##field##__VALUE__##valuename)
+ 
+ 
+ 
+ /* Bitmask generator macros */
+ 
+ #define REGFIELD_MASK(reg, field) \
+ 		(reg##__##field##__MASK << reg##__##field##__SHIFT)
+ 
+ #define REGFIELD_VALUE(reg, field, valuename) \
+ 		(reg##__##field##__VALUE__##valuename << reg##__##field##__SHIFT)
+ 
+ 
+ 
+ /* Register fields runtime access */
+ 
+ static inline unsigned long regfield_peek(void *base, unsigned long offset,
+ 		int shift, unsigned long mask)
+ {
+ 	return ((readl(base + offset) >> shift) & mask);
+ }
+ 
+ static inline void regfield_poke(void *base, unsigned long offset,
+ 		int shift, unsigned long mask, unsigned long value)
+ {
+ 	writel(((readl(base + offset) & ~(mask << shift)) |
+ 				((value & mask) << shift)), base + offset);
+ }
+ 
+ 
+ 
+ /* COMMs registers definitions */
+ 
+ #include <linux/stm/registers/asc.h>
+ #include <linux/stm/registers/pwm.h>
+ 
+ /* Audio registers definitions */
+ 
+ #include <linux/stm/registers/aud_pcmin.h>
+ #include <linux/stm/registers/aud_pcmout.h>
+ #include <linux/stm/registers/aud_spdif.h>
+ #include <linux/stm/registers/aud_spdifpc.h>
+ #include <linux/stm/registers/audcfg.h>
+ #include <linux/stm/registers/audcfg_adac.h>
+ #include <linux/stm/registers/audcfg_fsyn.h>
+ 
+ 
+ 
+ #endif
diff -urN linux-sh4-2.6.23.17_stm23_0119-orig/include/linux/stm_/fdma-reqs.h linux-sh4/include/linux/stm/fdma-reqs.h
--- linux-sh4-2.6.23.17_stm23_0119-orig/include/linux/stm_/fdma-reqs.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-sh4/include/linux/stm/fdma-reqs.h	2010-02-08 11:20:20.000000000 +0100
@@ -0,0 +1,130 @@
+/*
+ * Copyright (C) 2007 STMicroelectronics Limited
+ * Authors: Mark Glaisher <Mark.Glaisher@st.com>
+ *          Stuart Menefy <stuart.menefy@st.com>
+ *
+ * May be copied or modified under the terms of the GNU General Public
+ * License.  See linux/COPYING for more information.
+ */
+
+enum __stb7100_fdma_req_ids {
+	STB7100_FDMA_REQ_SPDIF_TEST =	0,
+	STB7100_FDMA_REQ_NOT_CONN_1,
+	STB7100_FDMA_REQ_NOT_CONN_2,
+	STB7100_FDMA_REQ_VIDEO_HDMI,
+	STB7100_FDMA_REQ_DISEQC_HALF_EMPTY,
+	STB7100_FDMA_REQ_DISEQC_HALF_FULL,
+	STB7100_FDMA_REQ_SH4_SCIF_RX,
+	STB7100_FDMA_REQ_SH4_SCIF_TX,
+	STB7100_FDMA_REQ_SSC_0_RX,
+	STB7100_FDMA_REQ_SSC_1_RX,
+	STB7100_FDMA_REQ_SSC_2_RX,	/* 10 */
+	STB7100_FDMA_REQ_SSC_0_TX,
+	STB7100_FDMA_REQ_SSC_1_TX,
+	STB7100_FDMA_REQ_SSC_2_TX,
+	STB7100_FDMA_REQ_UART_0_RX,
+	STB7100_FDMA_REQ_UART_1_RX,
+	STB7100_FDMA_REQ_UART_2_RX,
+	STB7100_FDMA_REQ_UART_3_RX,
+	STB7100_FDMA_REQ_UART_0_TX,
+	STB7100_FDMA_REQ_UART_1_TX,
+	STB7100_FDMA_REQ_UART_2_TX,	/* 20 */
+	STB7100_FDMA_REQ_UART_3_TX,
+	STB7100_FDMA_REQ_EXT_PIO_0,
+	STB7100_FDMA_REQ_EXT_PIO_1,
+	STB7100_FDMA_REQ_CPXM_DECRYPT,
+	STB7100_FDMA_REQ_CPXM_ENCRYPT,
+	STB7100_FDMA_REQ_PCM_0,
+	STB7100_FDMA_REQ_PCM_1,
+	STB7100_FDMA_REQ_PCM_READ,
+	STB7100_FDMA_REQ_SPDIF,
+	STB7100_FDMA_REQ_SWTS,		/* 30 */
+	STB7100_FDMA_REQ_UNUSED
+};
+
+enum __stb7109_fdma_reqids {
+	STB7109_FDMA_REQ_UNUSED =0,//0
+	STB7109_FDMA_DMA_REQ_HDMI_AVI,
+	STB7109_FDMA_REQ_DISEQC_HALF_EMPTY,
+	STB7109_FDMA_REQ_DISEQC_HALF_FULL,
+	STB7109_FDMA_REQ_SH4_SCIF_RX,
+	STB7109_FDMA_REQ_SH4_SCIF_TX,//5
+	STB7109_FDMA_REQ_SSC_0_RX,//6-8
+	STB7109_FDMA_REQ_SSC_1_RX,
+	STB7109_FDMA_REQ_SSC_2_RX,
+	STB7109_FDMA_REQ_SSC_0_TX,//9-11
+	STB7109_FDMA_REQ_SSC_1_TX,
+	STB7109_FDMA_REQ_SSC_2_TX,
+	STB7109_FDMA_REQ_UART_0_RX,//12-15
+	STB7109_FDMA_REQ_UART_1_RX,
+	STB7109_FDMA_REQ_UART_2_RX,
+	STB7109_FDMA_REQ_UART_3_RX,
+	STB7109_FDMA_REQ_UART_0_TX,//16-19
+	STB7109_FDMA_REQ_UART_1_TX,
+	STB7109_FDMA_REQ_UART_2_TX,
+	STB7109_FDMA_REQ_UART_3_TX,
+	STB7109_FDMA_REQ_REQ_EXT_PIO_0,//20
+	STB7109_FDMA_REQ_REQ_EXT_PIO_1,//21
+	STB7109_FDMA_REQ_CPXM_DECRYPT,
+	STB7109_FDMA_REQ_CPXM_ENCRYPT,
+	STB7109_FDMA_REQ_PCM_0=24,//24
+	STB7109_FDMA_REQ_PCM_1,
+	STB7109_FDMA_REQ_PCM_READ,
+	STB7109_FDMA_REQ_SPDIF,
+	STB7109_FDMA_REQ_SWTS_0,
+	STB7109_FDMA_REQ_SWTS_1,
+	STB7109_FDMA_REQ_SWTS_2
+};
+
+enum __stb7200_fdma_reqids {
+	STB7200_FDMA_REQ_CNT0 =0,
+	STB7200_FDMA_REQ_CNT1,
+	STB7200_FDMA_REQ_HDMI,
+	STB7200_FDMA_REQ_DISEQC0_TX_HALF_EMPTY,
+	STB7200_FDMA_REQ_DISEQC0_RX_HALF_FULL,
+	STB7200_FDMA_REQ_DISEQC1_TX_HALF_EMPTY,
+	STB7200_FDMA_REQ_DISEQC1_RX_HALF_FULL,
+	STB7200_FDMA_REQ_SH4_SCIF_RX,
+	STB7200_FDMA_REQ_SH4_SCIF_TX,
+	STB7200_FDMA_REQ_SSC_0_RX,
+	STB7200_FDMA_REQ_SSC_1_RX,//10
+	STB7200_FDMA_REQ_SSC_2_RX,
+	STB7200_FDMA_REQ_SSC_3_RX,
+	STB7200_FDMA_REQ_SSC_4_RX,
+	STB7200_FDMA_REQ_SSC_0_TX,
+	STB7200_FDMA_REQ_SSC_1_TX,
+	STB7200_FDMA_REQ_SSC_2_TX,
+	STB7200_FDMA_REQ_SSC_3_TX,
+	STB7200_FDMA_REQ_SSC_4_TX,//18
+	STB7200_FDMA_REQ_UART_0_RX,
+	STB7200_FDMA_REQ_UART_1_RX,
+	STB7200_FDMA_REQ_UART_2_RX,
+	STB7200_FDMA_REQ_UART_3_RX,
+	STB7200_FDMA_REQ_UART_0_TX,
+	STB7200_FDMA_REQ_UART_1_TX,
+	STB7200_FDMA_REQ_UART_2_TX,
+	STB7200_FDMA_REQ_UART_3_TX,
+	STB7200_FDMA_REQ_EMI_DMA0,
+	STB7200_FDMA_REQ_EMI_DMA1,
+	STB7200_FDMA_REQ_CPXM_DECRYPT_IN,
+	STB7200_FDMA_REQ_CPXM_DECRYPT_OUT,//30
+	STB7200_FDMA_REQ_CPXM_ENCRYPT_IN,
+	STB7200_FDMA_REQ_CPXM_ENCRYPT_OUT,
+	STB7200_FDMA_REQ_PCM0,
+	STB7200_FDMA_REQ_PCM1,
+	STB7200_FDMA_REQ_PCM2,
+	STB7200_FDMA_REQ_PCM3,
+	STB7200_FDMA_REQ_PCMIN,
+	STB7200_FDMA_REQ_SPDIF,
+	STB7200_FDMA_REQ_HDMI_PCM,
+	STB7200_FDMA_REQ_HDMI_SPDIF,
+	STB7200_FDMA_REQ_TELETEXT,
+	STB7200_FDMA_REQ_TELETEXT_SDOUT,
+	STB7200_FDMA_REQ_MODEM_PCM_PLAY,
+	STB7200_FDMA_REQ_MODEM_PCM_READ,
+	STB7200_FDMA_REQ_UHF_EMPTY,
+	STB7200_FDMA_REQ_UHF_FULL,
+	STB7200_FDMA_REQ_SRC_IP,
+	STB7200_FDMA_REQ_SRC_OP
+	/*49 - 54 reserved*/
+};
diff -urN linux-sh4-2.6.23.17_stm23_0119-orig/sound/stm/common.c linux-sh4/sound/stm/common.c
--- linux-sh4-2.6.23.17_stm23_0119-orig/sound/stm/common.c	2010-03-11 11:30:34.000000000 +0100
+++ linux-sh4/sound/stm/common.c	2010-03-11 11:39:22.000000000 +0100
@@ -221,7 +221,7 @@
 		return -EINVAL;
 	}
 
-	snd_stm_printd(0, "Base address is 0x%p.\n", *base_address);
+	snd_printd("Base address is 0x%p.\n", *base_address);
 
 	return 0;
 }
